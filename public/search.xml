<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Security笔记---基本原理及认证流程</title>
      <link href="/20219/05/23/Security%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
      <url>/20219/05/23/Security%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Security笔记—基本原理及认证流程"><a href="#Spring-Security笔记—基本原理及认证流程" class="headerlink" title="Spring Security笔记—基本原理及认证流程"></a>Spring Security笔记—基本原理及认证流程</h1><h2 id="一、-基本原理"><a href="#一、-基本原理" class="headerlink" title="一、 基本原理"></a>一、 基本原理</h2><p><img src="https://img-blog.csdnimg.cn/20190820004415916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>黄色模块：SecurityContextPersistenceFilter是承接容器的session与spring security的重要filter，主要工作是从session中获取SecurityContext，然后放到上下文中，之后的filter大多依赖这个来获取登录态。其主要是通过HttpSessionSecurityContextRepository来存取的。</li><li>绿色模块：可选择添加的认证过滤器，用于验证用户登入信息是否正确，正确则保存在session,主要代码AbstractAuthenticationProcessingFilter抽象类的<code>SecurityContextHolder.getContext().setAuthentication(authResult)</code></li><li>橘色模块：FilterSecurityInterceptor 最后的大门，通过WebSecurityConfigurerAdapter或其实现类的<code>protected void configure(HttpSecurity http) throws Exception</code>的配置方法，来确定请求是否能访问</li><li>深蓝色模块：ExceptionTranslationFilter 用于获取橘色模块的异常信息，凡是橘色模块不通过的请求就会报错，被其接受</li></ul><h2 id="二、认证流程"><a href="#二、认证流程" class="headerlink" title="二、认证流程"></a>二、认证流程</h2><h3 id="1、-流程图"><a href="#1、-流程图" class="headerlink" title="1、 流程图"></a>1、 流程图</h3><p><img src="https://img-blog.csdnimg.cn/2019082000443247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、认证源码大致方向"><a href="#2、认证源码大致方向" class="headerlink" title="2、认证源码大致方向"></a>2、认证源码大致方向</h3><ul><li>大致源码流程比较绕口，不过不是想象中麻烦，具体源码我会在2.3 源码详情追综，希望大伙能坚持一下</li><li>递进流程：用户提交登入信息 —》AbstractAuthenticationProcessingFilter 的 dofilter(…)方法 —》UsernamePasswordAuthenticationFilterr 的 attemptAuthentication(…)方法获取用户名和密码生成未认证的UsernamePasswordAuthenticationToken（是Authentication的子类） —》 ProviderManager（AuthenticatonManager的子类）的 authenticate(…) 方法接受UsernamePasswordAuthenticationToken参数  —》 AbstractUserDetailsAuthenticationProvider（AuthenticationProvider的子类）authenticate(….)的方法里面的的 retrieveUser(…)  —》DaoAuthenticationProvider的 retrieveUser(…) —-》CustomUserDetailService(自己写的，是UserDetailService的子类)的loadUserByUsername(…) 获取用户信息 </li><li>返回流程：CustomUserDetailService 的 loadUserByUsername(…) 获取用户信息后—》AbstractUserDetailsAuthenticationProvider 的 createSuccessAuthentication(…) 把未认证的UsernamePasswordAuthenticationToken变成已认证的状态 —》AbstractAuthenticationProcessingFilter的successfulAuthentication(…) 的SecurityContextHolder.getContext().setAuthentication(authResult)；把UsernamePasswordAuthenticationToken存到Session</li></ul><h3 id="3、-源码详解"><a href="#3、-源码详解" class="headerlink" title="3、 源码详解"></a>3、 源码详解</h3><blockquote><p>我会抠出 2.2 认证源码大致方向的代码里面关键部分并标序号注释讲解，建议大家用debug模式打点，亲自测试更好记忆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"---------------AbstractAuthenticationProcessingFilter ---------------------------------"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">... 省略部分</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 调用UsernamePasswordAuthenticationFilterr(其子类)的attemptAuthentication(...)方法，跳到下个分割线处</span></span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) ...异常处理省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 16. 获取序号15的Authentication对象，调用该方法</span></span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Authentication success. Updating SecurityContextHolder to contain: "</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 17. 获取序号15的Authentication对象，保存在session中</span></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.eventPublisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 18.成功处理</span></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------------UsernamePasswordAuthenticationFilterr--------------------"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">           <span class="comment">// 请求方式必须是Post请求</span></span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line"><span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String username = obtainUsername(request);   <span class="comment">// 获取用户名</span></span><br><span class="line">String password = obtainPassword(request);   <span class="comment">// 获取密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">username = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">password = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">username = username.trim();</span><br><span class="line"><span class="comment">// 2. 生成UsernamePasswordAuthenticationToken（Authentication的子类）对象,跳到下个分割线处</span></span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line"></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. this.getAuthenticationManager() 获取Authentication的实现类，即ProviderManager，跳到下个分割线处</span></span><br><span class="line">       <span class="comment">//  15.获取序号14的Authenticaition对象，返回上个分割线</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------UsernamePasswordAuthenticationToken构造方法------------------------------"</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3. 因为刚登入所以是false，未认证状态, 回到上个分割线处</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">setAuthenticated(<span class="keyword">false</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------------------------ProviderManager-----------------------------------"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">...省略部分</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 选择那种认证方式</span></span><br><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!provider.supports(toTest)) &#123;   <span class="comment">// 判断该认证用那种AuthenticationProvider的实现类实现</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">+ provider.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 6. 找到相应的认证方式的子类后，即AbstractUserDetailsAuthenticationProvider类调用方法，跳到下个分割线处</span></span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 13.把序号12的UserDetails对象，赋值到result(Authentication)对象</span></span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccountStatusException e) ...异常处理省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line"><span class="comment">// Authentication is complete. Remove credentials and other secret data</span></span><br><span class="line"><span class="comment">// from authentication</span></span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">            <span class="comment">// 14. 序号13的result对象，到上个分割线</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------------AbstractUserDetailsAuthenticationProvider----------------------"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">...省略部分</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 7. 通过DaoAuthenticationProvider(即AbstractUserDetailsAuthenticationProvide的子类)实现类方法来获取UserDetail对象，跳到下个分割线处</span></span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">                <span class="comment">// 11. 获取序号10的的UserDetails对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UsernameNotFoundException notFound) ... 异常处理省略</span><br><span class="line"></span><br><span class="line">Assert.notNull(user,</span><br><span class="line"><span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xxx.check(user) 用于验证用户信息是否合理,跟UserDetails构造方法有关，里面有一个为false，则报错不通过</span></span><br><span class="line">    <span class="comment">// User user = new User("zhangsan",  /// 用户名</span></span><br><span class="line">        <span class="comment">//      password,  // 密码</span></span><br><span class="line">        <span class="comment">//        true,  // 账号是否失效</span></span><br><span class="line">        <span class="comment">//        true,   // 账号是否过期</span></span><br><span class="line">        <span class="comment">//        true,  // 密码是否过期</span></span><br><span class="line">        <span class="comment">//        true,  // 账号是否冻结</span></span><br><span class="line">        <span class="comment">//        AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">preAuthenticationChecks.check(user);  </span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException exception) ...异常处理省略</span><br><span class="line"></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 12. 返回序号11的的UserDetails对象, 通过createSuccessAuthentication使其变成已认证状态</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"------------------------------------DaoAuthenticationProvider--------------------------"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">prepareTimingAttackProtection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 8. 通过自定义UserDetailService的子类来获取UserDetails对象---用户信息,跳到下个分割线</span></span><br><span class="line">UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line"><span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line"><span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 10. 获取序号9的UserDetails对象，返回上个分割线</span></span><br><span class="line"><span class="keyword">return</span> loadedUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UsernameNotFoundException ex) ...异常处理省略</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"----------------------CustomUserDetailService-----------------------------------"</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 9。获取用户信息，不连接数据库（虚拟账号），获取成功跳到上个分割线</span></span><br><span class="line">        log.info(<span class="string">"【CustomUserDetailService】根据用户名获取用户信息, username = &#123;&#125;"</span>, username);</span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">"123"</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"zhangsan"</span>,  <span class="comment">/// 用户名</span></span><br><span class="line">                password,  <span class="comment">// 密码</span></span><br><span class="line">                <span class="keyword">true</span>,  <span class="comment">// 账号是否失效</span></span><br><span class="line">                <span class="keyword">true</span>,   <span class="comment">// 账号是否过期</span></span><br><span class="line">                <span class="keyword">true</span>,  <span class="comment">// 密码是否过期</span></span><br><span class="line">                <span class="keyword">true</span>,  <span class="comment">// 账号是否冻结</span></span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>));</span><br><span class="line">        log.info(<span class="string">"【CustomUserDetailService】 password = &#123;&#125;"</span>, password);</span><br><span class="line">        log.info(<span class="string">"【CustomUserDetailService】获取User对象，user = &#123;&#125;"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程--java内存模型</title>
      <link href="/2020/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程--线程和线程池</title>
      <link href="/2020/01/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/01/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程–线程池和多线程"><a href="#并发编程–线程池和多线程" class="headerlink" title="并发编程–线程池和多线程"></a>并发编程–线程池和多线程</h1><p>[toc]</p><h2 id="一、什么是线程和进程"><a href="#一、什么是线程和进程" class="headerlink" title="一、什么是线程和进程"></a>一、什么是线程和进程</h2><h4 id="什么是进程？什么是线程？"><a href="#什么是进程？什么是线程？" class="headerlink" title="什么是进程？什么是线程？"></a>什么是进程？什么是线程？</h4><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p><p>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。</p><p>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程与进程的一个主要区别是，统一进程内的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写这些栈内存。</p><p>线程是进程的一个实体，是进程的一条执行路径。</p><p>线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。</p><h4 id="进程和线程的区别体现在以下几个方面："><a href="#进程和线程的区别体现在以下几个方面：" class="headerlink" title="进程和线程的区别体现在以下几个方面："></a>进程和线程的区别体现在以下几个方面：</h4><p>1.地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其他进程内不可见。</p><p>2.通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间可以直接独写进程数据段（如全局变量）来进程通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p><p>3.调度和切换：线程上下文切换比进程上下文切换快得多。</p><p>4.在多线程OS中，进程不是一个可执行的实体。</p><h4 id="进程和线程的选择取决以下几点："><a href="#进程和线程的选择取决以下几点：" class="headerlink" title="进程和线程的选择取决以下几点："></a>进程和线程的选择取决以下几点：</h4><p>1.需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程的代价是很大的。</p><p>2.线程的切换速度快，所以在需要大量计算，切换频繁时使用线程，还有耗时的操作时用使用线程可提高应用程序的响应。</p><p>3.因为对CPU系统的效率使用上线程更占优势，所以可能要发展到多机分布的用进程，多核分布用线程。</p><p>4.并行操作时用线程，如C/S架构的服务器端并发线程响应用户的请求。</p><p>5.需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p><h2 id="二、多线程排查死锁命令和操作"><a href="#二、多线程排查死锁命令和操作" class="headerlink" title="二、多线程排查死锁命令和操作"></a>二、多线程排查死锁命令和操作</h2><p> <a href="https://blog.csdn.net/u014039577/article/details/52351626" target="_blank" rel="noopener">https://blog.csdn.net/u014039577/article/details/52351626</a> </p><p>​        </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入了解JVM--内存模型</title>
      <link href="/2019/06/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/06/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Redis--Redis核心原理</title>
      <link href="/2019/06/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis-Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis-Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="深入了解Redis–Redis核心原理"><a href="#深入了解Redis–Redis核心原理" class="headerlink" title="深入了解Redis–Redis核心原理"></a>深入了解Redis–Redis核心原理</h1><h2 id="一、Redis的单线程和高性能"><a href="#一、Redis的单线程和高性能" class="headerlink" title="一、Redis的单线程和高性能"></a>一、Redis的单线程和高性能</h2><h3 id="1、Redis-单线程为什么还能这么快？"><a href="#1、Redis-单线程为什么还能这么快？" class="headerlink" title="1、Redis 单线程为什么还能这么快？"></a>1、Redis 单线程为什么还能这么快？</h3><p>因为它所有的数据都在内存中，所有的运算都是<strong>内存级别的运算</strong>( 一个常规的命令，set/get操作，时间是<strong>纳秒</strong>级别的，redis理想情况下<strong>QPS为10W/s</strong>)，而且单线程<strong>避免了多线程的切换性能损耗</strong>问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。 </p><h3 id="2、Redis单线程如何处理那么多的并发客户端连接？"><a href="#2、Redis单线程如何处理那么多的并发客户端连接？" class="headerlink" title="2、Redis单线程如何处理那么多的并发客户端连接？"></a>2、Redis单线程如何处理那么多的并发客户端连接？</h3><p>Redis的<strong>IO多路复用</strong>：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581431818149.png" alt="1581431818149"></p><h2 id="二、Redis持久化"><a href="#二、Redis持久化" class="headerlink" title="二、Redis持久化"></a>二、Redis持久化</h2><h3 id="1、RDB快照（snapshot）"><a href="#1、RDB快照（snapshot）" class="headerlink" title="1、RDB快照（snapshot）"></a>1、RDB快照（snapshot）</h3><p>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。</p><p>你可以对 Redis  进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</p><figure class="highlight plain"><figcaption><span>60 1000````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">默认设置</span><br><span class="line"></span><br><span class="line"> ![1581432750276](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;1581432750276.png)</span><br><span class="line"></span><br><span class="line">### 2、AOF（append-only file）</span><br><span class="line"></span><br><span class="line">快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将修改的每一条指令记录进文件</span><br><span class="line"></span><br><span class="line">你可以通过修改配置文件来打开 AOF 功能：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96; appendonly yes</span><br></pre></td></tr></table></figure><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 <a href="http://redisdoc.com/string/set.html#set" target="_blank" rel="noopener">SET</a>）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><p>你可以配置 Redis 多久才将数据 fsync (<strong>持久化</strong>)到磁盘一次。</p><p>有三个选项：</p><ol><li>`````appendfsync always````每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li><li><code>appendfsync everysec</code>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li><code>appendfsync no</code> 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ol><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p><code>more appendonly.aof</code>查看aof文件内容，文件内容存储使用<a href="https://www.cnblogs.com/tommy-huang/p/6051577.html" target="_blank" rel="noopener">Redis协议规范(RESP)</a></p><h3 id="3、RDB-和-AOF-，我应该用哪一个？"><a href="#3、RDB-和-AOF-，我应该用哪一个？" class="headerlink" title="3、RDB 和 AOF ，我应该用哪一个？"></a>3、RDB 和 AOF ，我应该用哪一个？</h3><p> 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><blockquote><p>你们可能有这么一个疑问？可以把RDB的快照时间设为每秒，可是实际上，每次快照，就要把整个内存数据快照，一般企业的Redis都是GB级别，这样花时间就，效率低下</p></blockquote><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式，因为如果aof文件非常大，如果有几个GB的话，Redis重启的话，Redis执行aof文件里面的命令，启动慢，效率低</p><p>那么如何选择呢？就是接下来要讲的</p><h3 id="4、Redis-4-0-混合持久化"><a href="#4、Redis-4-0-混合持久化" class="headerlink" title="4、Redis 4.0 混合持久化"></a>4、Redis 4.0 混合持久化</h3><p>重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。</p><p><strong>AOF在重写</strong>(aof文件里可能有太多没用指令，所以aof会定期根据内存的最新数据生成aof文件)<strong>时将重写这一刻把内存进行rdb快照和增加修改内存数据的命令追加aof文件( aof文件是新的aof文件 )末尾，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换；</strong></p><p>AOF根据配置规则在后台自动重写，也可以人为执行命令<strong>bgrewriteaof</strong>重写AOF。 于是在 Redis 重启的时候，可以<strong>先加载 rdb 的内容</strong>，然后再<strong>重放增量 AOF 日志</strong>就可以完全<strong>替代</strong>之前的 <strong>AOF 全量文件重放</strong>，重启效率因此大幅得到提升。</p><p>开启混合持久化：</p><p><code>aof-use-rdb-preamble yes</code>  </p><p>配置：</p><p><code>auto-aof-rewrite-percentage 100</code>：当容量一翻倍，aof就会重写</p><p><code>auto-aof-rewrite-min-size 64mb</code>：当容量超过64M时，才会执行上一条指令翻倍重写</p><p>混合持久化aof文件结构</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581434824790.png" alt="1581434824790"></p><p>​                                </p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Redis--Redis基本介绍</title>
      <link href="/2019/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redi--Redis%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redi--Redis%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Redis–Redis基本介绍"><a href="#深入理解Redis–Redis基本介绍" class="headerlink" title="深入理解Redis–Redis基本介绍"></a>深入理解Redis–Redis基本介绍</h1><h2 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h2><p>redis 简介<br> <strong>Redis</strong>是一个基于<strong>内存</strong>的高性能<strong>key-value</strong>数据库，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h2 id="二、Redis与Mecache区别"><a href="#二、Redis与Mecache区别" class="headerlink" title="二、Redis与Mecache区别"></a>二、Redis与Mecache区别</h2><ol><li>持久性<ul><li>Redis可以将内存中的数据保持在<strong>磁盘</strong>中，<strong>重启</strong>的时候可以<strong>再次加载</strong>进行使用，保证数据的持久性</li><li>Memecache把数据全部存在<strong>内存</strong>之中，<strong>断电后会挂掉</strong>，数据不能超过内存大小。</li></ul></li><li>数据类型<ul><li>Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的<strong>k/v</strong>类型的数据，同时还提供<strong>String，List,Set,Hash,Sorted Set</strong>数据结构的存储。</li><li>memcache支持<strong>简单数据类型</strong>，需要客户端自己处理复杂对象 </li></ul></li><li>存储键值大小<ul><li>Redis单个value的最大限制是<strong>1GB</strong></li><li>memcached只能保存<strong>1MB</strong>的数据 </li></ul></li></ol><h2 id="三、Redis基本数据类型"><a href="#三、Redis基本数据类型" class="headerlink" title="三、Redis基本数据类型"></a>三、Redis基本数据类型</h2><ol><li><p>String</p><p>字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。字符串结构使用非常广泛，一个常见的用途就是<strong>缓存用户信息</strong>。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程    </p></li><li><p>list</p><p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p></li><li><p>hash</p><p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的<strong>数组 + 链表</strong>二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对 用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。 hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p></li><li><p>set</p><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值NULL。 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 </p></li><li><p>zset</p><p>zset 似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。</p><p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 </p><p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p></li></ol><h2 id="四、Redis命令注意点"><a href="#四、Redis命令注意点" class="headerlink" title="四、Redis命令注意点"></a>四、Redis命令注意点</h2><p>尽量不要使用<strong>keys</strong>作为模糊查询redis中的键，而是使用<strong>scan</strong>。</p><p>理由：</p><ol><li>因为Redis是单线程，如果Redis的key有1000W的话，使用keys模糊查询查询的时间<strong>很高</strong>，线程<strong>阻塞</strong>，其他线程命令就无法执行，降低性能。</li><li>使用scan<strong>，通过<code>scan 0 match &lt;关键字&gt; count &lt;数量&gt;</code>，能够</strong>根据关键字<strong>获取</strong>规定数量<strong>的</strong>键值**。可以多次使用该命令迭代获取全部数据，每次命令执行时间短，不会过多的阻塞其他线程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful风格设计</title>
      <link href="/2019/05/12/Restful%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/05/12/Restful%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Restful风格设计"><a href="#Restful风格设计" class="headerlink" title="Restful风格设计"></a>Restful风格设计</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="Restful-其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的-API-设计规范，用于-Web-数据接口的设计"><a href="#Restful-其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的-API-设计规范，用于-Web-数据接口的设计" class="headerlink" title="Restful 其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的 API 设计规范，用于 Web 数据接口的设计"></a>Restful 其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的 API 设计规范，用于 Web 数据接口的设计</h3><h2 id="二-为什么使用Restful风格"><a href="#二-为什么使用Restful风格" class="headerlink" title="二. 为什么使用Restful风格"></a>二. 为什么使用Restful风格</h2><h3 id="1-普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢"><a href="#1-普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢" class="headerlink" title="1. 普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢"></a>1. 普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢</h3><h3 id="2-，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率"><a href="#2-，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率" class="headerlink" title="2.，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率"></a>2.，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率</h3><h2 id="三、Restful的规范"><a href="#三、Restful的规范" class="headerlink" title="三、Restful的规范"></a>三、Restful的规范</h2><blockquote><p>Restful很简单，就像数学公式一样，知道一些要点就会灵活运用，切记死记硬背</p></blockquote><h3 id="1-Url链接模式：动词-宾语"><a href="#1-Url链接模式：动词-宾语" class="headerlink" title="1.Url链接模式：动词+宾语"></a>1.Url链接模式：动词+宾语</h3><h3 id="2-动词：代表请求方式"><a href="#2-动词：代表请求方式" class="headerlink" title="2. 动词：代表请求方式"></a>2. 动词：代表请求方式</h3><ul><li>GET：获取（Get）</li><li>POST：添加（Create）</li><li>PUT：更新（Update）</li><li>DELETE：删除（Delete）</li></ul><h3 id="3-宾语：必须是名词"><a href="#3-宾语：必须是名词" class="headerlink" title="3. 宾语：必须是名词"></a>3. 宾语：必须是名词</h3><ul><li><a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a>   user:就是名词，想用复数表示的话，就跟英语一样，直接在后面加s，即<a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a></li><li>尽量避免多级请求：<a href="http://localhost:8080/management/1/user/1" target="_blank" rel="noopener">http://localhost:8080/management/1/user/1</a> 应该为：<a href="http://localhost:8080/management/1?user=1" target="_blank" rel="noopener">http://localhost:8080/management/1?user=1</a> (具体意思和用处后面详解)</li></ul><h3 id="4根据上面两点组合起来"><a href="#4根据上面两点组合起来" class="headerlink" title="4根据上面两点组合起来"></a>4根据上面两点组合起来</h3><ul><li>GET：<a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> 获取用户id=1信息</li><li>POST：<a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a>  添加用户信息（post请求的参数无法查看）</li><li>PUT：<a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a>  更新用户信息 todo:待完成</li><li>DELETE：<a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> 删除用户id=1信息</li></ul><h3 id="5-测试用例-详细代码"><a href="#5-测试用例-详细代码" class="headerlink" title="5.测试用例,详细代码"></a>5.测试用例,详细代码</h3><blockquote><p>接下来之后显示跟本次主题相关的代码，详细代码请见：<a href="https://github.com/ChaASuc/restful-demo.git，" target="_blank" rel="noopener">https://github.com/ChaASuc/restful-demo.git，</a> 如果觉得可以就fork一下，谢谢。有问题请发言，鄙人会虚心听取<br>该项目使用SpringBoot + tkMapper + H2数据库模式，直接运行即可使用<br>里面封装后台开发通用代码，也可以看我的实际项目—-个人博客系统：<a href="https://github.com/ChaASuc/myblog.git，" target="_blank" rel="noopener">https://github.com/ChaASuc/myblog.git，</a> 该项目内容更全，技术点更多，希望对你有帮助</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190812220550723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-1、添加用户"><a href="#5-1、添加用户" class="headerlink" title="5.1、添加用户"></a>5.1、添加用户</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//请求方式：Post;</span></span><br><span class="line">  <span class="comment">//请求路径 http://localhost:8080/user;</span></span><br><span class="line">  <span class="comment">// 请求参数User对象</span></span><br><span class="line">  <span class="comment">// 含义：把user对象添加数据库中</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultVO <span class="title">insertUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          @RequestBody User user</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      userService.insertUser(user);</span><br><span class="line">      ResultVO.success();</span><br><span class="line">      <span class="keyword">return</span> ResultVO.success();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812215824743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-2、获取用户信息"><a href="#5-2、获取用户信息" class="headerlink" title="5.2、获取用户信息"></a>5.2、获取用户信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求方式：Get;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/user/&#123;id&#125;;</span></span><br><span class="line"><span class="comment">// 含义：把根据id获取用户信息</span></span><br><span class="line"><span class="comment">// @PathVariable 获取链接&#123;&#125;里面的值：例如http://localhost:8080/user/1 即 id = 1</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">selectUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable Long id</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    User user = userService.selectUser(id);</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812223401709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求方式：Get;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/users;   users是复数形式</span></span><br><span class="line"><span class="comment">// 含义：获取所有用户信息</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">selectUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userService.selectUsers();</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812223617463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-3、更新用户信息"><a href="#5-3、更新用户信息" class="headerlink" title="5.3、更新用户信息"></a>5.3、更新用户信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求方式：Put;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/user;</span></span><br><span class="line"><span class="comment">// 请求参数User对象 </span></span><br><span class="line"><span class="comment">// 含义：根据用户对象更新数据库</span></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">updateUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestBody User user</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    userService.updateUser(user);</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812224405307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190812224442895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-4、删除用户信息"><a href="#5-4、删除用户信息" class="headerlink" title="5.4、删除用户信息"></a>5.4、删除用户信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//请求方式：Delete;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/user/&#123;id&#125;;</span></span><br><span class="line"><span class="comment">// 含义：根据id删除用户信息</span></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">deleteUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable Long id</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    userService.deleteUser(id);</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812224924274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190812225235496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/26/hello-world/"/>
      <url>/2019/01/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
