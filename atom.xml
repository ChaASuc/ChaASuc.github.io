<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈汉槟的博客</title>
  
  <subtitle>以Java开发为主的个人博客，记录自己在学习、工作和成长的笔记和心得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://deschen.com/"/>
  <updated>2021-03-03T15:54:07.824Z</updated>
  <id>http://deschen.com/</id>
  
  <author>
    <name>陈汉槟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="http://deschen.com/2021/03/03/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://deschen.com/2021/03/03/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-03-03T14:53:57.912Z</published>
    <updated>2021-03-03T15:54:07.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="一、Explain优化语句"><a href="#一、Explain优化语句" class="headerlink" title="一、Explain优化语句"></a>一、Explain优化语句</h2><ul><li>explain中的列详解<ul><li>id列<ul><li>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的<br>顺序增长的。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</li></ul></li><li>select_type列<ul><li>select_type 表示对应行是简单还是复杂的查询。<ul><li>simple：简单查询。查询不包含子查询和union</li><li>primary：复杂查询中最外层的 select</li><li>subquery：包含在 select 中的子查询（不在 from 子句中）</li><li>derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为<br>派生表（derived的英文含义）</li><li>union：在 union 中的第二个和随后的 select</li></ul></li></ul></li><li>table列<ul><li>访问哪个表</li><li>当 from 子句中有子查询时，table列是 &lt;deriven+id&gt; 格式，对应id的查询（如<deriven2>即id=2的查询）</li><li>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的<br>select 行id。</li></ul></li><li>type列<ul><li>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，<strong>查找数据行记录的大概</strong><br><strong>范围。</strong></li><li>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL<br>一般来说，得保证查询达到range级别，最好达到ref</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL性能优化&quot;&gt;&lt;a href=&quot;#MySQL性能优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL性能优化&quot;&gt;&lt;/a&gt;MySQL性能优化&lt;/h1&gt;&lt;h2 id=&quot;一、Explain优化语句&quot;&gt;&lt;a href=&quot;#一、Explain优化语
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ELK部署——CentOS7.X</title>
    <link href="http://deschen.com/2021/02/03/ELK%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94CentOS7.X/"/>
    <id>http://deschen.com/2021/02/03/ELK%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94CentOS7.X/</id>
    <published>2021-02-03T10:42:58.000Z</published>
    <updated>2021-03-01T10:24:53.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELK部署——CentOS7-X"><a href="#ELK部署——CentOS7-X" class="headerlink" title="ELK部署——CentOS7.X"></a>ELK部署——CentOS7.X</h1><h2 id="一、创建用户角色"><a href="#一、创建用户角色" class="headerlink" title="一、创建用户角色"></a>一、创建用户角色</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建用户组：groupadd <span class="built_in">es</span></span><br><span class="line">创建用户加入用户组：useradd <span class="built_in">es</span> -g <span class="built_in">es</span></span><br></pre></td></tr></table></figure><h2 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">下载：</span><br><span class="line">    wget https:<span class="comment">//artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.3.tar.gz</span></span><br><span class="line">    wget https:<span class="comment">//artifacts.elastic.co/downloads/logstash/logstash-6.2.3.tar.gz</span></span><br><span class="line">    wget https:<span class="comment">//artifacts.elastic.co/downloads/kibana/kibana-6.2.3-linux-x86_64.tar.gz</span></span><br><span class="line">解压：</span><br><span class="line">tar -zxvf elasticsearch<span class="number">-6.2</span><span class="number">.3</span>.tar.gz -C /usr/local</span><br><span class="line">tar -zxvf logstash<span class="number">-6.2</span><span class="number">.3</span>.tar.gz -C /usr/local</span><br><span class="line">tar -zxvf kibana<span class="number">-6.2</span><span class="number">.3</span>-linux-x86_64.tar.gz -C /usr/local</span><br><span class="line">给es授权</span><br><span class="line">chown -R es.es /usr/local/elasticsearch<span class="number">-6.2</span><span class="number">.3</span></span><br><span class="line">chown -R es.es /usr/local/logstash<span class="number">-6.2</span><span class="number">.3</span></span><br><span class="line">chown -R es.es /usr/local/kibana<span class="number">-6.2</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch配置：</span><br><span class="line">允许远程配置：</span><br><span class="line"><span class="keyword">cd</span> /usr/local/elasticsearch-<span class="number">6.2</span>.<span class="number">3</span></span><br><span class="line">elasticsearch-plugin install http<span class="variable">s:</span>//github.<span class="keyword">com</span>/medcl/elasticsearch-analysis-ik/releases/download/v7.<span class="number">6.2</span>/elasticsearch-analysis-ik-<span class="number">6.2</span>.<span class="number">3</span>.zip</span><br><span class="line"><span class="keyword">vi</span> config/elasticsearch.yml </span><br><span class="line">network.hos<span class="variable">t:</span> <span class="number">0.0</span>.<span class="number">0.0</span>  #改为<span class="number">0.0</span>.<span class="number">0.0</span>对外开放，如对特定ip开放则改为指定ip</span><br><span class="line">http.por<span class="variable">t:</span> <span class="number">9200</span>      #可更改端口不为<span class="number">9200</span></span><br><span class="line">修改配置，否则报异常：<span class="built_in">max</span> <span class="keyword">file</span> descriptors [<span class="number">4096</span>] <span class="keyword">for</span> elasticsearch process <span class="keyword">is</span> too low, increase <span class="keyword">to</span> at least [<span class="number">65535</span>]...</span><br><span class="line"><span class="keyword">vi</span> /etc/security/limits.<span class="keyword">conf</span>  # 在文末添加下面四个配置</span><br><span class="line">* soft nofile <span class="number">65536</span></span><br><span class="line">* hard nofile <span class="number">131072</span></span><br><span class="line">* soft nproc <span class="number">2048</span></span><br><span class="line">* hard nproc <span class="number">4096</span></span><br><span class="line">         <span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span></span><br><span class="line">         <span class="keyword">vm</span>.max_map_count=<span class="number">655360</span></span><br><span class="line">        </span><br><span class="line"> logstash配置：</span><br><span class="line"> <span class="keyword">cd</span> /usr/local/logstash-<span class="number">6.2</span>.<span class="number">3</span></span><br><span class="line"> logstash-plugin install logstash-codec-json_lines</span><br><span class="line"> <span class="keyword">vi</span> default.<span class="keyword">conf</span></span><br><span class="line"> # 监听<span class="number">5044</span>端口作为输入</span><br><span class="line">        <span class="built_in">input</span> &#123;</span><br><span class="line">            beats &#123;</span><br><span class="line">                port =&gt; <span class="string">"5044"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # 数据过滤</span><br><span class="line">        <span class="built_in">filter</span> &#123;</span><br><span class="line">            grok &#123;</span><br><span class="line">                <span class="keyword">match</span> =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"%&#123;COMBINEDAPACHELOG&#125;"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            geoip &#123;</span><br><span class="line">                <span class="keyword">source</span> =&gt; <span class="string">"clientip"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # 输出配置为本机的<span class="number">9200</span>端口，这是ElasticSerach服务的监听端口</span><br><span class="line">        output &#123;</span><br><span class="line">            elasticsearch &#123;</span><br><span class="line">                hosts =&gt; [<span class="string">"127.0.0.1:9200"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">Kibana远程配置：</span><br><span class="line"><span class="keyword">cd</span> /usr/local/kibana-<span class="number">6.2</span>.<span class="number">3</span>-linux-x86_64</span><br><span class="line"><span class="keyword">vi</span> config/kibana.yml</span><br><span class="line">server.hos<span class="variable">t:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line">elasticsearch.requestTimeou<span class="variable">t:</span> <span class="number">90000</span>  # 默认<span class="number">3000</span>会导致es连接失败</span><br></pre></td></tr></table></figure><h2 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch</span><br><span class="line">切换账号：<span class="keyword">su</span> es</span><br><span class="line">启动：</span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/elasticsearch-6.2.3</span><br><span class="line">bin/elasticsearch -<span class="keyword">d</span>  # -<span class="keyword">d</span>后台启动</span><br><span class="line">     查看日志：tail -f logs/elasticsearch.<span class="keyword">log</span></span><br><span class="line">     测试：curl 127.0.0.1:9200</span><br><span class="line">     响应成功：</span><br><span class="line">     &#123;</span><br><span class="line">              <span class="string">"name"</span> : <span class="string">"mNuYQ8h"</span>,</span><br><span class="line">              <span class="string">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">              <span class="string">"cluster_uuid"</span> : <span class="string">"1JsAZO0sTnuBYCREW97RDw"</span>,</span><br><span class="line">              <span class="string">"version"</span> : &#123;</span><br><span class="line">                <span class="string">"number"</span> : <span class="string">"6.2.3"</span>,</span><br><span class="line">                <span class="string">"build_hash"</span> : <span class="string">"c59ff00"</span>,</span><br><span class="line">                <span class="string">"build_date"</span> : <span class="string">"2018-03-13T10:06:29.741383Z"</span>,</span><br><span class="line">                <span class="string">"build_snapshot"</span> : false,</span><br><span class="line">                <span class="string">"lucene_version"</span> : <span class="string">"7.2.1"</span>,</span><br><span class="line">                <span class="string">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">                <span class="string">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">            &#125;</span><br><span class="line">logstash</span><br><span class="line">启动：</span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/logstash-6.2.3</span><br><span class="line">bin/logstash -f default.<span class="keyword">conf</span> &amp;</span><br><span class="line">    查看日志：tail -f logs/logstash-plain.<span class="keyword">log</span></span><br><span class="line">Kibana</span><br><span class="line">切换账号：<span class="keyword">su</span> es</span><br><span class="line">启动：</span><br><span class="line"><span class="keyword">su</span></span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/kibana-6.2.3-linux-x86_64</span><br><span class="line">nohup bin/kibana &amp;</span><br><span class="line">查看日志：tail -f nohup.<span class="keyword">out</span></span><br></pre></td></tr></table></figure><h2 id="五、自启动"><a href="#五、自启动" class="headerlink" title="五、自启动"></a>五、自启动</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">以ES自启动为例</span><br><span class="line">cd /etc/init.d</span><br><span class="line">vim es-server</span><br><span class="line"></span><br><span class="line"><span class="comment">## 编写启动脚本</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#chkconfig: 345 63 37</span></span><br><span class="line"><span class="comment">#description: elasticsearch</span></span><br><span class="line"><span class="comment">#processname: elasticsearch-6.2.3</span></span><br><span class="line"><span class="comment">## 这个目录是你Es所在文件夹的目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ES_HOME</span>=/usr/local/elasticsearch-6.2.3</span><br><span class="line">case <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        start)</span><br><span class="line">        ## es 是启动es的账户，如果你的不是这个记得调整</span><br><span class="line">                su es&lt;&lt;!</span><br><span class="line">                cd <span class="variable">$ES_HOME</span></span><br><span class="line">                ./bin/elasticsearch -d -p pid</span><br><span class="line">                exit</span><br><span class="line">!</span><br><span class="line">                echo <span class="string">"elasticsearch is started"</span></span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                <span class="attribute">pid</span>=`cat <span class="variable">$ES_HOME</span>/pid`</span><br><span class="line">                kill -9 <span class="variable">$pid</span></span><br><span class="line">                echo <span class="string">"elasticsearch is stopped"</span></span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                <span class="attribute">pid</span>=`cat <span class="variable">$ES_HOME</span>/pid`</span><br><span class="line">                kill -9 <span class="variable">$pid</span></span><br><span class="line">                echo <span class="string">"elasticsearch is stopped"</span></span><br><span class="line">                sleep 1</span><br><span class="line">                su elk&lt;&lt;!     【es 这个是启动es的账户，如果你的不是这个记得调整】</span><br><span class="line">                cd <span class="variable">$ES_HOME</span></span><br><span class="line">                ./bin/elasticsearch -d -p pid</span><br><span class="line">                exit</span><br><span class="line">!</span><br><span class="line">                echo <span class="string">"elasticsearch is started"</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo <span class="string">"start|stop|restart"</span></span><br><span class="line">        ;; </span><br><span class="line">esac</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 退出</span></span><br><span class="line">:wq!</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改文件权限</span></span><br><span class="line">chmod 777 es-server</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加系统服务，开机自启</span></span><br><span class="line">chkconfig --<span class="builtin-name">add</span> es-server</span><br><span class="line"></span><br><span class="line"><span class="comment">##  启动，关闭、重启服务</span></span><br><span class="line">service es-server start</span><br><span class="line">service es-server stop</span><br><span class="line">service es-server restart</span><br></pre></td></tr></table></figure><h2 id="六、切换ELK-7-x异常处理"><a href="#六、切换ELK-7-x异常处理" class="headerlink" title="六、切换ELK 7.x异常处理"></a>六、切换ELK 7.x异常处理</h2><p>ES问题：</p><ol><li><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210220152128686.png" alt="image-20210220152128686"></p></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">切换到es <span class="number">7</span>.x 目录：cd /usr/local/elasticsearch-<span class="number">7.6</span>.<span class="number">2</span></span><br><span class="line">修改配置文件：vi config/elasticsearch.yml</span><br><span class="line"><span class="keyword">node</span>.name:<span class="title"> node-1</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"node-1"</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210301143942570.png" alt="image-20210301143942570"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">切换到es <span class="number">7.</span>x 目录：cd /usr/local/elasticsearch<span class="number">-7.6</span><span class="number">.2</span></span><br><span class="line">配置文件添加：config/elasticsearch.yml</span><br><span class="line">xpack.ml.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210301144616286.png" alt="image-20210301144616286"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">切换到root用户修改配置sysctl.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span> </span><br><span class="line"><span class="keyword">vm</span>.max_map_count=<span class="number">655360</span></span><br><span class="line">sysctl -<span class="keyword">p</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ELK部署——CentOS7-X&quot;&gt;&lt;a href=&quot;#ELK部署——CentOS7-X&quot; class=&quot;headerlink&quot; title=&quot;ELK部署——CentOS7.X&quot;&gt;&lt;/a&gt;ELK部署——CentOS7.X&lt;/h1&gt;&lt;h2 id=&quot;一、创建用户角色&quot;
      
    
    </summary>
    
    
      <category term="ELK" scheme="http://deschen.com/categories/ELK/"/>
    
    
      <category term="ELK" scheme="http://deschen.com/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>VMware——CentOS7.X部署</title>
    <link href="http://deschen.com/2021/01/28/VMware%E2%80%94%E2%80%94CentOS7-X%E9%83%A8%E7%BD%B2/"/>
    <id>http://deschen.com/2021/01/28/VMware%E2%80%94%E2%80%94CentOS7-X%E9%83%A8%E7%BD%B2/</id>
    <published>2021-01-28T02:26:20.000Z</published>
    <updated>2021-01-29T01:37:27.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMware——CentOS7-x部署"><a href="#VMware——CentOS7-x部署" class="headerlink" title="VMware——CentOS7.x部署"></a>VMware——CentOS7.x部署</h1><p>[toc]</p><h2 id="一、新建虚拟器"><a href="#一、新建虚拟器" class="headerlink" title="一、新建虚拟器"></a>一、新建虚拟器</h2><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210129093554506.png" alt="image-20210129093554506"></p><ul><li>确定好版本，要与自己软件一致</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210129093623268.png" alt="image-20210129093623268"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221170614834.png" alt="image-20201221170614834"></p><ul><li>要选择<strong>Linux</strong>系统，版本要跟自己下载的<strong>centos7.x</strong>一致</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221170652989.png" alt="image-20201221170652989"></p><ul><li><p>建议存放位置放在自定义的文件夹，方便管理</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221171956274.png" alt="image-20201221171956274"></p></li><li><p>设置处理器的和数，<strong>定情况而定</strong></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172108411.png" alt="image-20201221172108411"></p></li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172132879.png" alt="image-20201221172132879"></p><ul><li><p>接下来一直点击<strong>下一步</strong>，直到出现<strong>完成</strong>的这个界面，<strong>自定义硬件</strong></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172350769.png" alt="image-20201221172350769"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172534237.png" alt="image-20201221172534237"></p></li></ul><h2 id="二、安装centos-7-X"><a href="#二、安装centos-7-X" class="headerlink" title="二、安装centos 7.X"></a>二、安装centos 7.X</h2><blockquote><p>当看不见鼠标时，说明你点击了虚拟机，这时可以使用<strong>ctrl+alt</strong>跳出虚拟机</p></blockquote><ul><li><p>选择红框选项，按下回车键</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172836938.png" alt="image-20201221172836938"></p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163036413.png" alt="image-20201221163036413" style="zoom: 67%;" /></li><li><p>设置时间，建议时区选择上海</p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163656843.png" alt="image-20201221163656843" style="zoom:80%;" /><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163629221.png" alt="image-20201221163629221" style="zoom:80%;" /></li><li><p>显示界面（这里我使用原始界面）</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163927355.png" alt="image-20201221163927355"></p><p>PS：想要图形界面的话，可以选择方框选项</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164005808.png" alt="image-20201221164005808"></p></li><li><p>磁盘划分</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164114006.png" alt="image-20201221164114006"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164157112.png" alt="image-20201221164157112"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164758435.png" alt="image-20201221164758435"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221165029626.png" alt="image-20201221165029626"></p></li></ul><h2 id="三、连接虚拟机"><a href="#三、连接虚拟机" class="headerlink" title="三、连接虚拟机"></a>三、连接虚拟机</h2><ul><li><p>启动虚拟机，输入<strong>ip addr</strong>，获取虚拟机的ip</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175212858.png" alt="image-20201221175212858"></p></li><li><p>本地使用<strong>CMD</strong>输入<strong>ping 192.168.163.132</strong>查看本地是否与虚拟机联通</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175344603.png" alt="image-20201221175344603"></p></li><li><p>虚拟机使用<strong>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> 查看虚拟机是否能联网</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175507224.png" alt="image-20201221175507224"></p></li><li><p>因为VM操作麻烦，建议使用xshell或其他软件连接虚拟机</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175924060.png" alt="image-20201221175924060"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175800476.png" alt="image-20201221175800476"></p><p>PS：如果出现ping不通的情况，解决方法</p><ol><li><p>查看是否是网络适配器红框部分禁用了，如果是，就右键启动</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221180143248.png" alt="image-20201221180143248"></p></li><li><p>服务列表关于VM部分是否没启用</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221180327045.png" alt="image-20201221180327045"></p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VMware——CentOS7-x部署&quot;&gt;&lt;a href=&quot;#VMware——CentOS7-x部署&quot; class=&quot;headerlink&quot; title=&quot;VMware——CentOS7.x部署&quot;&gt;&lt;/a&gt;VMware——CentOS7.x部署&lt;/h1&gt;&lt;p&gt;[t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://deschen.com/2020/06/10/%E9%9A%BE%E9%A2%98/"/>
    <id>http://deschen.com/2020/06/10/%E9%9A%BE%E9%A2%98/</id>
    <published>2020-06-10T13:48:47.000Z</published>
    <updated>2021-03-05T00:24:41.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ul><li><p>mysql与redis如何数据同步</p><ul><li>并发不高的情况下，读操作优先读取redis，不存在的话就去访问MySQL，并把读到的数据写回Redis中；写操作的话，直接写MySQL，成功后再写入Redis</li><li><a href="https://blog.csdn.net/ssspk_/article/details/90924226" target="_blank" rel="noopener">https://blog.csdn.net/ssspk_/article/details/90924226</a></li></ul></li><li><p>rabbitmq消息持久化，一致性</p><ul><li>RabbitMQ是一款消息中间件，解耦、异步</li><li>RabbitMQ工作模式<ul><li>简单模式：一个生产者、一个消费者</li><li>work工作模式：一个生产者，多个消费者</li><li>发布订阅：消费者监听队列，生产者发送消息通过交换机发送绑定其的队列</li><li>routing路由模式：生产者将消息发送给交换机按照路由判断,发送到匹配队列消费</li><li>topic 主题模式：跟路由模式相同，不过key可以模糊匹配对应队列<ul><li>星号代表多个单词,井号代表一个单词</li></ul></li></ul></li><li>RabbitMQ消息的可靠传输<ul><li>发送方确认模式：信道设置成 confirm 模式，发布的消息都会被指派一个唯一的 ID，发送到队列后，信道会发送确认给生产者，如果rabbitmq异常，会发送nack给生产者    </li><li>接收方确认机制：消费者接收每一条消息后都必须进行确认，只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</li></ul></li></ul></li><li><p>多线程</p></li><li><p>nginx</p></li><li><p>类加载过程</p><ul><li><p>过程：就是把.class文件加载进内存，解析生成对应的class对象。</p></li><li><p>注意点：JVM不是一开始把所有类都加载进内存的，而是需要时在加载，并且有且只有一次</p></li><li><p>五个阶段</p><ul><li>加载：将class文件通过类加载器存到内存<ul><li>通过类的全限定名获取类的二进制流，将这个字节流所代表的静态存储结构转化为方法区运行的数据结构，元空间会生成对应的class对象做为方法区这些数据的访问入口</li><li>类加载器<ul><li>启动类加载器：负责加载jre的核心类库，比如rt.jar等</li><li>扩展类加载器：负责加载jre的扩展目录ext中jar类包</li><li>系统类加载器：负责加载classpath路径下的包</li><li>用户自定义加载器：负责加载用户自定义路径下的类包</li></ul></li></ul></li><li>验证：保证加载进来的二进制流符合虚拟机规范<ul><li>文件格式规范验证：比如常量是否有不被支持的常量</li><li>元数据验证：比如该类是否继承被final修饰的类</li><li>字节码验证：比如方法体的类型转换是否有效。子类可以赋值给父类，反之报错</li><li>符号引用验证：比如符号引用中的访问性（private、public）是否被类访问</li></ul></li><li>准备<ul><li>类的静态变量分配并初始化为默认值</li><li>注意点：<ul><li>实例变量只有在对象实例化时，随对象一起分配java堆</li><li>初始化默认值规定：数据类型为0，引用类型为null，被final修饰直接定值</li></ul></li></ul></li><li>解析：将常量池内的符号引用替换为直接引用，即直接指向目标的指针</li><li>初始化：为类的静态变量赋予真正的初始值<ul><li>注意点：准备赋值的默认值时系统要求的默认值；初始化赋值是根据程序主观初始化类变量</li><li>初始化分为主动初始化和被动初始化<ul><li>主动引用：主动触发类的初始化<ul><li>创建类的实例</li><li>mian()方法的类</li><li>访问类的静态变量（不被final修饰的变量）</li><li>访问类的静态方法</li><li>反射</li></ul></li><li>被动引用：不触发类的初始化<ul><li>子类调用父类的静态变量，子类不初始化，而父类要</li><li>数据定义类，不触发类初始化</li><li>访问类的常量（final修饰），不触发初始化</li></ul></li></ul></li></ul></li></ul></li><li><p>类加载器</p><ul><li><p>类加载机制</p><ul><li><p>全盘委托：当类加载器加载一个类时，除非显示使用另一个类加载器，否则该类及所依赖和引用的类被这个类加载器加载</p></li><li><p>双亲委派：一个类加载器要加载一个类时，先判断是否已被加载，如果没有，它会先委托自己的父类加载器来加载， 以此类推，直到启动类加载器无法加载，向下委托子类加载器加载</p></li><li><p>如何打破双亲委派模型：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">因为ClassLoader#loadClass逻辑是</span><br><span class="line"><span class="number">1</span>、先查看该类是否已加载</span><br><span class="line"><span class="number">2</span>、如果没有就向上委托</span><br><span class="line"><span class="number">3</span>、启动类加载器加载，并向下委托加载</span><br><span class="line">想要打破双亲委派，可以在第二步开始，先判断该类是否是自定义加载器加载的类，是的话就用其加载，不是就用双亲委派机制加载，这样就避免该类依赖的其他类加载异常</span><br><span class="line">protected Class&lt;?&gt; load<span class="constructor">Class(String <span class="params">name</span>, <span class="params">boolean</span> <span class="params">resolve</span>)</span></span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (get<span class="constructor">ClassLoadingLock(<span class="params">name</span>)</span>) &#123;</span><br><span class="line">            <span class="comment">// 查看类是否已加载</span></span><br><span class="line">            Class&lt;?&gt; c = find<span class="constructor">LoadedClass(<span class="params">name</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">                long t0 = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>nano<span class="constructor">Time()</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 是否是启动类加载器，不是向上委托</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != null) &#123;</span><br><span class="line">                        c = parent.load<span class="constructor">Class(<span class="params">name</span>, <span class="params">false</span>)</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = find<span class="constructor">BootstrapClassOrNull(<span class="params">name</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c<span class="operator"> == </span>null) &#123;</span><br><span class="line">                   <span class="comment">// 使用类加载器加载</span></span><br><span class="line">                    c = find<span class="constructor">Class(<span class="params">name</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolve<span class="constructor">Class(<span class="params">c</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><ul><li><p>判断对象是否垃圾回收</p><ul><li>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡</li><li>两种方法：<ul><li>引用计数法：就是给对象添加引用计数器，每当引用一次，它就加1，而当引用失效，它就减一。当计数器为0时，就被垃圾回收<ul><li>优点：方法简单，执行效率高。</li><li>缺点：对象如果存在循环依赖的话，即A引用B，B引用A，A，B不引用其他实例，导致其引用计数器不为0，无法通知GC回收器回收</li></ul></li><li>可达性分析法：从GC ROOT对象出发，节点开始向下搜索，搜索的路径称为引用链。当一个对象到GC ROOT没有任何引用链相连的话，那么证明对象不可用，会被垃圾回收<ul><li>CG ROOT根节点：类加载器、static成员变量等</li></ul></li></ul></li><li>finalize()方法最终判断对象是否存活<ul><li>即使时不可达的对象，也不一定被垃圾回收。要真正宣布该对象死亡，就要至少经历再一次标记过程</li><li>标记过程<ul><li>第一次标记：查看对象是否覆盖finalize()或者虚拟机已经调用了，虚拟机是为没必要执行，就垃圾回收</li><li>第二次标记：将对象放置在F-QUEUE队列中，稍后虚拟机会自动建立一条线程执行，但是不会立即执行或者等它运行结束。因为finalize()方法慢时，在极端情况下造成死循环，导致内存回收系统崩溃。其中finalize()方法实现其自身对象赋值于引用链中的对象，那么对象就会移除<strong>即将回收</strong>的集合。</li></ul></li></ul></li></ul></li><li><p>垃圾回收算法</p><ul><li>标记-清除算法：算法分为标记、清除。首先标记所有存活对象，在标记完成时，统一回收未标记的对象<ul><li>优点：执行效率高</li><li>缺点：存在大量不连续的内存碎片，造成无法存放内存大的对象</li></ul></li><li>复制算法：将内存分为大小相同的两块，每次只使用其中一块。当这块内存使用满后，就会把存活的对象复制到另一块去，在把原先那块回收<ul><li>优点：不存在大量内存碎片</li><li>缺点：使用效率低，因为每次只使用其中的一块</li></ul></li><li>标记-整理算法：根据老年代特点推出的一种标记算法，标记过程跟标记-清除算法一样，然后把存货的对象向一端移动，清理边外的内存<ul><li>优点：不存在大量内存碎片</li><li>缺点：整理要花一定时间</li></ul></li><li>分代收集算法<ul><li>单钱虚拟机用分代收集算法，这种算法不是新思想，而是针对对象存活周期不同将内存分为几块，一般将java堆分为新生代、老年代，根据其中特征选择合适的收集算法<ul><li>新生代：有大量对象死去，选择复制算法，只需付出少量对象复制成本就完成垃圾回收</li><li>老年代：对象存活机率大，没有格外的空间分配担保，所以要用标记—清除或者标记-整理进行垃圾回收</li></ul></li></ul></li></ul></li><li><p>TCP协议中的三次握手和四次挥手</p><ul><li>三次握手<ul><li>第一次：客户端发送syn=1，seq=x发送服务端</li><li>第二次：服务端接收后，发送syn标志，确定标志ack给客户端ack=x+1</li><li>第三次：客户端接收后，发送seq=x+1，ack=y+1给服务端</li></ul></li><li>四次挥手<ul><li>第一次：客户端请求断开FIN,seq=x发送服务端，客户端进入fin-wait-1状态</li><li>第二次：服务端接收后，发送ack=x+1，seq=y给客户端，进入close-wait状态</li><li>第三次：客户端接收后，进入fin-wait-2状态，服务端在seq=z，ack=x+1，服务端进入last-ack</li><li>第四次：客户端接收后，发送ack=z+1，客户端进入time-wait状态</li></ul></li></ul></li><li><p>jvm内存模型</p><ul><li>Jvm内存模型图</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210304212806496.png" alt="image-20210304212806496"></p><ul><li>线程私有<ul><li>程序计数器：记录虚拟机字节码的指令地址</li><li>虚拟机栈：每个方法执行时，都会创建一个栈帧，存储局部变量、操作数、动态链接、方法返回地址。方法从调用到执行完毕，对应栈帧在虚拟机栈入栈和出栈</li><li>本地方法栈：跟虚拟机栈类似，执行native方法</li></ul></li><li>线程共享<ul><li>堆：内存最大的区域，存储java对象</li><li>方法区：存储已被虚拟机加载的类信息、常量、静态变量等</li></ul></li></ul></li><li><p>Java堆的划分</p><ul><li>新生代（1:3）:存放新生的对象<ul><li>Eden(8:10)</li><li>From Survivor(1:10)</li><li>To Survivor(1:10)</li><li>过程：eden区存放新建对象。而当eden区内存不够时，就会触发垃圾回收，将其与from survivor区的存活对象，复制to survivor区，然后to survivor区变成from survivor区。每经过一次垃圾回收，对象年龄+1，当超过默认15次时，会复制到老年代</li></ul></li><li>老年代(2:3)<ul><li>过程：老年代存放生命周期长的对象。而当老年代内存不够时，会触发full gc，比gc慢10倍左右。当时在装不下时，报出out of memory异常</li></ul></li></ul></li><li><p>Spring面试题</p><ul><li>spring：Spring是一个轻量级的IoC和AOP容器框架，用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。</li><li>spring优点：<ul><li>低侵入式设计，代码的污染极低</li><li>DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性</li><li>AOP技术，将一些通用业务进行集中式管理，如事务、日志</li></ul></li><li>Spring的IoC理解：创建对象的控制权转移给Spring框架进行管理，创建对象的主动权由自己把控的，现在有spring进行管理，通过java反射，运行时动态创建对象及管理对象调用方法<ul><li>IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入</li></ul></li><li>AOP理解：面向切面，将那些与业务无关的通用逻辑，抽取并封装为一个可重用的模块，减低代码耦合<ul><li>AOP代理主要分为静态代理和动态代理<ul><li>静态代理：在编译阶段生成AOP代理类，并将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。</li><li>动态代理：<ul><li>JDK动态代理：只提供接口的代理，不支持类的代理，要求被代理类实现接口。Proxy类创建代理类，当调用目标类方法时，InvocationHandler 通过invoke()方法反射来调用</li><li>GLIB动态代理：生成目标类的一个子类对象，并覆盖其中特定方法并添加增强代码</li></ul></li></ul></li><li>连接点：执行的方法</li><li>切面（Aspect）：被抽取出来的公共模块</li><li>切点（Pointcut）：定义哪些要被Join进行拦截</li><li>通知（Advice）：指要在连接点上执行的动作，即增强的逻辑</li><li>目标对象（Target）：包含连接点的对象，称作被通知（Advice）的对象</li><li>织入（Weaving）：通过动态代理，在目标对象（Target）的方法（即连接点Join point）中执行增强逻辑（Advice）的过程</li><li>引入（Introduction）：添加额外的方法或者字段到被通知的类</li></ul></li><li>bean生命周期<ul><li>实例化Bean、设置对象属性（依赖注入）、处理Aware接口、BeanPostProcessor前置处理、检查是否有InitializingBean处理，有的话调用afterPropertiesSet方法、检查是否有自定义的init-method、BeanPostProcessor后置处理器、注册必要的destruction回调接口、查看是否实现disposablebean接口、查看是否配置destory方法</li></ul></li></ul></li><li><p>Mybaits</p><ul><li>Mybatis是一个半ORM（对象关系映射）框架</li><li>#{}和${}的区别是什么<ul><li>${}是字符串替换，会直接替换成变量的值</li><li>#{}是预处理，会替换为?号，调用PreparedStatement的set方法来赋值；#{}可以有效的防止SQL注入，提高系统安全性。</li></ul></li><li>优缺点<ul><li>优点：基于SQL语句编程，相当灵活</li><li>缺点：对于多表关联，对编写SQL语句要有一定要求</li><li>Mybatis的一级、二级缓存<ul><li>一级缓存: 基于PerpetualCache 的 HashMap本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该Session中的所有 Cache 就将清空。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，</li><li>一级缓存的sql session互补影响，二级缓存的mapper(namespace)时可以跨多个sql session的</li></ul></li></ul></li></ul></li><li><p>todo</p></li><li><p>HashTable、HashMap、CurrentHashMap</p><ul><li>为什么使用2的n次方<ul><li>因为hash求余效率不如位移运算，源码就做了这种优化。因为hash%length==hash&amp;(length-1)前提是length是2的n次方</li></ul></li><li>HashMap特性<ul><li>hashMap底层</li></ul></li></ul></li><li><p>MySQL</p><ul><li><p>myisam与innodb区别</p><ul><li>myisam支持全文检索，但是不支持事务和行级锁，所以用于大量查询少量插入的场景</li><li>innodb基于聚簇索引建立，与myisam相反，它支持事务、外键</li></ul></li><li><p>mysql索引</p><ul><li>mysql索引是B+树索引，而B+树是左小右大的存储结构，节点只包含id索引列，叶子节点包含索引列和数据，而这种索引叫做聚簇索引</li><li>什么是非聚簇索引：跟聚簇索引相同结构，但是其叶子节点包含数据的存储地址，而Myisam使用这种索引</li></ul></li><li><p>锁类型</p><ul><li>mysql锁分为共享锁和排他锁，也成为读锁和写锁</li><li>读锁是共享的，但是这时候只读不写</li><li>写锁是排他锁，它会阻塞其他写锁和读锁，而按粒度来看，又分为行锁和表锁</li><li>表锁会锁定整个表，阻塞其他用户对该表的读写操作，比如alter修改表</li><li>行锁分为乐观锁和悲观锁，悲观锁用于for update，乐观锁通过版本号实现</li></ul></li><li><p>mysql主从表</p><ul><li>mysql主从同步原理<ul><li>master提交玩事务后，写入binlog</li><li>slave连接master，获取binlog</li><li>master创建dump线程，推送binlog到slave</li><li>slave启动一个线程读取同步过来的master的binlog，记录到relay_log中继日志中</li><li>slave开启sql线程读取relay_log事件并在slave执行，完成同步</li><li>slave记录自己的binlog</li></ul></li><li>mysql默认的复制方式是异步的，主库发送日志后不再关心从库，而这样产生一个问题：主库挂了，从库处理失败，这时候从库身为主库，日志丢了。这时候有两种概念<ul><li>全同步复制：主库写入binlog后强制日志同步到从库，从库完成后才返回客户端</li><li>半同步复制：从库写入日志成功后发送ack给主库，主库收到ack就判断操作完成</li></ul></li></ul></li><li><p>MySQL优化</p><ul><li>事务的四大特性（ACID）</li></ul><ol><li>原子性(Atomicity)：事务执行操作，要么全部成功，要么全部失败。事务失败会回滚事务开始前的状态</li><li>一致性（Consistency）: 事务前后数据的完整性必须保持一致。比如A转账B，那么A减少金额，B一定增加对应的金额</li><li>隔离性（Isolation）: 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A转账给B，那么A转钱过程中，C无法转钱给A</li><li>持久性1（Durability）：事务一旦提交，数据库的数据改变时永久的</li></ol><ul><li>事务的四个隔离级别</li></ul><p>√: 可能出现  ×: 不会出现</p><table><thead><tr><th align="left">事务隔离级别（从低到高）</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="left">读未提交（read-uncommitted）</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">读已提交（read-committed）</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">可重复读（repeatable-read）</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="left">串行化（serializable）</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>读未提交：事务A操作数据时，其他事务只允许对该行数据读取，虽然解决<strong>更新丢失</strong>问题。但是会照成<strong>脏读</strong>。<ul><li>什么是脏读：脏读就是事务A读取到事务B未提交的数据</li></ul></li><li>读已提交：事务A操作数据时，其他事务不允许对该行读写操作。这样能就解决<strong>脏读</strong>问题。但是会照成<strong>不可重复读</strong><ul><li>什么是不可重复读：事务A读取事务B操作前的数据和提交后的数据不一致</li></ul></li><li>可重复读：一个事务内，A读取数据，其他事务不允许对该行操作，这样多次读取的数据是一致的，解决了不可重复读的问题。但是会照成<strong>幻读</strong><ul><li>什么是幻读：事务A读取到事务B新增或者删除数据，导致数据个数不一致</li></ul></li><li>串行化：事务只能一个接着一个地执行，但不能并发执行。虽然能解决幻读问题。但是这种性能低，很少使用</li></ul><ul><li>数据库设计优化<ul><li>选择合适的字段属性：比如性别有男、女，可以通过tinyint(1)来记录，不用varchar这样减少数据库不必要的内存同时整型处理效率比文本快，另外把所有的字段最好NOT ＮULL避免全表扫描</li></ul></li><li>使用join替代子查询，之所以效率高些，因为MySQL不需要在内存中创建临时表来完成两步查询操作</li><li>使用索引<ul><li>在where子句中的列设置索引</li><li>最左前缀原则</li><li>尽量使用覆盖索引。因为辅助索引的叶子节点包含索引值和主键，如果查询的列不包含在覆盖索引中，那么这些列会通过主键搜索主键索引，这种情况会可能照成全表扫描</li><li>不要使用````!=, not in, no exist, is null , is not null``，因为这样会造成全表扫描</li><li>不要再索引列进行操作</li></ul></li><li>优化语句<ul><li>使用explain优化语句<ul><li>id列：select序列号，id越大，优先级越高；id相同从上到下执行；id为null最后执行</li><li>select_type列<ul><li>select_type 表示对应行是简单还是复杂的查询。<ul><li>simple：简单查询。查询不包含子查询和union</li><li>primary：复杂查询中最外层的 select</li><li>subquery：包含在 select 中的子查询（不在 from 子句中）</li><li>derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为<br>派生表（derived的英文含义）</li><li>union：在 union 中的第二个和随后的 select</li></ul></li></ul></li><li>table列<ul><li>访问哪个表</li><li>当 from 子句中有子查询时，table列是 &lt;deriven+id&gt; 格式，对应id的查询（如<deriven2>即id=2的查询）</li><li>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的<br>select 行id。</li></ul></li><li>type列：表示查询使用那种类型、是否使用索引，反映语句的质量<ul><li>system&gt; const&gt; eq_ref&gt; ref&gt;rang&gt; index&gt; all,最少要得保证查询达到range级别，最好达到ref</li><li>ref 表示具有匹配索引的行都用到</li><li>range表示索引范围内查找</li><li>index表示全索引树查找</li><li>all表示全表扫描</li></ul></li><li>possible_keys：mysql试用了那些索引</li><li>key：显示使用的索引</li><li>key_len：表示使用索引的长度。比如覆盖索引，每一列有固定的长度，根据长度判断使用那个列</li><li>extra：包含mysql查询的详细信息<ul><li>Using index：使用覆盖索引</li><li>Using where：使用 where 语句来处理结果，查询的列未被索引覆盖</li><li>Using index condition：查询的列不完全被索引覆盖</li><li>Using filesort：将用外部排序而不是索引排序</li></ul></li></ul></li></ul></li></ul></li><li><p>Redis</p><ul><li><p>五种数据类型</p><ul><li>String字符串，格式：set key value，一般用于对象缓存</li><li>Hash（哈希），格式: hmset key value1 value2 value3，一般用于对象集合的缓存。比如商品中有一个需要修改，那么只要更新hash的缓存集合，不需要重新从数据库获取缓存</li><li>List（列表）有序、可重复，底层是链表，格式：lpush name value。可以对两端进行插入、弹出操作。可用于博客的用户列表</li><li>set是无序不可重复。可用于博客中用户之间的共同关注文章</li><li>zset，有序不可重复，根据分数进行排序。可用于热门的标签排序</li></ul></li><li><p>redis与mecache对比</p><ul><li>redis具有丰富的数据类型，mecache只支持key-value</li><li>redis可以把数据持久化，而mecache把数据保存到内存中，当程序关闭时，数据就会消失</li></ul></li><li><p>redis持久化</p><ul><li>什么是持久化？持久化就是将数据从内存保存到硬盘，防止redis宕机数据丢失</li><li>RDB和AOF<ul><li>RDB，将数据以快照的形式保存磁盘，是redis默认的方式。当redis重启时，会读取RDB文件。但是有个缺点，RDB不能实时备份数据，有部分时刻的数据会丢失</li><li>AOF，将redis写命令写入磁盘，这样能保证实时备份数据。可是如果命令过多，就会照成redis重启时间过长</li><li>redis 4.0后，出现混合持久化模式，结合两者优缺点。RDB的内容会写入AOF开头，这样既能提升加载速度，又能保证数据的实时性。但是因为两者结合AOF里面RDB内容可读性差</li></ul></li></ul></li><li><p>redis过期策略</p><ul><li>定时策略：就是每个设置过期时间的key设置定时器，到过期时间就会清除</li><li>惰性策略：当访问一个key，才判断key是否已过期，过期清除</li><li>定时过期：每个一定时间，扫描一定数量的key，清除已过期的key</li></ul></li><li><p>redis淘汰策略</p><ul><li>noeviction：内存不足，写入新数据报错</li><li>allkeys-lru：内存不足，写入新数据，移除最近最少用的key</li><li>allkeys-random：内存不足，写入新数据，随机移除key</li><li>volatile-lru：内存不足，写入新数据，在设置过期时间的key中，移除最近最少用的key</li><li>volatile-random：内存不足，写入新数据，在设置过期时间的key中，移除最近最少用的key</li><li>volatile-ttl：内存不足，写入新数据，在设置过期时间的key中，移除最早过期的key</li></ul></li><li><p>缓存穿透</p><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>缓存穿透就是访问一个不存在的数据时，缓存没有命中，而访问数据库，在高并发情况下，数据库又因为压力而宕机</p><h3 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>布隆过滤器</p><ul><li>简介：布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li><li>原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。</li><li>优点：相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。而且它不存储元素本身，在某些对保密要求非常严格的场合有优势。</li><li>缺点：一定的误识别率和删除困难。<br>结合以上几点及去重需求（容忍误判，会误判在，在则丢，无妨），决定使用BlomFilter。</li></ul></li><li><p>缓存雪崩</p><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> 在缓存时设置相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，数据库瞬时压力过重雪崩。 </p><h3 id="2、解决方案-1"><a href="#2、解决方案-1" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li><li><p>缓存击穿</p><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>某个数据设置过期时间，而该数据是被高并发访问的热点数据，一旦过期，可能就会造成缓存被击穿的可能</p><h3 id="2、解决方案-2"><a href="#2、解决方案-2" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><ul><li><p>使用互斥锁解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;  </span><br><span class="line">      String value = redis.get(key);  </span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期  </span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db  </span></span><br><span class="line">          <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功  </span></span><br><span class="line">               value = db.get(key);  </span><br><span class="line">               redis.set(key, value, expire_secs);  </span><br><span class="line">               redis.del(key_mutex);  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可  </span></span><br><span class="line">                      sleep(<span class="number">50</span>);  </span><br><span class="line">                      get(key);  <span class="comment">//重试  </span></span><br><span class="line">              &#125;  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              <span class="keyword">return</span> value;        </span><br><span class="line">          &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>将该数据不设置过期时间，就不会造成缓存击穿问题</p></li></ul></li></ul></li><li><p>​    Nginx</p><ul><li>Nginx是一个高性能的 HTTP 和 反向代理 服务器</li><li>Nginx负载均衡<ul><li>循环轮询</li><li>最少连接，即每次都找连接数最少的服务器来转发请求</li><li>IP地址来决定当前请求</li><li>权重算法，会根据每个服务的权重来分发请求，权重大的请求相对会多分发一点，权重小的会少分发一点。</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;mysql与redis如何数据同步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发不高的情况下，读操作优先读取redis，不存在的
      
    
    </summary>
    
    
      <category term="学习" scheme="http://deschen.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap与ConcurrentHashMap原理</title>
    <link href="http://deschen.com/2020/03/05/HashMap%E4%B8%8EConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>http://deschen.com/2020/03/05/HashMap%E4%B8%8EConcurrentHashMap%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-05T08:02:06.000Z</published>
    <updated>2021-02-03T11:56:47.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap与ConcurrentHashMap原理"><a href="#HashMap与ConcurrentHashMap原理" class="headerlink" title="HashMap与ConcurrentHashMap原理"></a>HashMap与ConcurrentHashMap原理</h1><h2 id="一、HashMap的数据结构"><a href="#一、HashMap的数据结构" class="headerlink" title="一、HashMap的数据结构"></a>一、HashMap的数据结构</h2><p>HashMap有数组+链表+红黑树组成</p><ul><li><p>通过hash函数得到存储地址，进而保存到数组中</p></li><li><p>当出现hash冲突时， hashmap采用的就是链地址法 ，在冲突的地址上生成一个链表，将冲突的元素的key，通过equals进行比较，相同即覆盖，不同则添加到链表</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 判断是否是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="comment">// 判断键和值是否相同</span></span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>jdk1.8之后，就会转换为红黑树，理由：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     HashMap在JDK1.8及以后的版本中引入了红黑树结构，若桶中链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</span></span><br><span class="line"><span class="comment">还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</span></span><br><span class="line"><span class="comment">     虽然红黑树的时间复杂度时O(log(n))，比链表的时间复杂度O(n)低，</span></span><br><span class="line"><span class="comment">     而树节点的空间是普通节点空间的两倍</span></span><br><span class="line"><span class="comment">     规定：当节点数量小于8（移除或者扩容）时，就会变为链表，原因如下</span></span><br><span class="line"><span class="comment">     * Because TreeNodes are about twice the size of regular nodes, we</span></span><br><span class="line"><span class="comment">     * use them only when bins contain enough nodes to warrant use</span></span><br><span class="line"><span class="comment">     * (see TREEIFY_THRESHOLD). And when they become too small (due to</span></span><br><span class="line"><span class="comment">     * removal or resizing) they are converted back to plain bins.  In</span></span><br><span class="line"><span class="comment">     * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="comment">     * rarely used.  Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="comment">     * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment">     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment">     * parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment">     * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment">     * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment">     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment">     * factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:    0.60653066</span></span><br><span class="line"><span class="comment">     * 1:    0.30326533</span></span><br><span class="line"><span class="comment">     * 2:    0.07581633</span></span><br><span class="line"><span class="comment">     * 3:    0.01263606</span></span><br><span class="line"><span class="comment">     * 4:    0.00157952</span></span><br><span class="line"><span class="comment">     * 5:    0.00015795</span></span><br><span class="line"><span class="comment">     * 6:    0.00001316</span></span><br><span class="line"><span class="comment">     * 7:    0.00000094</span></span><br><span class="line"><span class="comment">     * 8:    0.00000006</span></span><br><span class="line"><span class="comment">     // 根据泊松分布得到hash冲突到第8个数的概率时千万分之6，接下来就概率时小于千万分之一</span></span><br><span class="line"><span class="comment">     // 因此时间和空间的权衡下，采用8作为链表和红黑树的阈值</span></span><br><span class="line"><span class="comment">     * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="二、HashMap的构造方法"><a href="#二、HashMap的构造方法" class="headerlink" title="二、HashMap的构造方法"></a>二、HashMap的构造方法</h2><ul><li><p>默认构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =======================默认参数====================================</span></span><br><span class="line">    <span class="comment">// 默认容器为16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量2的30次方</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认加载因子 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转为红黑树的阈值8</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>自定义构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 若初始化容量大于最大容量，就为最大容量2的30次方</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;  <span class="comment">// 加载因子0.75</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);   <span class="comment">// 容量的取值，取最近2的幂次的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 若n小于0，为1</span></span><br><span class="line">        <span class="comment">// 若n大于等于最大容量，为最大容量，否则为n+1</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么要取2的幂次呢？</p><ul><li><p>取余的模运算与位运算相等,而且取模运算效率低于位运算效率。</p></li><li><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> % <span class="number">8</span> = <span class="number">4</span></span><br><span class="line"><span class="number">100</span> &amp; (<span class="number">8</span>-<span class="number">1</span>) = <span class="number">001100110</span> &amp; <span class="number">0111</span> = <span class="number">0110</span> = <span class="number">4</span> 等价</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组扩容时，仅仅关注 “特殊位” 就可以重新定位元素 </p><ul><li><p>因为数组扩容变成原来的2倍，即二进制向左移动一位，此时重新计算定位。按照公式`hash&amp;(length-1)``，原本扩容前被舍弃的<strong>高位部分的最后一位</strong>，也参与计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">扩容前 <span class="number">100</span> &amp; (<span class="number">8</span>-<span class="number">1</span>) = <span class="number">001100100</span> &amp; <span class="number">0111</span> = <span class="number">0100</span> = <span class="number">4</span></span><br><span class="line">扩容后 <span class="number">100</span> &amp; (<span class="number">16</span>-<span class="number">1</span>) = <span class="number">001100100</span> &amp; <span class="number">01111</span> = <span class="number">00100</span> = <span class="number">4</span></span><br><span class="line">===================================================</span><br><span class="line">扩容前 <span class="number">108</span> &amp; (<span class="number">8</span>-<span class="number">1</span>) = <span class="number">001101100</span> &amp; <span class="number">0111</span> = <span class="number">0100</span> = <span class="number">4</span></span><br><span class="line">扩容后 <span class="number">108</span> &amp; (<span class="number">16</span>-<span class="number">1</span>) = <span class="number">001101100</span> &amp; <span class="number">01111</span> = <span class="number">1100</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure></li><li><p>从中可以看出，根据高位最后一位为0，还是原来的索引，为1，就是原来索引+原来数组长</p></li></ul></li><li><p>hashmap在put时才会初始化数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><ul><li>泊松分布： 是一种统计与概率学里常见到的离散机率分布 。 泊松分布适合于描述单位时间内随机事件发生的次数。  </li></ul><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583994301694.png" alt="1583994301694"></p><p>+ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap与ConcurrentHashMap原理&quot;&gt;&lt;a href=&quot;#HashMap与ConcurrentHashMap原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap与ConcurrentHashMap原理&quot;&gt;&lt;/a&gt;HashM
      
    
    </summary>
    
    
      <category term="Java" scheme="http://deschen.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--类加载器</title>
    <link href="http://deschen.com/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://deschen.com/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-02-29T09:37:09.000Z</published>
    <updated>2020-03-20T11:15:34.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–类加载器"><a href="#深入理解JVM–类加载器" class="headerlink" title="深入理解JVM–类加载器"></a>深入理解JVM–类加载器</h1><h2 id="一、类与类加载器的关系"><a href="#一、类与类加载器的关系" class="headerlink" title="一、类与类加载器的关系"></a>一、类与类加载器的关系</h2><ul><li><p>任意一个类,都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</p></li><li><p>每个类加载器都有各自的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。 </p></li></ul><h2 id="二、类加载器种类"><a href="#二、类加载器种类" class="headerlink" title="二、类加载器种类"></a>二、类加载器种类</h2><p>启动类加载器： 由C++编写，无法通过程序得到。主要负责加载JAVA中的 一些核心类库，主要是位于<JAVA_HOME>/lib/rt.jar中 </p><p>扩展类加载器： 要加载JAVA中的一些拓展类，主要位于<JAVA_HOME>/lib/ext </p><p>系统类加载器： 主要用于加载CLASSPATH路径下的类 </p><h2 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a>三、类加载机制</h2><p>全盘委托： 指当一个类加载器加载一个类时，除非显示地使用另一个类加载器，否则该类所依赖与引用的类也由这个类加载器加载。 </p><p>双亲委派： 一个类加载器要加载一个类时，先判断是否已被加载，如果没有，它会先委托自己的父类加载器来加载， 以此类推，直到启动类加载器无法加载，向下委托子类加载器加载 </p><h2 id="四、双亲委派模型源码分析"><a href="#四、双亲委派模型源码分析" class="headerlink" title="四、双亲委派模型源码分析"></a>四、双亲委派模型源码分析</h2><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583074859678.png" alt="1583074859678"></p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583075146217.png" alt="1583075146217">)<img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583075296256.png" alt="1583075296256"></p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583075400741.png" alt="1583075400741"></p><h2 id="五、自定义类加载器"><a href="#五、自定义类加载器" class="headerlink" title="五、自定义类加载器"></a>五、自定义类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.deschen.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        CustomClassLoader loader01 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"F:\\java-note\\jvm-note\\classes\\"</span>, <span class="string">".class"</span>, <span class="string">"loader01"</span>);</span><br><span class="line">        CustomClassLoader loader02 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"F:\\java-note\\jvm-note\\classes\\"</span>, <span class="string">".class"</span>, <span class="string">"loader02"</span>);</span><br><span class="line">        Class&lt;?&gt; class01 = loader01.loadClass(<span class="string">"cn.deschen.jvm.gc.C"</span>);</span><br><span class="line">        System.out.println(<span class="string">"class01 类加载器："</span> + class01.getClassLoader());</span><br><span class="line">        Class&lt;?&gt; class02 = loader02.loadClass(<span class="string">"cn.deschen.jvm.gc.C"</span>);</span><br><span class="line">        System.out.println(<span class="string">"class02 类加载器："</span> + class02.getClassLoader());</span><br><span class="line">        <span class="comment">// 结果是false</span></span><br><span class="line">        <span class="comment">// 为什么都是C类，结果是false呢？ =》因为loader01与loader02不是同一个类加载器，因此类的命令空间不同，因此两个类是不一样的</span></span><br><span class="line">        System.out.println(<span class="string">"class01 == class02："</span> + (class01 == class02));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: java-note</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: deschen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义类加载器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loadPath;   <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="keyword">private</span> String filePrefix;   <span class="comment">// 文件后缀</span></span><br><span class="line">    <span class="keyword">private</span> String loaderName;   <span class="comment">// 类加载器名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认应用类加载器作为自定义类加载器的父类加载器</span></span><br><span class="line"><span class="comment">     * 调用父类构造方法</span></span><br><span class="line"><span class="comment">     * java.lang.ClassLoader.ClassLoader()&#123;</span></span><br><span class="line"><span class="comment">     *     this(checkCreateClassLoader(), getSystemClassLoader());</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * getSystemClassLoader()就是应用程序类加载器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String loadPath, String filePrefix, String loaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.loadPath = loadPath;</span><br><span class="line">        <span class="keyword">this</span>.filePrefix = filePrefix;</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent, String loadPath, String filePrefix, String loaderName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置应用类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.loadPath = loadPath;</span><br><span class="line">        <span class="keyword">this</span>.filePrefix = filePrefix;</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoadPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loadPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadPath</span><span class="params">(String loadPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadPath = loadPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFilePrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilePrefix</span><span class="params">(String filePrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePrefix = filePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoaderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoaderName</span><span class="params">(String loaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class文件转换为字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  类的二进制名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bao = <span class="keyword">null</span>;</span><br><span class="line">        name = name.replace(<span class="string">"."</span>, <span class="string">"//"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(loadPath + name + filePrefix);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = fis.read())) &#123;</span><br><span class="line">               bao.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != bao) &#123;</span><br><span class="line">                    bao.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bao.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、打破双亲委派机制"><a href="#六、打破双亲委派机制" class="headerlink" title="六、打破双亲委派机制"></a>六、打破双亲委派机制</h2><img src=" https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584533309335.png " alt="1584533309335" style="zoom:200%;" /><p>`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–类加载器&quot;&gt;&lt;a href=&quot;#深入理解JVM–类加载器&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–类加载器&quot;&gt;&lt;/a&gt;深入理解JVM–类加载器&lt;/h1&gt;&lt;h2 id=&quot;一、类与类加载器的关系&quot;&gt;&lt;a href=&quot;#一、
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://deschen.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是中台？</title>
    <link href="http://deschen.com/2019/12/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0%EF%BC%9F/"/>
    <id>http://deschen.com/2019/12/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0%EF%BC%9F/</id>
    <published>2019-12-20T12:53:20.000Z</published>
    <updated>2019-12-20T13:06:52.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是中台？"><a href="#什么是中台？" class="headerlink" title="什么是中台？"></a>什么是中台？</h1><h2 id="一、中台的介绍"><a href="#一、中台的介绍" class="headerlink" title="一、中台的介绍"></a>一、中台的介绍</h2><p>中台就是把企业各个业务线共用的、复用性高的功能独立开来，整合分析，变成为企业内部服务的功能</p><h2 id="二、举个栗子"><a href="#二、举个栗子" class="headerlink" title="二、举个栗子"></a>二、举个栗子</h2><p>我们都知道阿里上有淘宝、饿了么等各个不同体系的系统，对用户的分析就需要结合数据。如果没有中台概念，那么每个系统都回查询自己的用户中心，还要考虑同步数据的问题（即注册了淘宝账号，就要同步到其他系统的用户中心），这样开发成本高，维护难。</p><p>而中台就是把各个系统公共的功能独立开来，例如：把用户中心、订单中心、商品中心等独立开来，这些功能与各个系统对接，这样成本低，效率高。程序员可以更加专注业务方面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是中台？&quot;&gt;&lt;a href=&quot;#什么是中台？&quot; class=&quot;headerlink&quot; title=&quot;什么是中台？&quot;&gt;&lt;/a&gt;什么是中台？&lt;/h1&gt;&lt;h2 id=&quot;一、中台的介绍&quot;&gt;&lt;a href=&quot;#一、中台的介绍&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="中台" scheme="http://deschen.com/categories/%E4%B8%AD%E5%8F%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--七种垃圾收集器</title>
    <link href="http://deschen.com/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%83%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://deschen.com/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%83%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2019-10-11T08:18:05.000Z</published>
    <updated>2021-03-04T09:57:45.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–七种垃圾收集器"><a href="#深入理解JVM–七种垃圾收集器" class="headerlink" title="深入理解JVM–七种垃圾收集器"></a>深入理解JVM–七种垃圾收集器</h1><h2 id="一、垃圾收集器"><a href="#一、垃圾收集器" class="headerlink" title="一、垃圾收集器"></a>一、垃圾收集器</h2><ul><li><p>七种垃圾收集器组合</p><p> <img src="http://img.blog.csdn.net/20170102225015393" alt="img"></p></li><li><p>区域划分</p><ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul></li></ul><h2 id="二、并发垃圾收集和并行垃圾收集的区别"><a href="#二、并发垃圾收集和并行垃圾收集的区别" class="headerlink" title="二、并发垃圾收集和并行垃圾收集的区别"></a>二、并发垃圾收集和并行垃圾收集的区别</h2><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；如：ParNew、Parallel Scavenge、Parallel Old；</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1（也有并行）；</li></ul><h2 id="三、收集器详解"><a href="#三、收集器详解" class="headerlink" title="三、收集器详解"></a>三、收集器详解</h2><h3 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h3><p>Serial（串行）收集器收集器是<strong>最基本、历史最悠久</strong>的垃圾收集器了。大家看名字就知道这个收集器是一个<strong>单线程收集器</strong>了。它的单线程的意义不仅仅意味着它<strong>只会使用一条垃圾收集线程去完成垃圾收集</strong>工作，更重要的是<strong>它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521520253.png" alt="1584521520253"></p><h3 id="2、ParNew收集器"><a href="#2、ParNew收集器" class="headerlink" title="2、ParNew收集器"></a>2、ParNew收集器</h3><p>ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了<strong>使用多线程进行垃圾收集外</strong>，<strong>其余行为</strong>（控制参数、收集算法、回收策略等等）和Serial收集器<strong>完全一样</strong>。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521563004.png" alt="1584521563004"></p><h3 id="3、Parallel-Scavenge收集器"><a href="#3、Parallel-Scavenge收集器" class="headerlink" title="3、Parallel Scavenge收集器"></a>3、Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器<strong>类似于ParNew 收集器，是Server 模式</strong>（内存大于2G，2个cpu）下的<strong>默认收集器</strong>，那么它有什么特别之处呢？</p><p>Parallel Scavenge收集器<strong>关注点是吞吐量（高效率的利用CPU）</strong>。所谓吞吐量就是<strong>CPU中用于运行用户代码的时间与CPU总消耗时间的比值</strong>。 </p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521574511.png" alt="1584521574511"></p><h3 id="4、Serial-Old收集器"><a href="#4、Serial-Old收集器" class="headerlink" title="4、Serial Old收集器"></a>4、Serial Old收集器</h3><p><strong>Serial</strong>收集器的<strong>老年代版本</strong>，它同样是一个<strong>单线程</strong>收集器。它主要有两大用途：一种用途是在<strong>JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用</strong>，另一种用途是作<strong>为CMS收集器的后备方案</strong>。  </p><h3 id="5、Parallel-Old收集器"><a href="#5、Parallel-Old收集器" class="headerlink" title="5、Parallel Old收集器"></a>5、Parallel Old收集器</h3><p> <strong>Parallel Scavenge</strong>收集器的<strong>老年代</strong>版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h3 id="6、CMS收集器"><a href="#6、CMS收集器" class="headerlink" title="6、CMS收集器"></a>6、CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让<strong>垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程(<strong>STW</strong>)，并记录下<strong>直接与root相连的对象，速度很快</strong> ；</li><li><strong>并发标记：</strong> <strong>同时开启GC和用户线程</strong>，用一个<strong>闭包结构</strong>去<strong>记录可达对象</strong>。但在这个阶段结束，这个闭包结构<strong>并不能保证包含当前所有的可达对象</strong>。因为<strong>用户线程</strong>可能会<strong>不断的更新引用域</strong>，所以GC线程无法保证可达性分析的<strong>实时性</strong>。所以这个算法里会<strong>跟踪记录这些发生引用更新的地方</strong>。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了<strong>修正</strong>并发标记期间因为用户程序继续运行而导致<strong>标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般<strong>会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong></li><li><strong>并发清除：</strong> 开启用户线程，同时<strong>GC线程开始对未标记的区域做清扫</strong>。</li></ul><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521588277.png" alt="1584521588277"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li>对<strong>CPU资源敏感</strong>（会和服务抢资源）；</li><li><strong>无法处理浮动垃圾(</strong>在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法<strong>-“标记-清除”</strong>算法会导致收集结束时会有大量空间碎片产生<strong>。</strong></li></ul><h3 id="7、G1收集器-XX-UseG1GC"><a href="#7、G1收集器-XX-UseG1GC" class="headerlink" title="7、G1收集器(-XX:+UseG1GC)"></a>7、G1收集器(-XX:+UseG1GC)</h3><p><strong>G1</strong> (Garbage-First)是一款<strong>面向服务器的垃圾收集器</strong>,主要针对配备<strong>多颗处理器及大容量内存的机器</strong>. 以极<strong>高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</strong>.</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image002.gif" alt="截图.png"></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image004.gif" alt="截图.png"></p><p>G1将<strong>Java堆划分为多个大小相等的独立区域</strong>（<strong>Region</strong>），虽保留新生代和老年代的<strong>概念</strong>，但不再是<strong>物理隔阂</strong>了，它们都是（可以不连续）<strong>Region</strong>的集合。</p><p><strong>分配大对象</strong>（直接进<strong>Humongous区</strong>，专门<strong>存放短期巨型对象</strong>， <strong>当分配的对象大于等于Region大小的一半</strong>的时候就会被认为是巨型对象 ）不会因为无法找到连续空间而提前触发下一次GC。</p><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong>（initial mark，STW）：在此阶段，标记 GC Roots能直接关联到的对象。 需要停顿线程，但耗时很短 </li><li><strong>并发标记</strong>（Concurrent Marking）： GC Root开始对堆中对象进行<strong>可达性分析，找出存活的对象，</strong>这阶段耗时较长，但可与用户程序并发执行 </li><li><strong>最终标记</strong>（Remark，STW）： 修正在并发标记期间因<strong>用户程序继续运作而导致标记产生变动的那一部分标记记录</strong> </li><li><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，<strong>根据用户所期望的GC停顿时间来制定回收计划</strong>.</li></ul><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image006.gif" alt="clipboard.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–七种垃圾收集器&quot;&gt;&lt;a href=&quot;#深入理解JVM–七种垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–七种垃圾收集器&quot;&gt;&lt;/a&gt;深入理解JVM–七种垃圾收集器&lt;/h1&gt;&lt;h2 id=&quot;一、垃圾收集器&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://deschen.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--四种垃圾收集算法</title>
    <link href="http://deschen.com/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%9B%9B%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://deschen.com/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%9B%9B%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</id>
    <published>2019-10-11T07:56:36.000Z</published>
    <updated>2020-03-18T11:37:07.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–四种垃圾收集算法"><a href="#深入理解JVM–四种垃圾收集算法" class="headerlink" title="深入理解JVM–四种垃圾收集算法"></a>深入理解JVM–四种垃圾收集算法</h1><h2 id="一、标记-清除算法"><a href="#一、标记-清除算法" class="headerlink" title="一、标记-清除算法"></a>一、标记-清除算法</h2><p>算法分为“标记”和“清除”阶段：首先<strong>标记所有存活</strong>的对象，在标记完成后<strong>统一回收所有未标记</strong>的对象。它是最基础的收集算法，效率也很高。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584530746245.png" alt="1584530746245"></p><p>优点：执行效率高</p><p>缺点：1、标记清除后会产生大量不连续的碎片；2、分配速度慢，因为存在大量不连续碎片，每次分配都需要遍历空闲链表，找到足够大的内存空间存放对象</p><h2 id="二、复制算法"><a href="#二、复制算法" class="headerlink" title="二、复制算法"></a>二、复制算法</h2><p>为了解决标记-清除算法问题，“复制”收集算法出现了。它可以将<strong>内存分为大小相同的两块</strong>，<strong>每次使用其中的一块</strong>。当这一块的内存<strong>使用完后</strong>，就将<strong>还存活的对象有序复制到另一块</strong>去，然后再<strong>把使用的空间一次清理</strong>掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584530755486.png" alt="1584530755486"></p><p>优点：不存在大量不连续的内存碎片</p><p>缺点：使用效率低下，因为每次只使用其中一块内存空间</p><h2 id="三、标记-整理算法"><a href="#三、标记-整理算法" class="headerlink" title="三、标记-整理算法"></a>三、标记-整理算法</h2><p>根据老年代的特点特出的一种标记算法，<strong>标记</strong>过程仍然与<strong>“标记-清除”算法一样</strong>，清除的过程不同，让<strong>所有存活的对象向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584530762589.png" alt="1584530762589"></p><p>优点：不存在大量不连续的内存碎片</p><p>缺点： 整理会花一定的时间 </p><h2 id="四、分代收集算法"><a href="#四、分代收集算法" class="headerlink" title="四、分代收集算法"></a>四、分代收集算法</h2><p>当前<strong>虚拟机的垃圾收集都采用分代收集算法</strong>，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。一般将java堆分为新生代和老年代，这样我们就可以根据<strong>各个年代的特点选择合适的垃圾收集算法</strong>。</p><p>比如在<strong>新生代</strong>中，每次收集都会有<strong>大量对象死去</strong>，所以可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没<strong>有额外的空间对它进行分配担保</strong>，所以我们必须选择<strong>“标记-清除”或“标记-整理”</strong>算法进行垃圾收集。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–四种垃圾收集算法&quot;&gt;&lt;a href=&quot;#深入理解JVM–四种垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–四种垃圾收集算法&quot;&gt;&lt;/a&gt;深入理解JVM–四种垃圾收集算法&lt;/h1&gt;&lt;h2 id=&quot;一、标记-清除算法
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://deschen.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--对象存活分析算法</title>
    <link href="http://deschen.com/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%A4%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://deschen.com/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%A4%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</id>
    <published>2019-10-11T06:24:15.000Z</published>
    <updated>2021-02-12T11:14:04.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–对象存活分析算法"><a href="#深入理解JVM–对象存活分析算法" class="headerlink" title="深入理解JVM–对象存活分析算法"></a>深入理解JVM–对象存活分析算法</h1><blockquote><p> 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p></blockquote><h2 id="一、引用计数法"><a href="#一、引用计数法" class="headerlink" title="一、引用计数法"></a>一、引用计数法</h2><ul><li><p>概念：给对象中添加一个<strong>引用计数器</strong>，每当有一个地方<strong>引用</strong>它，计数器就<strong>加1</strong>；当<strong>引用失效</strong>，计数器就减1；任何时候计数器<strong>为0</strong>的对象就是<strong>不可能再被使用</strong>的。</p></li><li><p>分析：这个方法实现<strong>简单，效率高</strong>，但是目前<strong>主流的虚拟机</strong>中并<strong>没有选择这个算法</strong>来管理内存，其最主要的<strong>原因是</strong>它很难解决<strong>对象之间相互循环引用</strong>的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象<strong>testA</strong> 和 <strong>testB</strong> <strong>相互引用</strong>着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的<strong>引用计数器都不为0</strong>，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test testA = <span class="keyword">new</span> Test();</span><br><span class="line">        Test testA = <span class="keyword">new</span> Test();</span><br><span class="line">        testA.setObj(testB);</span><br><span class="line">        testB.setObj(testA);</span><br><span class="line">        testA = <span class="keyword">null</span>;</span><br><span class="line">        testB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、可达性分析算法"><a href="#二、可达性分析算法" class="headerlink" title="二、可达性分析算法"></a>二、可达性分析算法</h2><ul><li>概念：这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li><li><strong>GC Roots</strong>根节点：<strong>类加载器</strong>、<strong>Thread</strong>、虚拟机栈的本地变量表、<strong>static成员</strong>、<strong>常量引用</strong>、本地方法栈的变量等等</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210212191352321.png" alt="image-20210212191352321"></p><ul><li><strong>finalize()</strong>方法最终判定对象<strong>是否存活</strong><ul><li>即使在可达性分析算法中<strong>不可达的对象</strong>，也<strong>并非是一定会被回收</strong>的。要真正宣告一个对象死亡，至少要经历<strong>再次标记</strong>过程。</li><li>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</li><li>标记过程：<ul><li>第一次标记。筛选的条件是此对象是否<strong>有必要执行finalize()</strong>方法。当对象<strong>没有覆盖finalize方法</strong>，或者<strong>finalize方法已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。</li><li>第二次标记。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被<strong>放置在一个名为：F-Queue的队列</strong>之中，并在稍后由一条<strong>虚拟机自动建立的、低优先级的Finalizer线程</strong>去执行。这里所谓的“执行”是指虚拟机会<strong>触发这个方法，但并不承诺会等待它运行结束</strong>。这样做的原因是，如果一个对象f<strong>inalize()方法中执行缓慢，或者发生死循环（更极端的情况）</strong>，将很可能会导致F-Queue<strong>队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃</strong>。</li><li>finalize()–只要<strong>重新与引用链上的任何的一个对象建立关联</strong>即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–对象存活分析算法&quot;&gt;&lt;a href=&quot;#深入理解JVM–对象存活分析算法&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–对象存活分析算法&quot;&gt;&lt;/a&gt;深入理解JVM–对象存活分析算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://deschen.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--类加载过程详解</title>
    <link href="http://deschen.com/2019/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://deschen.com/2019/10/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-10-01T07:00:21.000Z</published>
    <updated>2020-03-18T13:39:14.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–类加载过程详解"><a href="#深入理解JVM–类加载过程详解" class="headerlink" title="深入理解JVM–类加载过程详解"></a>深入理解JVM–类加载过程详解</h1><blockquote><p>如果向学习和理解JVM的话，《深入理解JVM虚拟机》这本圣经必不可少的，我也是你们其中一份子，这本书看了一遍后有很多不懂，沮丧。。。也不敢装懂，不过该懂得还是懂一些，因此打算写几篇JVM得博客，巩固知识，也希望大伙能提点我的错误和不足</p><p>《深入理解JVM虚拟机》的分享链接：链接：<a href="https://pan.baidu.com/s/1fnTMWfC7Zi3HVJ5C78O80Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1fnTMWfC7Zi3HVJ5C78O80Q</a><br>提取码：hhmo</p></blockquote><h2 id="一、Java文件从编码完成到最终执行过程"><a href="#一、Java文件从编码完成到最终执行过程" class="headerlink" title="一、Java文件从编码完成到最终执行过程"></a>一、Java文件从编码完成到最终执行过程</h2><ul><li>编译：Java文件通过javac命令编译生成字节码，也就是.class文件</li><li>运行：.class文件交给JVM虚拟机进行<strong>类加载</strong>，到最后执行过程</li></ul><h2 id="二、类加载过程详解"><a href="#二、类加载过程详解" class="headerlink" title="二、类加载过程详解"></a>二、类加载过程详解</h2><h3 id="1、类加载的过程"><a href="#1、类加载的过程" class="headerlink" title="1、类加载的过程"></a>1、类加载的过程</h3><ul><li><p>过程： JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p></li><li><p>注意点：JVM<strong>不是一开始把所有的类</strong>加载进内存，而是需要的时候<strong>有且仅有一次</strong>加载</p></li></ul><h3 id="2、类加载五个阶段："><a href="#2、类加载五个阶段：" class="headerlink" title="2、类加载五个阶段："></a>2、类加载五个阶段：</h3><blockquote><p>类加载的顺序除了<strong>解析</strong>之外是<strong>固定</strong>的(  可以在<strong>初始化阶段之后</strong>再开始，这是为了支持Java语言的<strong>运行时绑定</strong>。例如<strong>多态</strong> )，但是<strong>不是连续</strong>(  因为这些阶段通常都是<strong>互相交叉的混合进行</strong>，通常会在一个阶段执行的过程中调用或者激活另一个阶段 )</p></blockquote><h4 id="2-1-加载："><a href="#2-1-加载：" class="headerlink" title="2.1 加载："></a>2.1 加载：</h4><ul><li>加载：将<strong>class文件</strong>通过<strong>类加载器</strong>存到内存中<ul><li>过程:<ol><li>通过一个<strong>类的全限定名来获取</strong>定义此类的二进制字节流。</li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong>。</li><li>在<strong>元空间</strong>中生成一个代表这个类的java.lang.<strong>Class对象</strong>，作为方法区这些数据的访问<strong>入口</strong>。（字段，方法名，常量池…）</li></ol></li><li>注意点：类的全限定名获取的<strong>来源</strong>没有确定，可以很多途径《深入理解Java虚拟机》书中有提，不会坑你们，嘻嘻</li><li>.class文件来源：<ol><li>本地磁盘</li><li>网络下载</li><li>下载的war，jar包</li><li>从专门的数据库中读取. class文件(少见)</li><li>将java源文件动态编译成 class文件1) 典型的就是动态代理,通过运行期生成 class文件 2) jsp转换成的servlet,而serlvet是一个java文件，会被编译成 class文件</li></ol></li><li>类加载器：( 这个在第二篇就会详细讲解 )<ul><li><strong>启动类加载器</strong>：负责加载JRE的核心类库，如jre目标下的rt.jar,charsets.jar等</li><li><strong>扩展类加载器</strong>：负责加载JRE扩展目录ext中JAR类包</li><li><strong>系统类加载器</strong>：负责加载ClassPath路径下的类包</li><li><strong>用户自定义加载器</strong>：负责加载用户自定义路径下的类包</li></ul></li></ul></li></ul><h4 id="2-2-链接：包含验证、准备、解析三个过程"><a href="#2-2-链接：包含验证、准备、解析三个过程" class="headerlink" title="2.2 链接：包含验证、准备、解析三个过程"></a>2.2 链接：包含验证、准备、解析三个过程</h4><h5 id="2-21-验证"><a href="#2-21-验证" class="headerlink" title="2.21 验证"></a>2.21 验证</h5><ul><li><p>验证： 为了保证加载进来的字节流<strong>符合虚拟机规范</strong>，不会造成安全错误。 </p></li><li><p>四种检验：</p><ol><li>文件格式的验证<ul><li>常量中是否有不被支持的常量？</li><li>指向常量的索引值是否指向不存在或不符合类型的常量等。</li><li>目的：保证输入的<strong>字节流</strong>能正确地<strong>解析并存储于方法区</strong>之内,格式上符合描述一个Java类型信息的要求。</li></ul></li><li>元数据的验证<ul><li>该类是否继承了被final修饰的类？</li><li>类中的字段，方法是否与父类冲突？是否出现了不合理的重载等？</li><li>目的：类的元数据信息进行语义校验,保证<strong>不存在不符合</strong>Java语言规范的<strong>元数据信息。</strong></li></ul></li><li>字节码的验证<ul><li>方法体的类型转换是否有效？例如：<strong>子类</strong>对象可以赋值于<strong>父类数据类型</strong>，反之发报错。</li><li><strong>任意时刻</strong>操作数栈的指令类型与指令代码序列是否配合工作。例如：操作数栈放置<strong>int类型</strong>，使用确实<strong>long类型</strong>载入本地变量表。</li><li>目的：通过数据流和控制流分析,确定程序语义是<strong>合法的、符合逻辑</strong>的。是对<strong>类的方法体的校验</strong></li></ul></li><li>符号引用的验证<ul><li>校验符号引用中通过全限定名是否能够找到对应的类？</li><li>校验符号引用中的访问性（private，public等）是否可被当前类访问？</li><li>目的：确保解析动作能正常执行</li></ul></li></ol></li></ul><h5 id="2-22-准备"><a href="#2-22-准备" class="headerlink" title="2.22 准备"></a>2.22 准备</h5><ul><li><p>准备：为类的<strong>静态变量</strong>分配内存并将其<strong>初始化为默认值</strong>，这些内存都将在<strong>方法区</strong>中进行分配。</p></li><li><p>注意点：</p><ol><li>类变量(被 <strong>static</strong>修饰的变量)，而<strong>不包括实例变量</strong>，实例变量将在对象实例化时随着对象一起分配在Java堆中。</li><li>这里所说的初始值“通常情况”下是数据类型的零值，引用类型是null。特殊情况：被final修饰的变量，会直接赋值<strong>给定值</strong></li></ol></li><li><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>   <span class="comment">// 准备阶段是：value=0，而不是123</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>   <span class="comment">// 准备阶段是：value=123</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-23-解析"><a href="#2-23-解析" class="headerlink" title="2.23 解析"></a>2.23 解析</h5><ul><li><p>解析：虚拟机将常量池内的符号引用替换为直接引用的过程</p></li><li><p>符号引用(Symlxiuc References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可。符号引用是与虚拟机实现的内存布局<strong>无关</strong>的</p></li><li><p>直接引用(Direct References)：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局<strong>相关</strong>的</p></li></ul><h4 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h4><ul><li><p>初始化： 为类的静态变量赋予<strong>真正</strong>的初始值 </p></li><li><p>与准备阶段的差别：</p><ul><li>准备阶段，变量已经赋过一次系统要求的<strong>初始值( 默认值 )</strong></li><li>初始化阶段，根据程序员通过程序制定的<strong>主观</strong>计划去<strong>初始化类变量和其他资源</strong></li></ul></li><li><p><code>&lt;clinit&gt;</code>方法描述：是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块( static块)</strong>中的语句合并产生的,编译器收集的顺序是由语句在<strong>源文件中出现的顺序</strong>所决定的</p></li><li><p>初始化分为<strong>主动引用</strong>和<strong>被动引用</strong></p><ul><li>主动引用：主动触发类的初始化<ul><li>对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。 <ol><li>创建<strong>类的实例</strong></li><li>访问类的<strong>静态变量</strong>( 不被<strong>final</strong>修饰的变量 )</li><li>访问类的<strong>静态方法</strong></li><li><strong>反射</strong></li><li>当初始化一个类时，发现其<strong>父类还未初始化</strong>，则先出发父类的初始化</li><li>虚拟机启动时，定义了<strong>main()</strong>方法的那个类先初始化</li></ol></li></ul></li><li>被动引用：不触发类的初始化<ul><li>子类调用<strong>父类的静态变量</strong>，子类不会被初始化。只有<strong>父类被初始化</strong></li><li>通过<strong>数组</strong>定义来引用类，不会触发类的初始化</li><li>访问<strong>类的常量</strong>，不会初始化类( 注意跟主动引用2情况区分 )</li></ul></li></ul></li><li><p>测试用例( 要用<code>System.out.println(&quot;***********主动引用X*********************&quot;);</code>分隔每个用例，要一个一个测试，不要全部，不然会造成误解。因为类<strong>有且仅有一次</strong>初始化，全部运行，运行结果又造成误解 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.deschen.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MainClass init 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MainClass init 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println("***********主动引用7*********************");   //主动引用7，直接运行，就可以了，结果如下图，其他大家可以自己测试</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//        System.out.println("***********主动引用1*********************");</span></span><br><span class="line"><span class="comment">//        new SuperClass();</span></span><br><span class="line"><span class="comment">//        System.out.println("***********主动引用2*********************");</span></span><br><span class="line"><span class="comment">//        System.out.println(SuperClass.value);</span></span><br><span class="line"><span class="comment">//        System.out.println("***********主动引用3*********************");</span></span><br><span class="line"><span class="comment">//        SuperClass.method();</span></span><br><span class="line"><span class="comment">//        System.out.println("***********主动引用4*********************");</span></span><br><span class="line"><span class="comment">//        Class.forName("cn.deschen.jvm.gc.ExtendClass");</span></span><br><span class="line"><span class="comment">//        System.out.println("***********主动引用5*********************");</span></span><br><span class="line"><span class="comment">//        System.out.println(ExtendClass.value);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println("***********被动引用1*********************");</span></span><br><span class="line"><span class="comment">//        System.out.println(SuperClass.value);// 被动引用1</span></span><br><span class="line"><span class="comment">//        System.out.println("***********被动引用2*********************");</span></span><br><span class="line"><span class="comment">//        SuperClass[] superClasses = new SuperClass[10];// 被动引用2</span></span><br><span class="line"><span class="comment">//        System.out.println("***********被动引用3*********************");</span></span><br><span class="line"><span class="comment">//        System.out.println(SuperClass.VALUE);// 被动引用3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> VALUE = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ExtendClass static Method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ExtendClass init 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ExtendClass init 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p> <img src="https://img-blog.csdnimg.cn/20200205143024192.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qmlTk2Zj-1580884042274)(C:\Users\20423\AppData\Roaming\Typora\typora-user-images\1580884002599.png)]"> </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–类加载过程详解&quot;&gt;&lt;a href=&quot;#深入理解JVM–类加载过程详解&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–类加载过程详解&quot;&gt;&lt;/a&gt;深入理解JVM–类加载过程详解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如果向学习
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://deschen.com/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Redis--集群部署</title>
    <link href="http://deschen.com/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://deschen.com/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</id>
    <published>2019-08-01T02:25:06.000Z</published>
    <updated>2021-02-24T09:32:24.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Redis–集群部署"><a href="#深入理解Redis–集群部署" class="headerlink" title="深入理解Redis–集群部署"></a>深入理解Redis–集群部署</h1><h2 id="一、启动集群"><a href="#一、启动集群" class="headerlink" title="一、启动集群"></a>一、启动集群</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8001/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8002/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8003/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8004/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8005/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8006/</span>redis.conf</span><br></pre></td></tr></table></figure><p># 客户端连接8001端口的redis实例</p><figure class="highlight plain"><figcaption><span>-a deschen -c -h 192.168.0.61 -p 8001````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\# 查看集群状态</span><br><span class="line"></span><br><span class="line">192.168.0.61:8001&gt; cluster nodes</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;01&#x2F;clip_image002.gif)</span><br><span class="line"></span><br><span class="line">从上图可以看出，整个集群运行正常，三个master节点和三个slave节点，8001端口的实例节点存储0-5460这些hash槽，8002端口的实例节点存储5461-10922这些hash槽，8003端口的实例节点存储10923-16383这些hash槽，这三个master节点存储的所有hash槽组成redis集群的存储槽位，slave点是每个主节点的备份从节点，不显示存储槽位  </span><br><span class="line"></span><br><span class="line">## 二、集群操作</span><br><span class="line"></span><br><span class="line">我们在原始集群基础上再增加一主(8007)一从(8008)，增加节点后的集群参见下图，新增节点用虚线框表示</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;01&#x2F;clip_image004.gif)</span><br><span class="line"></span><br><span class="line">### 1、增加redis实例</span><br><span class="line"></span><br><span class="line">在&#x2F;usr&#x2F;local&#x2F;redis-cluster下创建8007和8008文件夹，并拷贝8001文件夹下的redis.conf文件到8007和8008这两个文件夹下</span><br></pre></td></tr></table></figure><p>mkdir 8008</p><p>mkdir 8008</p><p>cd 8001</p><p>cp redis.conf /usr/local/redis-cluster/8007/</p><p>cp redis.conf /usr/local/redis-cluster/8008/</p><p>修改8007文件夹下的redis.conf配置文件</p><p>vim /usr/local/redis-cluster/8007/redis.conf</p><p>修改如下内容：</p><p>port:8007</p><p>dir /usr/local/redis-cluster/8007/</p><p>cluster-config-file nodes-8007.conf</p><p>修改8008文件夹下的redis.conf配置文件</p><p>vim /usr/local/redis-cluster/8008/redis.conf</p><p>修改内容如下：</p><p>port:8008</p><p>dir /usr/local/redis-cluster/8008/</p><p>cluster-config-file nodes8008.conf</p><p>启动8007和8008俩个服务并查看服务状态</p><p> /usr/local/redis-5.0.2/src/redis-server /usr/local/redis-cluster/8007/redis.conf</p><p> /usr/local/redis-5.0.2/src/redis-server /usr/local/redis-cluster/8008/redis.conf</p><p> ps -el | grep redis</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="number">2</span>、查看redis集群的命令帮助</span><br></pre></td></tr></table></figure><p>cd /usr/local/redis-5.0.2</p><p>src/redis-cli –cluster help</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">clipboard.png</span>](<span class="link">https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image006.gif</span>)</span><br></pre></td></tr></table></figure><p>1、create：创建一个集群环境host1:port1 … hostN:portN</p><p>2、call：可以执行redis命令</p><p>3、add-node：将一个节点添加到集群里，第一个参数为新节点的ip:port，第二个参数为集群中任意一个已经存在的节点的ip:port </p><p>4、del-node：移除一个节点</p><p>5、reshard：重新分片</p><p>6、check：检查集群状态</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">### 3、 配置8007为集群主节点</span></span><br><span class="line"></span><br><span class="line">使用<span class="code">```</span><span class="code">`add-node`</span><span class="code">```</span>命令新增一个主节点8007(master)，绿色为新增节点，红色为已知存在节点，看到日志最后有<span class="code">```</span><span class="code">`"[OK] New node added correctly"`</span><span class="code">```</span>提示代表新节点加入成功</span><br><span class="line"></span><br><span class="line"><span class="code">```</span><span class="code">`/usr/local/redis-5.0.2/src/redis-cli --cluster add-node 192.168.0.64:8007 192.168.0.61:8001`</span><span class="code">```</span> </span><br><span class="line"></span><br><span class="line">查看集群状态</span><br><span class="line"></span><br><span class="line">![<span class="string">clipboard.png</span>](<span class="link">https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image008.gif</span>)</span><br><span class="line"></span><br><span class="line">注意：当添加节点成功以后，新增的节点不会有任何数据，因为它还没有分配任何的slot(hash槽)，我们需要为新节点手工分配hash槽 </span><br><span class="line"></span><br><span class="line">使用redis-cli命令为8007分配hash槽，找到集群中的任意一个主节点(红色位置表示集群中的任意一个主节点)，对其进行重新分片工作。</span><br><span class="line"></span><br><span class="line"><span class="code">```</span>`/usr/local/redis-5.0.2/src/redis-cli --cluster reshard 192.168.0.61:8001</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输出如下：</span><br><span class="line"></span><br><span class="line">How many slots <span class="keyword">do</span> you want <span class="keyword">to</span> move (<span class="keyword">from</span> 1 <span class="keyword">to</span> 16384)? 600</span><br><span class="line"></span><br><span class="line">(ps:需要多少个槽移动到新的节点上，自己设置，比如600个hash槽)</span><br><span class="line"></span><br><span class="line">What is the receiving node ID? eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</span><br><span class="line"></span><br><span class="line">(ps:把这600个hash槽移动到哪个节点上去，需要指定节点id)</span><br><span class="line"></span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line"></span><br><span class="line"><span class="built_in"> Type </span><span class="string">'all'</span> <span class="keyword">to</span> use all the nodes as source nodes <span class="keyword">for</span> the hash slots.</span><br><span class="line"></span><br><span class="line"><span class="built_in"> Type </span><span class="string">'done'</span> once you entered all the source nodes IDs.</span><br><span class="line"></span><br><span class="line">Source node 1:all</span><br><span class="line"></span><br><span class="line">(ps:输入all为从所有主节点(8001,8002,8003)中分别抽取相应的槽数指定到新节点中，抽取的总槽数为600个)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> proceed with the proposed reshard plan (<span class="literal">yes</span>/<span class="literal">no</span>)? <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">(ps:输入<span class="literal">yes</span>确认开始执行分片任务)</span><br></pre></td></tr></table></figure><p>查看下最新的集群状态</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image010.gif" alt="clipboard.png"></p><p>如上图所示，现在我们的8007已经有hash槽了，也就是说可以在8007上进行读写数据啦！到此为止我们的8007已经加入到集群中，并且是主节点(Master)</p><h3 id="4、配置8008为8007的从节点"><a href="#4、配置8008为8007的从节点" class="headerlink" title="4、配置8008为8007的从节点"></a>4、配置8008为8007的从节点</h3><p>添加从节点8008到集群中去并查看集群状态</p><figure class="highlight plain"><figcaption><span>--cluster add-node 192.168.0.64:8008 192.168.0.61:8001````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![clipboard.png](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;01&#x2F;clip_image012.gif)</span><br><span class="line"></span><br><span class="line">如图所示，还是一个master节点，没有被分配任何的hash槽。</span><br><span class="line"></span><br><span class="line">我们需要执行replicate命令来指定当前节点(从节点)的主节点id为哪个,首先需要连接新加的8008节点的客户端，然后使用集群命令进行操作，把当前的8008(slave)节点指定到一个主节点下(这里使用之前创建的8007主节点，红色表示节点id)</span><br></pre></td></tr></table></figure><p>/usr/local/redis-5.0.2/src/redis-cli -c -h 192.168.0.64 -p 8008</p><p>192.168.0.61:8008&gt; cluster replicate eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\# 查看集群状态，<span class="number">8008</span>节点已成功添加为<span class="number">8007</span>节点的从节点</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:<span class="comment">//root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image014.gif)</span></span><br><span class="line"></span><br><span class="line">### <span class="number">5</span>、删除<span class="number">8008</span>从节点</span><br><span class="line"></span><br><span class="line">用del-node删除从节点<span class="number">8008</span>，指定删除节点ip和端口，以及节点id(红色为<span class="number">8008</span>节点id)</span><br><span class="line"></span><br><span class="line">````/usr/local/redis<span class="number">-5.0</span><span class="number">.2</span>/src/redis-cli --cluster del-node <span class="number">192.168</span><span class="number">.0</span><span class="number">.64</span>:<span class="number">8008</span> <span class="number">1805</span>b6339d91b0e051f46845eebacb9bc43baefe</span><br></pre></td></tr></table></figure><p>再次查看集群状态，如下图所示，8008这个slave节点已经移除，并且该节点的redis服务也已被停止</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image016.gif" alt="clipboard.png"></p><h3 id="6、删除8007主节点"><a href="#6、删除8007主节点" class="headerlink" title="6、删除8007主节点"></a>6、删除8007主节点</h3><p>最后，我们尝试删除之前加入的主节点8007，这个步骤相对比较麻烦一些，因为主节点的里面是有分配了hash槽的，所以我们这里必须先把8007里的hash槽放入到其他的可用主节点中去，然后再进行移除节点操作，不然会出现数据丢失问题(目前只能把master的数据迁移到一个节点上，暂时做不了平均分配功能)，执行命令如下：</p><figure class="highlight plain"><figcaption><span>--cluster reshard 192.168.0.64:8007````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出如下：</span><br></pre></td></tr></table></figure><p>How many slots do you want to move (from 1 to 16384)? 600</p><p>What is the receiving node ID? deedad3c34e8437baa6ff013fd3d1461a0c2e761</p><p>(ps:这里是需要把数据移动到哪？8001的主节点id)</p><p>Please enter all the source node IDs.</p><p> Type ‘all’ to use all the nodes as source nodes for the hash slots.</p><p> Type ‘done’ once you entered all the source nodes IDs.</p><p>Source node 1:eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</p><p>(ps:这里是需要数据源，也就是我们的8007节点id)</p><p>Source node 2:done</p><p>(ps:这里直接输入done 开始生成迁移计划)</p><p>Do you want to proceed with the proposed reshard plan (yes/no)? Yes</p><p>(ps:这里输入yes开始迁移)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">至此，我们已经成功的把<span class="number">8007</span>主节点的数据迁移到<span class="number">8001</span>上去了，我们可以看一下现在的集群状态如下图，你会发现<span class="number">8007</span>下面已经没有任何hash槽了，证明迁移成功！</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:<span class="comment">//root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image018.gif)</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">最后我们直接使用del-node命令删除<span class="number">8007</span>主节点即可（红色表示<span class="number">8007</span>的节点id）。</span><br><span class="line"></span><br><span class="line">````/usr/local/redis<span class="number">-5.0</span><span class="number">.2</span>/src/redis-cli --cluster del-node <span class="number">192.168</span><span class="number">.0</span><span class="number">.64</span>:<span class="number">8007</span>  eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</span><br></pre></td></tr></table></figure><p># 查看集群状态，一切还原为最初始状态啦！大功告成！</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image020.gif" alt="clipboard.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Redis–集群部署&quot;&gt;&lt;a href=&quot;#深入理解Redis–集群部署&quot; class=&quot;headerlink&quot; title=&quot;深入理解Redis–集群部署&quot;&gt;&lt;/a&gt;深入理解Redis–集群部署&lt;/h1&gt;&lt;h2 id=&quot;一、启动集群&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://deschen.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://deschen.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis--集群讲解</title>
    <link href="http://deschen.com/2019/07/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E8%AE%B2%E8%A7%A3/"/>
    <id>http://deschen.com/2019/07/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E8%AE%B2%E8%A7%A3/</id>
    <published>2019-07-20T00:41:38.000Z</published>
    <updated>2021-02-24T09:32:15.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis集群详解"><a href="#Redis集群详解" class="headerlink" title="Redis集群详解"></a>Redis集群详解</h1><h2 id="一、Redis有三种集群模式"><a href="#一、Redis有三种集群模式" class="headerlink" title="一、Redis有三种集群模式"></a>一、Redis有三种集群模式</h2><ul><li>主从模式</li><li>Sentinel模式( 哨兵模式 )</li><li>Cluster模式( 集群模式 )</li></ul><p>PS ：集群查看命令： <code>info replication</code> </p><h2 id="二、主从模式"><a href="#二、主从模式" class="headerlink" title="二、主从模式"></a>二、主从模式</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>主从模式是三种模式中最简单的，在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)。</p><h3 id="2、工作机制："><a href="#2、工作机制：" class="headerlink" title="2、工作机制："></a>2、工作机制：</h3><p>当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。</p><h3 id="3、优缺点"><a href="#3、优缺点" class="headerlink" title="3、优缺点"></a>3、优缺点</h3><ul><li>优点：<ul><li>1、高可靠性，主从实时备份，有效解决单节点数据丢失问题。</li><li>2、可做读写分离，从库分担读操作，缓解主库压力</li></ul></li><li>缺点：主库异常，需要手动主从切换</li></ul><h2 id="三、Sentinel模式"><a href="#三、Sentinel模式" class="headerlink" title="三、Sentinel模式"></a>三、Sentinel模式</h2><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> 监控redis集群的运行状况 </p><h3 id="2、工作机制：-1"><a href="#2、工作机制：-1" class="headerlink" title="2、工作机制："></a>2、工作机制：</h3><ul><li><p>假设主节点宕机，第一个哨兵先检测到这个结果，第一个哨兵主标志为<strong>主观下线</strong>。</p></li><li><p>当后面的哨兵也检测到主节点为<strong>主观下线</strong>，并且数量达到一定值时，就会标志为<strong>客观下线</strong></p></li><li><p>在认为主节点<strong>客观下线</strong>的情况下,哨兵节点节点间会发起一次选举，如果超过半数以上的节点返回，则将该节点标记为leader的情况下，对<strong>故障的主节点</strong>所属的<strong>从节点中</strong>选取<strong>新的主节点</strong></p><p>当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的ip和port，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。 </p></li></ul><h3 id="3、优缺点-1"><a href="#3、优缺点-1" class="headerlink" title="3、优缺点"></a>3、优缺点</h3><ul><li>优点：有效解决主从模式主库异常手动主从切换的问题</li><li>缺点：运维复杂，哨兵选举期间，不能对外提供服务</li></ul><h2 id="四、Cluster模式"><a href="#四、Cluster模式" class="headerlink" title="四、Cluster模式"></a>四、Cluster模式</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。  </p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581473766762.png" alt="1581473766762"></p><h3 id="3、槽位"><a href="#3、槽位" class="headerlink" title="3、槽位"></a>3、槽位</h3><p>Redis Cluster 将所有数据划分为 <strong>16384</strong> 的 slots( 槽位 ）</p><p>当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p><h3 id="4、槽位定位算法"><a href="#4、槽位定位算法" class="headerlink" title="4、槽位定位算法"></a>4、槽位定位算法</h3><p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。</p><p>HASH_SLOT = CRC16(key) mod 16384</p><h3 id="5、跳转重定位"><a href="#5、跳转重定位" class="headerlink" title="5、跳转重定位"></a>5、跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581474165999.png" alt="1581474165999"></p><h3 id="6、网络抖动"><a href="#6、网络抖动" class="headerlink" title="6、网络抖动"></a>6、网络抖动</h3><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。</p><p>为解决这种问题，Redis Cluster 提供了一种选项cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p><h3 id="7、选举原理分析"><a href="#7、选举原理分析" class="headerlink" title="7、选举原理分析"></a>7、选举原理分析</h3><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p><p>1.slave发现自己的master变为FAIL</p><p>2.将自己记录的集群cluster_current_epoch(选举周期)加1( 查看命令：<code>cluster info</code>)，并广播FAILOVER_AUTH_REQUEST 信息</p><p>3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p><p>4.尝试failover的slave收集FAILOVER_AUTH_ACK</p><p>5.超过半数后变成新Master</p><p>6.广播通知其他集群节点。</p><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p><p>延迟计算公式：</p><p> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p><p>•SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis集群详解&quot;&gt;&lt;a href=&quot;#Redis集群详解&quot; class=&quot;headerlink&quot; title=&quot;Redis集群详解&quot;&gt;&lt;/a&gt;Redis集群详解&lt;/h1&gt;&lt;h2 id=&quot;一、Redis有三种集群模式&quot;&gt;&lt;a href=&quot;#一、Redis有三种集
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://deschen.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="redis" scheme="http://deschen.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>分库分表理论篇——以MySQL为例</title>
    <link href="http://deschen.com/2019/07/17/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%A5MySQL%E4%B8%BA%E4%BE%8B/"/>
    <id>http://deschen.com/2019/07/17/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E2%80%94%E2%80%94%E4%BB%A5MySQL%E4%B8%BA%E4%BE%8B/</id>
    <published>2019-07-17T02:34:14.000Z</published>
    <updated>2020-11-11T03:50:57.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分库分表——-以MySQL为例"><a href="#分库分表——-以MySQL为例" class="headerlink" title="分库分表—— 以MySQL为例"></a>分库分表—— 以MySQL为例</h1><h2 id="一、为什么要分库分表？"><a href="#一、为什么要分库分表？" class="headerlink" title="一、为什么要分库分表？"></a>一、为什么要分库分表？</h2><p><code>单库单表</code>虽然容易对数据进行操作，但是其容量是<code>有限</code>的。对于日益扩充的数据来说，会造成<code>数据查询速度慢</code>以及<code>加大服务器的压力</code>。据了解，医疗行业的业务数据很多都是<code>不能删除</code>的，数据久而久之堆积会影响应用程序的执行效率，就会影响用户的体验等。因此我觉得有必要了解下分库分表。</p><h2 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h2><p>这里我想到几种优化的方法</p><ul><li>减少数据库访问压力<ul><li>使用<strong>缓存</strong>技术，对数据库的信息进行缓存，减少数据库访问压力</li><li>使用<strong>Nginx</strong>进行静态资源的获取，对一些高访问的<strong>网页</strong>，一次访问时可以先生成<strong>静态页面</strong>存到<strong>本地</strong>中，用户再次访问就会直接返回，这样减少与数据库的交互和渲染页面的操作，提高效率</li><li>读写分离<ul><li>互联网业务一般<strong>读多写少</strong>，<strong>读写</strong>比例基本是<strong>10:1</strong>。比如订单业务，顾客购买商品生成<strong>一次</strong>订单后，就会<strong>多次</strong>查看订单情况。这时可以采用<strong>主从架构</strong>，<strong>主库</strong>负责<strong>DML</strong>(增删改)操作，<strong>从库</strong>负责<strong>DQL</strong>(查看操作)，<strong>一</strong>个主库可以有<strong>多</strong>个从库，极大减轻读写压力</li></ul></li></ul></li><li>提升数据库性能<ul><li>可以从机器性能入手，内存不够加内存条，外存( 如硬盘 )不够加外存，这样即使数据量在大，也不会影响I/O读写速率，<strong>但是</strong>，数据量大会增加<strong>I/O的次数</strong>，数据库性能依旧会下降，不推荐，成本太高，没钱花，/(ㄒoㄒ)/~~</li><li>优化数据库<strong>索引</strong>，数据库<strong>语句</strong>，这个我将会写篇博客，具体介绍</li><li>分库分表<ul><li>分库分表要<strong>按业务进行拆分</strong>，具体后面会说。主要是打破<strong>单库单表</strong>的情况，数据存在<strong>多库多表</strong>中。打个比方，100W条数据存在10个库中，10个库有10张相同的表，那么一张表存的数据就会1W条左右，这样减低数据库的容量，提升I/O操作速率，提高数据库的性能</li></ul></li></ul></li></ul><h2 id="三、什么是分库分表"><a href="#三、什么是分库分表" class="headerlink" title="三、什么是分库分表"></a>三、什么是分库分表</h2><blockquote><p> 分库分表，顾名思义就是拆分数据库和拆分数据表。问题就来了，要怎么拆分数据库和数据表呢？</p></blockquote><p>这里用一张电商的数据库的ER图拆分<br><img src="https://img-blog.csdnimg.cn/20200119164837128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>垂直拆分( 以电商ER图拆分 )</p><ul><li><p>垂直拆库：按照业务拆分，<strong>业务耦合性低的数据表</strong>拆分到<strong>不同数据库</strong>中。比如电商数据库拆分成用户库、商品库、订单库…<strong>但是</strong>，不是什么表都可以分库的，例如：订单库有<strong>订单表和订单明细表</strong>，这两张表<strong>耦合性高</strong>，必须放在一起</p></li><li><p>垂直拆表：按照数据表的<strong>字段热点</strong>(就是使用<strong>频率高</strong>)和字段<strong>存储类型</strong>进行拆分。比如电商中商品不是有<strong>文字描述</strong>吗？可是我们一般看商品的<strong>标题，价格，图片</strong>，对于<strong>文字描述</strong>字段一般点进去才看(查看<strong>频率不如前者高</strong>)，那么我们可以把商品表除文字描述这些大字段拆分出另一张表使用，提高查询性能</p><p>PS：拆分大字段还有另一个原因，因为大字段读取时间长，数据量大的话，影响I/O的读取效率<br><img src="https://img-blog.csdnimg.cn/20200119164926806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>特点：</p><ul><li>每个库（表）的结构都不一样</li><li>每个库（表）的数据都（至少有一列）一样  </li><li>每个库（表）的并集是全量数据</li></ul></li></ul></li><li><p>水平拆分( 以电商ER图拆分)</p><ul><li><p>水平拆库：把<strong>单个数据库</strong>的数据拆分成<strong>多个相同结构数据库</strong>存储</p></li><li><p>水平拆表：把<strong>单表</strong>的数据量拆分成<strong>多个相同结构表</strong>存储</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200119164947411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="img"></p><ul><li><p>以上两者合并达到分库分表<br><img src="https://img-blog.csdnimg.cn/20200119165023617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>特点：</p><ul><li>每个库（表）的结构都不一样</li><li>每个库（表）的数据都（至少有一列）一样  </li><li>每个库（表）的并集是全量数据</li></ul></li></ul></li></ul><h2 id="四、优势和弊端"><a href="#四、优势和弊端" class="headerlink" title="四、优势和弊端"></a>四、优势和弊端</h2><ul><li>优点：<ul><li>减少数据库的访问压力和单个存储容量</li></ul></li><li>弊端：<ul><li>增加了我们维护成本，毕竟多个数据库和数据表维护</li><li>分布式事务（跨库事务），比如：处理一个业务需要执行多条插入语句，每条在不同机器的不同数据库中，出现问题，如何回滚</li><li>跨库join，因为在不同数据库中，就无法使用join命令获取信息</li></ul></li></ul><h2 id="五、推荐中间件Sharding-JDBC（点击跳到官方文档）"><a href="#五、推荐中间件Sharding-JDBC（点击跳到官方文档）" class="headerlink" title="五、推荐中间件Sharding-JDBC（点击跳到官方文档）"></a>五、推荐中间件<a href="https://shardingsphere.apache.org/document/legacy/4.x/document/cn/overview/" target="_blank" rel="noopener">Sharding-JDBC（点击跳到官方文档）</a></h2><blockquote><p>Sharding-JDBC是在应用层进行对sql语句进行封装的中间件，它通过数据分片、路由等策略将数据存到不同库表中</p></blockquote><ol><li>数据分片<ul><li>含义：将单一数据库中的数据分散地存放至多个数据库或表中</li><li>分片方式：垂直分片、水平分片（分别对应三标题的业务拆分）</li><li>主键：雪花算法、UUID，也可以自己创建主键规则（<code>实现ShardingKeyGenerator</code>）</li><li>数据分片规则：SQL解析 =&gt; 执行器优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt; 结果归并</li><li>SQL注意事项<ul><li>逻辑表：就是水平分表的数据表的总称（该表实际不存在）。在代码操作的SQL语句的表都是逻辑表(<code>t_order</code>)，但经过Sharding-JDBC就会执行到具体数据库的具体表（<code>t_order0 ~ t_order9</code>)</li><li>真实表：就是<code>t_order0 ~ t_order9</code></li><li>数据节点：数据源名称和数据表组成，如<code>ds_0.t_order0</code></li><li>绑定表：就是将分片规则一致的主表和子表绑定。避免关联查询不会出现<strong>笛卡尔积关联</strong><ul><li>订单表<code>t_order0~t_order1</code>和订单详情<code>t_orderdetail0~t_orderdetail1</code>以<code>order_id%2</code>分片，那么<code>order_id为双数在t_order0和t_orderdetail0</code>，<code>order_id为单数在t_order1和t_orderdetail1</code>，可见数据绝对不会插入<code>t_order0和t_orderdetail1</code>或<code>t_order1和t_orderdetail0</code>这种情况。然而如果不绑定的话，查询就会出现<code>2*2现象</code>，出现不必要的查询，降低查询效率</li></ul></li></ul></li></ul></li></ol><p><img src="https://shardingsphere.apache.org/document/legacy/4.x/document/img/sharding/sharding_architecture_cn.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li><p>读写分离</p><ul><li>含义：同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性</li><li>操作：数据库要配置主从模式，因为Sharding-JDBC不支持数据同步</li></ul></li><li><p>事务处理</p><ul><li>本地事务</li><li>两阶段事务-XA</li><li>SAGA柔性事务</li><li>Seata柔性事务</li></ul></li><li><p>其他请看官方文档</p></li></ol><h2 id="六、实战"><a href="#六、实战" class="headerlink" title="六、实战"></a>六、实战</h2><ul><li><p><a href="https://shardingsphere.apache.org/document/legacy/4.x/document/cn/manual/sharding-jdbc/configuration/" target="_blank" rel="noopener">Sharding-JDBC配置</a>——这里使用springboot配置</p><ul><li>依赖</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.0.0-RC2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;sharding-core-common&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.0.0-RC2&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">   <span class="attr">shardingsphere:</span></span><br><span class="line">        <span class="attr">datasource:</span></span><br><span class="line">            <span class="attr">ss_ds1:</span>  <span class="comment">## 分库表名</span></span><br><span class="line">                <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">Root@123</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ss_ds1</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">            <span class="attr">ss_ds2:</span>  <span class="comment">## 分库表名</span></span><br><span class="line">                <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">                <span class="attr">password:</span> <span class="string">Root@123</span></span><br><span class="line">                <span class="attr">type:</span> <span class="string">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class="line">                <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ss_ds2</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">sharding:</span>  </span><br><span class="line">            <span class="attr">binding-tables:</span> <span class="string">t_order,t_orderdetail</span>   <span class="comment">## 绑定表</span></span><br><span class="line">            <span class="attr">default-database-strategy:</span>  </span><br><span class="line">                <span class="attr">inline:</span></span><br><span class="line">                    <span class="attr">algorithm-expression:</span> <span class="string">ss_ds$-&gt;&#123;user_id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span></span><br><span class="line">                    <span class="attr">sharding-column:</span> <span class="string">user_id</span></span><br><span class="line">            <span class="attr">tables:</span></span><br><span class="line">                <span class="attr">t_order:</span></span><br><span class="line">                    <span class="attr">actual-data-nodes:</span> <span class="string">ss_ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span></span><br><span class="line">                    <span class="attr">table-strategy:</span></span><br><span class="line">                        <span class="attr">inline:</span></span><br><span class="line">                            <span class="attr">algorithm-expression:</span> <span class="string">t_order$-&gt;&#123;order_id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span>    <span class="comment">## 分片算法</span></span><br><span class="line">                            <span class="attr">sharding-column:</span> <span class="string">order_id</span></span><br><span class="line">                <span class="attr">t_order_item:</span></span><br><span class="line">                    <span class="attr">actual-data-nodes:</span> <span class="string">ss_ds$-&gt;&#123;0..1&#125;.t_orderdetail$-&gt;&#123;0..1&#125;</span></span><br><span class="line">                    <span class="attr">table-strategy:</span></span><br><span class="line">                        <span class="attr">inline:</span></span><br><span class="line">                            <span class="attr">algorithm-expression:</span> <span class="string">t_orderdetail$-&gt;&#123;order_id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span></span><br><span class="line">                            <span class="attr">sharding-column:</span> <span class="string">order_id</span></span><br></pre></td></tr></table></figure><ul><li>自定义主键（目前知道的是Mybatis支持，但JPA不支持）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、实现接口ShardingKeyGenerator</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomKeyGenerator</span> <span class="keyword">implements</span> <span class="title">ShardingKeyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Comparable&lt;?&gt; generateKey() &#123;</span><br><span class="line">       <span class="comment">// 主键生成处理</span></span><br><span class="line">        <span class="keyword">return</span> id;                   <span class="comment">// 主键生成</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CustomKeyGenerator"</span>;             <span class="comment">//用于配置文件使用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2、在resources目录下新建META-INF文件夹，再新建services文件夹，文件名为CustomKeyGenerator全路径</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 3、配置文件    </span></span><br><span class="line">spring.shardingsphere.sharding.tables.&#123;表名&#125;.key-generator.column=id          ## generateKey()返回值   </span><br><span class="line">spring.shardingsphere.sharding.tables.&#123;表名&#125;.key-generator.type=CustomKeyGenerator   ## getType()返回值</span><br></pre></td></tr></table></figure><ul><li>业务逻辑处理（跟传统<code>JPA</code>一样，这里不做多说明）</li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Sharding-JDBC是一款不错的分库分表中间件，虽然我对此理解学习不够全面，如果有不足的地方希望大家赐教，相互学习，后期我会继续更新文章内容。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分库分表——-以MySQL为例&quot;&gt;&lt;a href=&quot;#分库分表——-以MySQL为例&quot; class=&quot;headerlink&quot; title=&quot;分库分表—— 以MySQL为例&quot;&gt;&lt;/a&gt;分库分表—— 以MySQL为例&lt;/h1&gt;&lt;h2 id=&quot;一、为什么要分库分表？&quot;&gt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://deschen.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>分库分表理论篇——以MySQL为例</title>
    <link href="http://deschen.com/2019/07/17/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%90%86%E8%AE%BA%E7%AF%87%E2%80%94%E2%80%94%E4%BB%A5MySQL%E4%B8%BA%E4%BE%8B/"/>
    <id>http://deschen.com/2019/07/17/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%90%86%E8%AE%BA%E7%AF%87%E2%80%94%E2%80%94%E4%BB%A5MySQL%E4%B8%BA%E4%BE%8B/</id>
    <published>2019-07-17T02:34:14.000Z</published>
    <updated>2019-07-17T02:36:35.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分库分表理论篇——-以MySQL为例"><a href="#分库分表理论篇——-以MySQL为例" class="headerlink" title="分库分表理论篇—— 以MySQL为例"></a>分库分表理论篇—— 以MySQL为例</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>当今互联网大爆炸的时代，<strong>业务</strong>越来越多和大，<strong>单库单表</strong>数据超出数据库支持<strong>容量</strong>，数据库<strong>I/O操作</strong>次数会越来越多和慢，数据库的整体<strong>性能</strong>就会急剧下降。</p><h2 id="二、如何优化"><a href="#二、如何优化" class="headerlink" title="二、如何优化"></a>二、如何优化</h2><p>这里我想到几种优化的方法</p><ul><li>减少数据库访问压力<ul><li>使用<strong>缓存</strong>技术，对数据库的信息进行缓存，减少数据库访问压力</li><li>使用<strong>Nginx</strong>进行静态资源的获取，对一些高访问的<strong>网页</strong>，一次访问时可以先生成<strong>静态页面</strong>存到<strong>本地</strong>中，用户再次访问就会直接返回，这样减少与数据库的交互和渲染页面的操作，提高效率</li><li>读写分离<ul><li>互联网业务一般<strong>读多写少</strong>，<strong>读写</strong>比例基本是<strong>10:1</strong>。比如订单业务，顾客购买商品生成<strong>一次</strong>订单后，就会<strong>多次</strong>查看订单情况。这时可以采用<strong>主从架构</strong>，<strong>主库</strong>负责<strong>DML</strong>(增删改)操作，<strong>从库</strong>负责<strong>DQL</strong>(查看操作)，<strong>一</strong>个主库可以有<strong>多</strong>个从库，极大减轻读写压力</li></ul></li></ul></li><li>提升数据库性能<ul><li>可以从机器性能入手，内存不够加内存条，外存( 如硬盘 )不够加外存，这样即使数据量在大，也不会影响I/O读写速率，<strong>但是</strong>，数据量大会增加<strong>I/O的次数</strong>，数据库性能依旧会下降，不推荐，成本太高，没钱花，/(ㄒoㄒ)/~~</li><li>优化数据库<strong>索引</strong>，数据库<strong>语句</strong>，这个我将会写篇博客，具体介绍</li><li>分库分表<ul><li>分库分表要<strong>按业务进行拆分</strong>，具体后面会说。主要是打破<strong>单库单表</strong>的情况，数据存在<strong>多库多表</strong>中。打个比方，100W条数据存在10个库中，10个库有10张相同的表，那么一张表存的数据就会1W条左右，这样减低数据库的容量，提升I/O操作速率，提高数据库的性能</li></ul></li></ul></li></ul><h2 id="三、什么是分库分表"><a href="#三、什么是分库分表" class="headerlink" title="三、什么是分库分表"></a>三、什么是分库分表</h2><blockquote><p> 分库分表，顾名思义就是拆分数据库和拆分数据表。问题就来了，要怎么拆分数据库和数据表呢？</p></blockquote><p>这里用一张电商的数据库的ER图拆分<br><img src="https://img-blog.csdnimg.cn/20200119164837128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>垂直拆分( 以电商ER图拆分 )</p><ul><li><p>垂直拆库：按照业务拆分，<strong>业务耦合性低的数据表</strong>拆分到<strong>不同数据库</strong>中。比如电商数据库拆分成用户库、商品库、订单库…<strong>但是</strong>，不是什么表都可以分库的，例如：订单库有<strong>订单表和订单明细表</strong>，这两张表<strong>耦合性高</strong>，必须放在一起</p></li><li><p>垂直拆表：按照数据表的<strong>字段热点</strong>(就是使用<strong>频率高</strong>)和字段<strong>存储类型</strong>进行拆分。比如电商中商品不是有<strong>文字描述</strong>吗？可是我们一般看商品的<strong>标题，价格，图片</strong>，对于<strong>文字描述</strong>字段一般点进去才看(查看<strong>频率不如前者高</strong>)，那么我们可以把商品表除文字描述这些大字段拆分出另一张表使用，提高查询性能</p><p>PS：拆分大字段还有另一个原因，因为大字段读取时间长，数据量大的话，影响I/O的读取效率<br><img src="https://img-blog.csdnimg.cn/20200119164926806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>特点：</p><ul><li>每个库（表）的结构都不一样</li><li>每个库（表）的数据都（至少有一列）一样  </li><li>每个库（表）的并集是全量数据</li></ul></li></ul></li><li><p>水平拆分( 以电商ER图拆分)</p><ul><li><p>水平拆库：把<strong>单个数据库</strong>的数据拆分成<strong>多个相同结构数据库</strong>存储</p></li><li><p>水平拆表：把<strong>单表</strong>的数据量拆分成<strong>多个相同结构表</strong>存储</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200119164947411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ennDrFQt-1579422434154)(C:\Users\20423\AppData\Roaming\Typora\typora-user-images\1579421448(1)\].jpg)"></p><ul><li><p>以上两者合并达到分库分表<br><img src="https://img-blog.csdnimg.cn/20200119165023617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>特点：</p><ul><li>每个库（表）的结构都不一样</li><li>每个库（表）的数据都（至少有一列）一样  </li><li>每个库（表）的并集是全量数据</li></ul></li></ul></li></ul><h2 id="三、优势和弊端"><a href="#三、优势和弊端" class="headerlink" title="三、优势和弊端"></a>三、优势和弊端</h2><ul><li>优点：<ul><li>减少数据库的访问压力和单个存储容量</li></ul></li><li>弊端：<ul><li>增加了我们维护成本，毕竟多个数据库和数据表维护</li><li>分布式事务（跨库事务），比如：处理一个业务需要执行多条插入语句，每条在不同机器的不同数据库中，出现问题，如何回滚</li><li>跨库join，因为在不同数据库中，就无法使用join命令获取信息</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分库分表理论篇——-以MySQL为例&quot;&gt;&lt;a href=&quot;#分库分表理论篇——-以MySQL为例&quot; class=&quot;headerlink&quot; title=&quot;分库分表理论篇—— 以MySQL为例&quot;&gt;&lt;/a&gt;分库分表理论篇—— 以MySQL为例&lt;/h1&gt;&lt;h2 id=&quot;一
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://deschen.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL索引深入理解</title>
    <link href="http://deschen.com/2019/07/13/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://deschen.com/2019/07/13/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2019-07-13T10:21:45.000Z</published>
    <updated>2021-03-03T14:53:45.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>[toc]</p><h2 id="一、什么是索引？"><a href="#一、什么是索引？" class="headerlink" title="一、什么是索引？"></a>一、什么是索引？</h2><p>索引是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></p><h2 id="二、底层知识铺垫-–-计算机组成原理"><a href="#二、底层知识铺垫-–-计算机组成原理" class="headerlink" title="二、底层知识铺垫 – 计算机组成原理"></a>二、底层知识铺垫 – 计算机组成原理</h2><blockquote><p>有没想过1、索引的数据结构为什么不是二叉排序树、红黑树、Hash、B树？而是B+树？2、为什么索引能是排好序的？</p><p>这些需要计算机组成原理的知识才能解决！希望大伙认真看，踊跃发言，互相学习</p></blockquote><h3 id="1、磁盘的读取原理"><a href="#1、磁盘的读取原理" class="headerlink" title="1、磁盘的读取原理"></a>1、磁盘的读取原理</h3><ul><li><p>索引存储在文件中，也就是说，查询索引就需要磁盘I/O操作，而磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。 </p></li><li><p>磁盘的机械运动是怎么样子的？时间消耗多大？</p><ul><li><p>磁盘结构图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTgvMTM1MDU0NjY2N184NjI4LmpwZw?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTgvMTM1MDU0NjY3MF84ODI5LmpwZw?x-oss-process=image/format,png" alt="img"></p></li><li><p>概念：</p><ul><li><strong>磁道</strong>：以盘片中心为圆心，用不同的半径，划分出不同的很窄的圆环形区域，称为磁道</li><li><strong>扇区</strong>：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区.扇区是磁盘最小的物理存储单元</li><li><strong>柱面</strong>：上下一串盘片中，相同半径的磁道所组成的一个圆柱型的环壁，就称为柱面</li></ul></li><li><p>磁盘读取时间计算：</p><ul><li><strong>寻道时间</strong>：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快。主流磁盘一般在5ms以下；</li><li><strong>旋转延迟</strong>：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。比如： 一个 7200（转 / 每分钟）的硬盘，平均旋转延迟时间为 1 ÷ ( 7200 ÷ 60 ) ÷ 2＝4.17ms（最多旋转１圈，最少不用旋转，平均情况下，需要旋转半圈）。 </li><li><strong>数据传输时间</strong>：完成传输所请求的数据所需要的时间。一般在零点几毫秒，相对于前两个时间可以忽略不计。</li><li>可见，磁盘I/O时间取决于寻道时间和旋转延迟</li></ul></li></ul></li></ul><h3 id="2、内存的读取原理"><a href="#2、内存的读取原理" class="headerlink" title="2、内存的读取原理"></a>2、内存的读取原理</h3><ul><li><p>内存的地址：计算机使用的主存基本都是随机读写存储器（RAM），内存可以抽象概括为一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元由行和列构成唯一的地址。 </p></li><li><p>内存读取原理：当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。由图可见，内存的读取时间仅与读取的次数呈线性关系，无机械操作，查询时间短、效率高</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/5.png" alt="img"> </p></li></ul><h3 id="3、-从内存读取到磁盘预读"><a href="#3、-从内存读取到磁盘预读" class="headerlink" title="3、 从内存读取到磁盘预读"></a>3、 <strong>从内存读取到磁盘预读</strong></h3><ul><li>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：  *<em>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。 *</em>  </li><li>另一个原因： 由于磁盘顺序读取的效率很高（<strong>不需要寻道时间</strong>，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 </li><li>预读的长度一般为<strong>页（page）的整倍数</strong>。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），<strong>主存和磁盘以页为单位交换数据</strong>。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</li></ul><h2 id="三、索引的数据结构"><a href="#三、索引的数据结构" class="headerlink" title="三、索引的数据结构"></a>三、索引的数据结构</h2><blockquote><p>第二部分主要用于B+树上,页的概念和预读十分重要,方便下面理解</p></blockquote><h3 id="1、不用二叉排序树、Hash、B树的分析"><a href="#1、不用二叉排序树、Hash、B树的分析" class="headerlink" title="1、不用二叉排序树、Hash、B树的分析"></a>1、不用二叉排序树、Hash、B树的分析</h3><ul><li><p>二叉排序树</p><ul><li>劣势：二叉排序树在极端情况下会有斜树，造成O(n)的时间复杂度</li></ul></li><li><p>Hash</p><ul><li>劣势：Hash是把索引数据进行Hash算法对应一个地址，我们会发现这个好像性能很好啊，直接找到，但是我们想想，它能满足我们日常开发大部分情况吗？比如通过大于或者小于去筛选数据，所以说也不合适，当然mysql还是提供了Hash索引，毕竟有些场合还是用起来也不错</li></ul></li><li><p>B树( 多路查找树 )</p><ul><li><p>概念:</p><ul><li>度(Degree)-节点的数据存储个数</li><li>叶节点具有相同的深度</li><li>叶节点的指针为空</li><li>节点中的数据key从左到右递增排列</li></ul></li><li><p>优势：二叉树存储的数据(海量数据可能来自文件，来自数据库)，不仅<strong>高度很高</strong>，而且每次查询，<strong>一个节点只有一个元素</strong>加载进内存，这样需要<strong>多次I/O</strong>操作，效率低下；而B树可以一次查询就有一个节点(数据库的话有一<strong>页</strong>节点)加载进内存，高度极大缩小，内存处理效率高又能减少I/O操作，查询效率高（为什么内存处理效率高？为什么要减少I/O操作？为什么是一页的数据？第二部分有讲解）</p><p>PS：一棵B 树的阶为1001 (即1 个结点包含1 000 个关键字) ，高度为2 ，它可以储存超过10 亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次I/O操作即可</p></li><li><p>不足：为什么不使用B树？因为一次I/O存入内存的<strong>节点数据</strong>会影响<strong>节点里面元素个数</strong>（存的容量有限，一页大小），而B+树解决这一问题</p></li><li><p>图解：</p><p> <img src="https://img2018.cnblogs.com/blog/1422817/201906/1422817-20190618113351277-845341592.png" alt="img"> </p></li><li><p>为什么不一开始节点是全部数据</p><p>因为内存与硬盘数据交互的单位是页，而一页是4K或8K，如果全部数据超过一页单位，就会有多次I/O操作，减低性能</p></li></ul></li></ul><h3 id="2、使用B-树的原因"><a href="#2、使用B-树的原因" class="headerlink" title="2、使用B+树的原因"></a>2、使用B+树的原因</h3><ul><li><p>概念：是B树的变形树</p><ul><li>非叶子节点不存储data，只存储key(索引值)，可以增大度</li><li>各个叶子节点的头和尾有指针连接，可以顺序访问，提高区间访问的性能</li></ul></li><li><p>优势：B+树非叶子节点存储的是索引值，这样一页的数据存储的个数比B树多，这样降低高度，从而查询次数也会减低、I/O操作次数减少，效率更高</p></li><li><p>图解：</p><p> <img src="https://img2018.cnblogs.com/blog/1422817/201906/1422817-20190618113402246-1099834253.png" alt="img"></p></li><li><p>B+Tree索引的性能分析</p><ul><li>一般使用磁盘I/O次数评价索引结构的优劣</li><li>预读：磁盘一般会顺序向后读取一定长度的数据(页的整数倍)放入内存</li><li>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用</li><li>B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次I/O</li><li>B+Tree的度d一般会超过100，因此h非常小(一般为3到5之间)</li></ul><h3 id="四、聚簇索引和非聚簇索引"><a href="#四、聚簇索引和非聚簇索引" class="headerlink" title="四、聚簇索引和非聚簇索引"></a>四、聚簇索引和非聚簇索引</h3></li></ul><ul><li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p></li><li><p>非聚簇索引：将数据存储与索引分开放置，找到索引就能找到数据的存储地址</p></li><li><p>MyISAM:</p><ul><li>主键索引数据结构</li></ul><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581586662878.png" alt="1581586662878"></p><ul><li><p>铺助索引数据结构</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210303225244849.png" alt="image-20210303225244849"></p></li></ul></li><li><p>InnoDB</p><ul><li><p>主键索引数据结构</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210303225319743.png" alt="image-20210303225319743"></p></li></ul><ul><li><p>铺助索引数据结构</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210303225327950.png" alt="image-20210303225327950"></p></li><li><p>问题？</p><ul><li><p>为什么非主键索引结构叶子节点存储的是主键值？</p><p>如果辅助索引叶子节点存数据的话，就会造成插入、修改、删除数据时，主键和辅助索引要维护两份数据，会造成<strong>数据一致性</strong>问题，同时也<strong>增大存储空间</strong></p></li><li><p>为什么InnoDB表必须有主键？</p><p>InnoDB的数据文件本身就是按B+Tree组织的一个索引结构文件。（没有创建主键，数据表也会找其中一列做数据，数据不重复，如果没有不重复，后台会默认创建主键，而且时整形的。）</p></li><li><p>为什么不用UUID而用自增的整形id？</p><ul><li>UUID比较使用ASCII比较字符，一个一个比较肯定比整数比较慢</li><li>UUID存储的空间比整形存储空间大</li><li>整形自增id，数据会插入到最后面的叶子节点的后面，而UUID数据插入的话，无法保证插入的位置，可能在数据的中间，因为节点度满了，节点就会分裂，可能会造成上面很多的节点分裂</li></ul></li><li><p>联合索引的底层存储结构长什么样？</p><p>联合索引和单个索引差不多，索引有多个字段。在查找时，先比较第一个字段，比不了就比较下一个，一次类推。这样就是最左前缀原理由来。</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210303225341671.png" alt="image-20210303225341671"></p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、什么是索引？&quot;&gt;&lt;a href=&quot;#一、什么是索引？&quot; cl
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://deschen.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>详解五种单例模式</title>
    <link href="http://deschen.com/2019/07/04/%E8%AF%A6%E8%A7%A3%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://deschen.com/2019/07/04/%E8%AF%A6%E8%A7%A3%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-07-04T00:33:57.000Z</published>
    <updated>2019-07-08T00:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解五种单例模式"><a href="#详解五种单例模式" class="headerlink" title="详解五种单例模式"></a>详解五种单例模式</h1><h2 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h2><p>单例模式，属于创建类型的一种常用的软件设计模式。定义是：一个类有且只有<strong>唯一</strong>一个实例，提供系统使用。</p><h2 id="二、单例模式应用的场景"><a href="#二、单例模式应用的场景" class="headerlink" title="二、单例模式应用的场景"></a>二、单例模式应用的场景</h2><ul><li>Web应用配置文件的读取，由于配置文件是共享资源，一般采用单例模式</li><li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li><li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。</li><li>…</li></ul><h2 id="三、单例模式的优缺点"><a href="#三、单例模式的优缺点" class="headerlink" title="三、单例模式的优缺点"></a>三、单例模式的优缺点</h2><ul><li>优点：节约资源以及提高资源的利用率，如果一个应用总是产生相同的实例，实例一多，就会导致系统内存不足，运行响应缓慢，甚至宕机</li><li>缺点： 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失</li></ul><h2 id="四、单例模式四种模式"><a href="#四、单例模式四种模式" class="headerlink" title="四、单例模式四种模式"></a>四、单例模式四种模式</h2><blockquote><p>单例模式三个主要特点：1、构造方法私有化；2、实例化的变量引用私有化；3、获取实例的方法共有。 </p></blockquote><h3 id="0、idea-多线程debug调试"><a href="#0、idea-多线程debug调试" class="headerlink" title="0、idea 多线程debug调试"></a>0、idea 多线程debug调试</h3><p>在接下来讲解中，使用多线程测试，因此如何使用idea 多线程debug是非常重要的，以懒汉模式为例</p><ul><li>打下断点，右键改为Thread，点击Done</li><li>点击运行debug按钮</li></ul><p><img src="https://img-blog.csdnimg.cn/20200115212559409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020011521263358.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200115212718650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200115212739872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1、懒汉模式"><a href="#1、懒汉模式" class="headerlink" title="1、懒汉模式"></a>1、懒汉模式</h3><blockquote><p>类初始化时不会立刻创建实例，而是当调用方法时创建</p><p>缺点：线程不安全，延迟初始化，严格意义上不是不是单例模式 ，因为可能创建多个实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断实例是否已创建</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread of creating instance: "</span> + Thread.currentThread().getName());</span><br><span class="line">            singleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            System.out.println(<span class="string">"Thread of instance: "</span> + singleton);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================测试======================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + LazySingleton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115212940983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、饿汉模式"><a href="#2、饿汉模式" class="headerlink" title="2、饿汉模式"></a>2、饿汉模式</h3><blockquote><p>类初始化时立刻创建实例，线程安全</p><p>缺点： 资源利用率不高，可能永远不被调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySinglenton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类初始化时就已经创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySinglenton singlenton = <span class="keyword">new</span> HungrySinglenton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySinglenton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类初始化就创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySinglenton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singlenton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========================测试===============================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + HungrySinglenton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213038439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3、双重检测锁"><a href="#3、双重检测锁" class="headerlink" title="3、双重检测锁"></a>3、双重检测锁</h3><blockquote><p>进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<strong>singleton</strong>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<strong>volatile</strong>修饰<strong>signleton</strong>实例变量有效，解决该问题。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用volatile 防止 类初始化重排*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLockSingleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLockSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否存在，避免不要的实例,不过多线程可以进入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="comment">// 使用synchronized，单线程通行，防止多线程进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread of passing the first lock："</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 再次判断是否存在，防止多线程创建，达到双重检测</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"thread of creating instance: "</span> + Thread.currentThread().getName());</span><br><span class="line">                    singleton = <span class="keyword">new</span> DoubleCheckLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================测试===========================================</span><br><span class="line"><span class="comment">// 使用多线程测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + DoubleCheckLockSingleton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115212826332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="测试结果\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0e3T32EH-1579094660038)(C:\Users\20423\AppData\Roaming\Typora\typora-user-images\1579064576184.png)\]"></p><h3 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h3><blockquote><p>只有<strong>第一次</strong>调用方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。 </p><p>缺点：无法传参，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类被调用创建实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticInner.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleton singleton = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==============================测试===================================</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    System.out.println(StaticInnerSingleton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213112109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5、枚举单例"><a href="#5、枚举单例" class="headerlink" title="5、枚举单例"></a>5、枚举单例</h3><blockquote><p>在介绍枚举单例前说下，上面四种单例模式有一个缺点：能通过反射机制调用私有的构造器，创建新的实例，破坏单例模式；而枚举单例就是能解决这一问题</p></blockquote><h4 id="5-1-反射攻击双重检查锁单例模式"><a href="#5-1-反射攻击双重检查锁单例模式" class="headerlink" title="5.1  反射攻击双重检查锁单例模式"></a>5.1  反射攻击双重检查锁单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用多线程测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        DoubleCheckLockSingleton singleton1 = DoubleCheckLockSingleton.getInstance();</span><br><span class="line">        Constructor&lt;DoubleCheckLockSingleton&gt; constructor =</span><br><span class="line">                            DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 设置访问权限</span></span><br><span class="line">        DoubleCheckLockSingleton singleton3 = constructor.newInstance();</span><br><span class="line">        System.out.println(singleton3 == singleton1);</span><br><span class="line">               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213146345.png" alt="在这里插入图片描述"></p><h4 id="5-2-如何防止反射破坏"><a href="#5-2-如何防止反射破坏" class="headerlink" title="5.2  如何防止反射破坏"></a>5.2  如何防止反射破坏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">在第四节第<span class="number">3</span>段的DoubleCheckLockSingleton类中的私有构造方法添加判断</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 防止多线程进入，会发布又没用同步代码库快的测试结果</span></span><br><span class="line">        <span class="keyword">synchronized</span>(DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                flag = !flag;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" come in"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式被侵犯！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">=============================测试================================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 非反射案例</span></span><br><span class="line">                DoubleCheckLockSingleton singleton1 = DoubleCheckLockSingleton.getInstance();</span><br><span class="line">                System.out.println(singleton1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread-1 "</span>).start();</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 反射</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Constructor&lt;DoubleCheckLockSingleton&gt; constructor =</span><br><span class="line">                            DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">                    constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 设置访问权限</span></span><br><span class="line">                    DoubleCheckLockSingleton singleton3 = constructor.newInstance();</span><br><span class="line">                    System.out.println(<span class="string">"反射创建实例是否为同一个："</span> + (singleton3 == singleton1));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread-3"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br>没有使用synchronized的结果<br><img src="https://img-blog.csdnimg.cn/20200115213445603.png" alt="在这里插入图片描述"><br>使用synchronized的结果<br><img src="https://img-blog.csdnimg.cn/20200115213514483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="5-3-枚举单例的出现"><a href="#5-3-枚举单例的出现" class="headerlink" title="5.3  枚举单例的出现"></a>5.3  枚举单例的出现</h4><blockquote><p>在jdk1.5后出现枚举实现单例模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    ENUM_SINGLETON,</span><br><span class="line">    ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ENUM_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================================测试============================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//四种单例多线程检测</span></span><br><span class="line"><span class="comment">//        multiThreadSingle();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射检测</span></span><br><span class="line"><span class="comment">//        invokeSingleton();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举检测</span></span><br><span class="line">        EnumSingleton singleton1=EnumSingleton.ENUM_SINGLETON;</span><br><span class="line">        EnumSingleton singleton2=EnumSingleton.ENUM_SINGLETON;</span><br><span class="line">        System.out.println(<span class="string">"非反射情况下是否为同一个实例："</span>+(singleton1==singleton2));</span><br><span class="line">        Constructor&lt;EnumSingleton&gt; constructor= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            constructor = EnumSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//其父类的构造器</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            EnumSingleton singleton3 = constructor.newInstance(<span class="string">"ENUM_SINGLETON"</span>, <span class="number">666</span>);</span><br><span class="line">            System.out.println(<span class="string">"反射情况下是否为单例："</span> + (singleton1==singleton3));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213537924.png" alt="在这里插入图片描述"></p><h4 id="5-4-枚举单例抵制反射分析"><a href="#5-4-枚举单例抵制反射分析" class="headerlink" title="5.4 枚举单例抵制反射分析"></a>5.4 枚举单例抵制反射分析</h4><ul><li><p>为什么使用<strong>getDeclaredConstructor(String.class,int.class)</strong>，而不是 <strong>getDeclaredConstructor()</strong>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========枚举Enum类，实际上就是Enum========</span></span><br><span class="line">    <span class="comment">// 所以反射调用父类构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Constructor</strong>类的<strong>newInstance</strong>方法源码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// =============================如果是枚举的话，反射失败====================================</span></span><br><span class="line">        <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM ) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;详解五种单例模式&quot;&gt;&lt;a href=&quot;#详解五种单例模式&quot; class=&quot;headerlink&quot; title=&quot;详解五种单例模式&quot;&gt;&lt;/a&gt;详解五种单例模式&lt;/h1&gt;&lt;h2 id=&quot;一、什么是单例模式&quot;&gt;&lt;a href=&quot;#一、什么是单例模式&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://deschen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://deschen.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入了解JVM--内存模型</title>
    <link href="http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-06-28T09:00:33.000Z</published>
    <updated>2021-03-04T14:57:31.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h2><ul><li>Jvm内存模型图</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210304212806496.png" alt="image-20210304212806496"></p><ul><li><p>线程私有</p><ul><li>程序计数器：记录虚拟机字节码的指令地址</li><li>虚拟机栈：每个方法执行时，都会创建一个栈帧，存储局部变量、操作数、动态链接、方法返回地址。方法从调用到执行完毕，对应栈帧在虚拟机栈入栈和出栈</li><li>本地方法栈：跟虚拟机栈类似，执行native方法</li></ul></li><li><p>线程共享</p><ul><li>堆：内存最大的区域，存储java对象</li><li>方法区：存储已被虚拟机加载的类信息、常量、静态变量等</li></ul></li><li><p>Java堆的划分</p><ul><li>新生代（1:3）:存放新生的对象<ul><li>Eden(8:10)</li><li>From Survivor(1:10)</li><li>To Survivor(1:10)</li><li>过程：eden区存放新建对象。而当eden区内存不够时，就会触发垃圾回收，将其与from survivor区的存活对象，复制to survivor区，然后to survivor区变成from survivor区。每经过一次垃圾回收，对象年龄+1，当超过默认15次时，会复制到老年代</li></ul></li><li>老年代(2:3)<ul><li>过程：老年代存放生命周期长的对象。而当老年代内存不够时，会触发full gc，比gc慢10倍左右。当时在装不下时，报出out of memory异常</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jvm内存模型&quot;&gt;&lt;a href=&quot;#jvm内存模型&quot; class=&quot;headerlink&quot; title=&quot;jvm内存模型&quot;&gt;&lt;/a&gt;jvm内存模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Jvm内存模型图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://des
      
    
    </summary>
    
    
      <category term="Java" scheme="http://deschen.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://deschen.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis--解决Redis缓存穿透、雪崩、击穿问题</title>
    <link href="http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E8%A7%A3%E5%86%B3Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E8%A7%A3%E5%86%B3Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</id>
    <published>2019-06-28T06:25:33.000Z</published>
    <updated>2020-02-12T07:05:18.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题"><a href="#深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题" class="headerlink" title="深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题"></a>深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题</h1><h2 id="一、缓存穿透"><a href="#一、缓存穿透" class="headerlink" title="一、缓存穿透"></a>一、缓存穿透</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>缓存穿透就是访问一个不存在的数据时，缓存没有命中，而访问数据库，在高并发情况下，数据库又因为压力而宕机</p><h3 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>布隆过滤器</p><ul><li>简介：布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li><li>原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。</li><li>优点：相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。而且它不存储元素本身，在某些对保密要求非常严格的场合有优势。</li><li>缺点：一定的误识别率和删除困难。<br>结合以上几点及去重需求（容忍误判，会误判在，在则丢，无妨），决定使用BlomFilter。</li></ul><h2 id="二、缓存雪崩"><a href="#二、缓存雪崩" class="headerlink" title="二、缓存雪崩"></a>二、缓存雪崩</h2><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> 在缓存时设置相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，数据库瞬时压力过重雪崩。 </p><h3 id="2、解决方案-1"><a href="#2、解决方案-1" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="三、缓存击穿"><a href="#三、缓存击穿" class="headerlink" title="三、缓存击穿"></a>三、缓存击穿</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>某个数据设置过期时间，而该数据是被高并发访问的热点数据，一旦过期，可能就会造成缓存被击穿的可能</p><h3 id="2、解决方案-2"><a href="#2、解决方案-2" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><ul><li><p>使用互斥锁解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;  </span><br><span class="line">      String value = redis.get(key);  </span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期  </span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db  </span></span><br><span class="line">          <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功  </span></span><br><span class="line">               value = db.get(key);  </span><br><span class="line">               redis.set(key, value, expire_secs);  </span><br><span class="line">               redis.del(key_mutex);  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可  </span></span><br><span class="line">                      sleep(<span class="number">50</span>);  </span><br><span class="line">                      get(key);  <span class="comment">//重试  </span></span><br><span class="line">              &#125;  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              <span class="keyword">return</span> value;        </span><br><span class="line">          &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>将该数据不设置过期时间，就不会造成缓存击穿问题</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题&quot;&gt;&lt;a href=&quot;#深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题&quot; class=&quot;headerlink&quot; title=&quot;深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Java" scheme="http://deschen.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://deschen.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语法基础</title>
    <link href="http://deschen.com/2019/06/13/MySQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://deschen.com/2019/06/13/MySQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2019-06-13T10:21:45.000Z</published>
    <updated>2021-03-03T06:38:57.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL语法基础"><a href="#MySQL语法基础" class="headerlink" title="MySQL语法基础"></a>MySQL语法基础</h1><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/Sql%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.png" alt="Sql语言基础" style="zoom: 25%;" /><blockquote><p>思维导图 </p><p>链接：<a href="https://pan.baidu.com/s/1whN2oiWZrklR8MCCFUCMSg" target="_blank" rel="noopener">https://pan.baidu.com/s/1whN2oiWZrklR8MCCFUCMSg</a><br>提取码：6666 </p></blockquote><h1 id="MySQL知识图谱"><a href="#MySQL知识图谱" class="headerlink" title="MySQL知识图谱"></a>MySQL知识图谱</h1><h2 id="Sql语言基础"><a href="#Sql语言基础" class="headerlink" title="Sql语言基础"></a>Sql语言基础</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>CREATE TABLE mytable (<br> id INT NOT NULL AUTO_INCREMENT,<br> col1 INT NOT NULL DEFAULT 1,<br> col2 VARCHAR(45) NULL,<br> col3 DATE NULL,<br> PRIMARY KEY (<code>id</code>));</p><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ul><li><p>添加列</p><p>ALTER TABLE mytable<br>ADD col CHAR(20);</p></li><li><p>删除列</p><p>ALTER TABLE mytable<br>DROP COLUMN col;</p></li><li><p>删除表</p><p>DROP TABLE mytable;</p></li></ul><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ul><li><p>普通插入</p><p>INSERT INTO mytable(col1, col2)<br>VALUES(val1, val2);</p></li><li><p>查询内容插入</p><p>INSERT INTO mytable1(col1, col2)<br>SELECT col1, col2<br>FROM mytable2;</p></li><li><p>表内容插入</p><p>CREATE TABLE newtable AS<br>SELECT * FROM mytable;</p></li></ul><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>UPDATE mytable<br>SET col = val<br>WHERE id = 1;</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li><p>DELETE</p><p>DELETE FROM mytable<br>WHERE id = 1;</p></li><li><p>TRUNCATE</p><p>TRUNCATE TABLE mytable;</p></li><li><p>DELETE与TRUNCATE区别</p><p>表和索引所占空间。当表被truncate 后，这个表和索引所占用的空间会恢复到初始bai大小，delete操作不会减少表或索引所占用的空间。<br>delete要通过事务提交生效，而truncate立即生效，不会回滚，在没有备份情况下，谨慎用truncate<br>delete 语句每次删除一行，并在事务日志中为所删除的每行记录一项。truncate table 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p></li></ul><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><ul><li><p>DISTINCT</p><p>标识所选列的唯一性<br>SELECT DISTINCT col1, col2<br>FROM mytable;</p></li><li><p>LIMIT</p><p>限制返回的行数，有两个参数，第一个参数表示起始行，可选填，默认从0开始；第二个表示返回的总行数<br>SELECT *<br>FROM mytable<br>LIMIT 5;<br>等同于<br>SELECT *<br>FROM mytable<br>LIMIT 0, 5;</p></li><li><p>ASC / DESC</p><p>ASC : 升序(默认)<br>DESC : 降序<br>可选择多个列排序，且不同排序方式<br>SELECT *<br>FROM mytable<br>ORDER BY col1 DESC, col2 ASC;</p></li><li><p>通配符</p><p>用于过滤语句中，只能用于文本字段<br>% 匹配 &gt;=0 个任意字符<br>_ 匹配 ==1 个任意字符；<br>SELECT *<br>FROM mytable<br>WHERE col1 = “col1%”;<br>注意点：通用符尽量用在后面。因为写在前面，就会全表扫描，影响查询效率</p></li><li><p>计算字段</p><ul><li><p>简单计算</p><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量<br>计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。</p><pre><code>SELECT col1 * col2 AS aliasFROM mytable;</code></pre><p>CONCAT() 用于连接两个字段，许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。</p><pre><code>SELECT CONCAT(TRIM(col1), &apos;(&apos;, TRIM(col2), &apos;)&apos;) AS         concat_colFROM mytable;</code></pre></li><li><p>函数</p><ul><li><p>汇总</p><p>函数说明：<br>AVG() 返回某列的平均值<br>COUNT() 返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>注意点：<br>AVG() 会忽略 NULL 行。<br>使用DISTINCT，先根据DISTINCT的列找到对应数据，在计算平均值</p><pre><code>SELECT AVG(DISTINCT col1) AS avg_colFROM mytable;</code></pre></li><li><p>日期和时间处理</p><p>日期格式: YYYY-MM-DD<br>时间格式: HH:MM:SS<br>函 数 说 明<br>AddDate() 增加一个日期(天、周等)<br>AddTime() 增加一个时间(时、分等)<br>CurDate() 返回当前日期<br>CurTime() 返回当前时间<br>Date() 返回日期时间的日期部分<br>DateDiff() 计算两个日期之差<br>Date_Add() 高度灵活的日期运算函数<br>Date_Format() 返回一个格式化的日期或时间串<br>Day() 返回一个日期的天数部分<br>DayOfWeek() 对于一个日期，返回对应的星期几<br>Hour() 返回一个时间的小时部分<br>Minute() 返回一个时间的分钟部分<br>Month() 返回一个日期的月份部分<br>Now() 返回当前日期和时间<br>Second() 返回一个时间的秒部分<br>Time() 返回一个日期时间的时间部分<br>Year() 返回一个日期的年份部分</p><pre><code>SELECT NOW();</code></pre></li><li><p>文本处理</p><p>函数说明：<br>SIN()  正弦<br>COS()  余弦<br>TAN()  正切<br>ABS()  绝对值<br>SQRT()  平方根<br>MOD()  余数<br>EXP()  指数<br>PI()  圆周率<br>’RAND()  随机数</p></li></ul></li></ul></li><li><p>WHERE</p><p>条件查询<br>操作符说明：<br>= 等于<br>&lt; 小于</p><p>大于<br>!= 不等于<br>&lt;= 小于等于<br>= 大于等于<br>BETWEEN在两个值之间<br>IS NULL为 NULL 值<br>注意点：<br>AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。<br>IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。<br>NOT 操作符用于否定一个条件</p><pre><code>SELECT *FROM mytableWHERE col1 = &quot;col1&quot;;</code></pre></li><li><p>分组</p><p>具有相同数据值的行划为一组<br>常与汇总函数处理使用，如求分组数据的平均值等</p><pre><code>SELECT col, COUNT(*) AS numFROM mytableGROUP BY col;</code></pre><p>结合ORDER BY排序</p><pre><code>SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num;</code></pre><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><pre><code> SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING num &gt;= 2;</code></pre><p>注意点：<br>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；<br>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；<br>NULL 的行会单独分为一组；</p></li><li><p>子查询</p><p>子查询中只能返回一个字段的数据。<br>可以将子查询的结果作为 WHRER 语句的过滤条件:</p><pre><code>SELECT *FROM mytable1WHERE col1 IN (SELECT col2    FROM mytable2);</code></pre><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次:</p><pre><code>SELECT cust_name, (SELECT COUNT(*)     FROM Orders      WHERE Orders.cust_id = Customers.cust_id)      AS orders_numFROM CustomersORDER BY cust_name;</code></pre></li><li><p>JOIN</p><ul><li>左链接</li><li>内链接</li><li>右链接</li><li>左独有</li><li>全连接</li><li>右独有</li><li>并集去交集</li></ul></li><li><p>UNION</p><p>使用 UNION 来组合两个查询，每个查询必须包含相同的列、表达式和聚集函数<br>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。<br>只能包含一个 ORDER BY 子句，并且必须位于语句的最后</p><pre><code>SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2ORDER BY col;</code></pre></li><li><p>视图</p><p>视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的</p><pre><code>CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_colFROM mytableWHERE col5 = val;</code></pre></li><li><p>存储过程</p><p>存储过程可以看成是对一系列 SQL 操作的批处理。<br>使用存储过程的好处:<br>代码封装，保证了一定的安全性；<br>代码复用；<br>由于是预先编译，因此具有很高的性能。</p></li><li><p>事务管理</p><p>事务(transaction)指一组 SQL 语句；<br>回退(rollback)指撤销指定 SQL 语句的过程；<br>提交(commit)指将未存储的 SQL 语句结果写入数据库表；<br>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。<br>START TRANSACTION<br>// …<br>SAVEPOINT delete1<br>// …<br>ROLLBACK TO delete1<br>// …<br>COMMIT</p></li><li><p>事务管理</p><p>事务(transaction)指一组 SQL 语句；<br>回退(rollback)指撤销指定 SQL 语句的过程；<br>提交(commit)指将未存储的 SQL 语句结果写入数据库表；<br>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。<br>START TRANSACTION<br>// …<br>SAVEPOINT delete1<br>// …<br>ROLLBACK TO delete1<br>// …<br>COMMIT</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL语法基础&quot;&gt;&lt;a href=&quot;#MySQL语法基础&quot; class=&quot;headerlink&quot; title=&quot;MySQL语法基础&quot;&gt;&lt;/a&gt;MySQL语法基础&lt;/h1&gt;&lt;img src=&quot;https://deschen-storage.oss-cn-guan
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://deschen.com/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
