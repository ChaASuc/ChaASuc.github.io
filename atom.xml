<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈汉槟的博客</title>
  
  <subtitle>以Java开发为主的个人博客，记录自己在学习、工作和成长的笔记和心得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://deschen.com/"/>
  <updated>2020-01-31T06:44:01.786Z</updated>
  <id>http://deschen.com/</id>
  
  <author>
    <name>陈汉槟</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发编程--java内存模型</title>
    <link href="http://deschen.com/2020/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://deschen.com/2020/01/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-01-31T06:44:01.000Z</published>
    <updated>2020-01-31T06:44:01.786Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>并发编程--线程和线程池</title>
    <link href="http://deschen.com/2020/01/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://deschen.com/2020/01/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-01-29T02:58:29.000Z</published>
    <updated>2020-01-30T16:45:09.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程–线程池和多线程"><a href="#并发编程–线程池和多线程" class="headerlink" title="并发编程–线程池和多线程"></a>并发编程–线程池和多线程</h1><p>[toc]</p><h2 id="一、什么是线程和进程"><a href="#一、什么是线程和进程" class="headerlink" title="一、什么是线程和进程"></a>一、什么是线程和进程</h2><h4 id="什么是进程？什么是线程？"><a href="#什么是进程？什么是线程？" class="headerlink" title="什么是进程？什么是线程？"></a>什么是进程？什么是线程？</h4><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p><p>进程可以看成程序执行的一个实例。进程是系统资源分配的独立实体，每个进程都拥有独立的地址空间。一个进程无法访问另一个进程的变量和数据结构，如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如管道，文件，套接字等。</p><p>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间。线程与进程的一个主要区别是，统一进程内的一个主要区别是，同一进程内的多个线程会共享部分状态，多个线程可以读写同一块内存（一个进程无法直接访问另一进程的内存）。同时，每个线程还拥有自己的寄存器和栈，其他线程可以读写这些栈内存。</p><p>线程是进程的一个实体，是进程的一条执行路径。</p><p>线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。</p><h4 id="进程和线程的区别体现在以下几个方面："><a href="#进程和线程的区别体现在以下几个方面：" class="headerlink" title="进程和线程的区别体现在以下几个方面："></a>进程和线程的区别体现在以下几个方面：</h4><p>1.地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其他进程内不可见。</p><p>2.通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间可以直接独写进程数据段（如全局变量）来进程通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p><p>3.调度和切换：线程上下文切换比进程上下文切换快得多。</p><p>4.在多线程OS中，进程不是一个可执行的实体。</p><h4 id="进程和线程的选择取决以下几点："><a href="#进程和线程的选择取决以下几点：" class="headerlink" title="进程和线程的选择取决以下几点："></a>进程和线程的选择取决以下几点：</h4><p>1.需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程的代价是很大的。</p><p>2.线程的切换速度快，所以在需要大量计算，切换频繁时使用线程，还有耗时的操作时用使用线程可提高应用程序的响应。</p><p>3.因为对CPU系统的效率使用上线程更占优势，所以可能要发展到多机分布的用进程，多核分布用线程。</p><p>4.并行操作时用线程，如C/S架构的服务器端并发线程响应用户的请求。</p><p>5.需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。</p><h2 id="二、多线程排查死锁命令和操作"><a href="#二、多线程排查死锁命令和操作" class="headerlink" title="二、多线程排查死锁命令和操作"></a>二、多线程排查死锁命令和操作</h2><p> <a href="https://blog.csdn.net/u014039577/article/details/52351626" target="_blank" rel="noopener">https://blog.csdn.net/u014039577/article/details/52351626</a> </p><p>​        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发编程–线程池和多线程&quot;&gt;&lt;a href=&quot;#并发编程–线程池和多线程&quot; class=&quot;headerlink&quot; title=&quot;并发编程–线程池和多线程&quot;&gt;&lt;/a&gt;并发编程–线程池和多线程&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、什么是线程和进程&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>深入理解Redis--集群部署</title>
    <link href="http://deschen.com/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://deschen.com/2019/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</id>
    <published>2019-08-01T02:25:06.000Z</published>
    <updated>2019-08-04T03:34:27.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Redis–集群部署"><a href="#深入理解Redis–集群部署" class="headerlink" title="深入理解Redis–集群部署"></a>深入理解Redis–集群部署</h1><h2 id="一、启动集群"><a href="#一、启动集群" class="headerlink" title="一、启动集群"></a>一、启动集群</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8001/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8002/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8003/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8004/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8005/</span>redis.conf</span><br><span class="line"></span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/redis-5.0.2/</span>src<span class="regexp">/redis-server /u</span>sr<span class="regexp">/local/</span>redis-cluster<span class="regexp">/8006/</span>redis.conf</span><br></pre></td></tr></table></figure><p># 客户端连接8001端口的redis实例</p><figure class="highlight plain"><figcaption><span>-a deschen -c -h 192.168.0.61 -p 8001````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\# 查看集群状态</span><br><span class="line"></span><br><span class="line">192.168.0.61:8001&gt; cluster nodes</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;01&#x2F;clip_image002.gif)</span><br><span class="line"></span><br><span class="line">从上图可以看出，整个集群运行正常，三个master节点和三个slave节点，8001端口的实例节点存储0-5460这些hash槽，8002端口的实例节点存储5461-10922这些hash槽，8003端口的实例节点存储10923-16383这些hash槽，这三个master节点存储的所有hash槽组成redis集群的存储槽位，slave点是每个主节点的备份从节点，不显示存储槽位  </span><br><span class="line"></span><br><span class="line">## 二、集群操作</span><br><span class="line"></span><br><span class="line">我们在原始集群基础上再增加一主(8007)一从(8008)，增加节点后的集群参见下图，新增节点用虚线框表示</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;01&#x2F;clip_image004.gif)</span><br><span class="line"></span><br><span class="line">### 1、增加redis实例</span><br><span class="line"></span><br><span class="line">在&#x2F;usr&#x2F;local&#x2F;redis-cluster下创建8007和8008文件夹，并拷贝8001文件夹下的redis.conf文件到8007和8008这两个文件夹下</span><br></pre></td></tr></table></figure><p>mkdir 8008</p><p>mkdir 8008</p><p>cd 8001</p><p>cp redis.conf /usr/local/redis-cluster/8007/</p><p>cp redis.conf /usr/local/redis-cluster/8008/</p><p>修改8007文件夹下的redis.conf配置文件</p><p>vim /usr/local/redis-cluster/8007/redis.conf</p><p>修改如下内容：</p><p>port:8007</p><p>dir /usr/local/redis-cluster/8007/</p><p>cluster-config-file nodes-8007.conf</p><p>修改8008文件夹下的redis.conf配置文件</p><p>vim /usr/local/redis-cluster/8008/redis.conf</p><p>修改内容如下：</p><p>port:8008</p><p>dir /usr/local/redis-cluster/8008/</p><p>cluster-config-file nodes8008.conf</p><p>启动8007和8008俩个服务并查看服务状态</p><p> /usr/local/redis-5.0.2/src/redis-server /usr/local/redis-cluster/8007/redis.conf</p><p> /usr/local/redis-5.0.2/src/redis-server /usr/local/redis-cluster/8008/redis.conf</p><p> ps -el | grep redis</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### <span class="number">2</span>、查看redis集群的命令帮助</span><br></pre></td></tr></table></figure><p>cd /usr/local/redis-5.0.2</p><p>src/redis-cli –cluster help</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">clipboard.png</span>](<span class="link">https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image006.gif</span>)</span><br></pre></td></tr></table></figure><p>1、create：创建一个集群环境host1:port1 … hostN:portN</p><p>2、call：可以执行redis命令</p><p>3、add-node：将一个节点添加到集群里，第一个参数为新节点的ip:port，第二个参数为集群中任意一个已经存在的节点的ip:port </p><p>4、del-node：移除一个节点</p><p>5、reshard：重新分片</p><p>6、check：检查集群状态</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">### 3、 配置8007为集群主节点</span></span><br><span class="line"></span><br><span class="line">使用<span class="code">```</span><span class="code">`add-node`</span><span class="code">```</span>命令新增一个主节点8007(master)，绿色为新增节点，红色为已知存在节点，看到日志最后有<span class="code">```</span><span class="code">`"[OK] New node added correctly"`</span><span class="code">```</span>提示代表新节点加入成功</span><br><span class="line"></span><br><span class="line"><span class="code">```</span><span class="code">`/usr/local/redis-5.0.2/src/redis-cli --cluster add-node 192.168.0.64:8007 192.168.0.61:8001`</span><span class="code">```</span> </span><br><span class="line"></span><br><span class="line">查看集群状态</span><br><span class="line"></span><br><span class="line">![<span class="string">clipboard.png</span>](<span class="link">https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image008.gif</span>)</span><br><span class="line"></span><br><span class="line">注意：当添加节点成功以后，新增的节点不会有任何数据，因为它还没有分配任何的slot(hash槽)，我们需要为新节点手工分配hash槽 </span><br><span class="line"></span><br><span class="line">使用redis-cli命令为8007分配hash槽，找到集群中的任意一个主节点(红色位置表示集群中的任意一个主节点)，对其进行重新分片工作。</span><br><span class="line"></span><br><span class="line"><span class="code">```</span>`/usr/local/redis-5.0.2/src/redis-cli --cluster reshard 192.168.0.61:8001</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输出如下：</span><br><span class="line"></span><br><span class="line">How many slots <span class="keyword">do</span> you want <span class="keyword">to</span> move (<span class="keyword">from</span> 1 <span class="keyword">to</span> 16384)? 600</span><br><span class="line"></span><br><span class="line">(ps:需要多少个槽移动到新的节点上，自己设置，比如600个hash槽)</span><br><span class="line"></span><br><span class="line">What is the receiving node ID? eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</span><br><span class="line"></span><br><span class="line">(ps:把这600个hash槽移动到哪个节点上去，需要指定节点id)</span><br><span class="line"></span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line"></span><br><span class="line"><span class="built_in"> Type </span><span class="string">'all'</span> <span class="keyword">to</span> use all the nodes as source nodes <span class="keyword">for</span> the hash slots.</span><br><span class="line"></span><br><span class="line"><span class="built_in"> Type </span><span class="string">'done'</span> once you entered all the source nodes IDs.</span><br><span class="line"></span><br><span class="line">Source node 1:all</span><br><span class="line"></span><br><span class="line">(ps:输入all为从所有主节点(8001,8002,8003)中分别抽取相应的槽数指定到新节点中，抽取的总槽数为600个)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> proceed with the proposed reshard plan (<span class="literal">yes</span>/<span class="literal">no</span>)? <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">(ps:输入<span class="literal">yes</span>确认开始执行分片任务)</span><br></pre></td></tr></table></figure><p>查看下最新的集群状态</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image010.gif" alt="clipboard.png"></p><p>如上图所示，现在我们的8007已经有hash槽了，也就是说可以在8007上进行读写数据啦！到此为止我们的8007已经加入到集群中，并且是主节点(Master)</p><h3 id="4、配置8008为8007的从节点"><a href="#4、配置8008为8007的从节点" class="headerlink" title="4、配置8008为8007的从节点"></a>4、配置8008为8007的从节点</h3><p>添加从节点8008到集群中去并查看集群状态</p><figure class="highlight plain"><figcaption><span>--cluster add-node 192.168.0.64:8008 192.168.0.61:8001````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![clipboard.png](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;01&#x2F;clip_image012.gif)</span><br><span class="line"></span><br><span class="line">如图所示，还是一个master节点，没有被分配任何的hash槽。</span><br><span class="line"></span><br><span class="line">我们需要执行replicate命令来指定当前节点(从节点)的主节点id为哪个,首先需要连接新加的8008节点的客户端，然后使用集群命令进行操作，把当前的8008(slave)节点指定到一个主节点下(这里使用之前创建的8007主节点，红色表示节点id)</span><br></pre></td></tr></table></figure><p>/usr/local/redis-5.0.2/src/redis-cli -c -h 192.168.0.64 -p 8008</p><p>192.168.0.61:8008&gt; cluster replicate eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\# 查看集群状态，<span class="number">8008</span>节点已成功添加为<span class="number">8007</span>节点的从节点</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:<span class="comment">//root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image014.gif)</span></span><br><span class="line"></span><br><span class="line">### <span class="number">5</span>、删除<span class="number">8008</span>从节点</span><br><span class="line"></span><br><span class="line">用del-node删除从节点<span class="number">8008</span>，指定删除节点ip和端口，以及节点id(红色为<span class="number">8008</span>节点id)</span><br><span class="line"></span><br><span class="line">````/usr/local/redis<span class="number">-5.0</span><span class="number">.2</span>/src/redis-cli --cluster del-node <span class="number">192.168</span><span class="number">.0</span><span class="number">.64</span>:<span class="number">8008</span> <span class="number">1805</span>b6339d91b0e051f46845eebacb9bc43baefe</span><br></pre></td></tr></table></figure><p>再次查看集群状态，如下图所示，8008这个slave节点已经移除，并且该节点的redis服务也已被停止</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image016.gif" alt="clipboard.png"></p><h3 id="6、删除8007主节点"><a href="#6、删除8007主节点" class="headerlink" title="6、删除8007主节点"></a>6、删除8007主节点</h3><p>最后，我们尝试删除之前加入的主节点8007，这个步骤相对比较麻烦一些，因为主节点的里面是有分配了hash槽的，所以我们这里必须先把8007里的hash槽放入到其他的可用主节点中去，然后再进行移除节点操作，不然会出现数据丢失问题(目前只能把master的数据迁移到一个节点上，暂时做不了平均分配功能)，执行命令如下：</p><figure class="highlight plain"><figcaption><span>--cluster reshard 192.168.0.64:8007````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出如下：</span><br></pre></td></tr></table></figure><p>How many slots do you want to move (from 1 to 16384)? 600</p><p>What is the receiving node ID? deedad3c34e8437baa6ff013fd3d1461a0c2e761</p><p>(ps:这里是需要把数据移动到哪？8001的主节点id)</p><p>Please enter all the source node IDs.</p><p> Type ‘all’ to use all the nodes as source nodes for the hash slots.</p><p> Type ‘done’ once you entered all the source nodes IDs.</p><p>Source node 1:eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</p><p>(ps:这里是需要数据源，也就是我们的8007节点id)</p><p>Source node 2:done</p><p>(ps:这里直接输入done 开始生成迁移计划)</p><p>Do you want to proceed with the proposed reshard plan (yes/no)? Yes</p><p>(ps:这里输入yes开始迁移)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">至此，我们已经成功的把<span class="number">8007</span>主节点的数据迁移到<span class="number">8001</span>上去了，我们可以看一下现在的集群状态如下图，你会发现<span class="number">8007</span>下面已经没有任何hash槽了，证明迁移成功！</span><br><span class="line"></span><br><span class="line">![clipboard.png](https:<span class="comment">//root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image018.gif)</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">最后我们直接使用del-node命令删除<span class="number">8007</span>主节点即可（红色表示<span class="number">8007</span>的节点id）。</span><br><span class="line"></span><br><span class="line">````/usr/local/redis<span class="number">-5.0</span><span class="number">.2</span>/src/redis-cli --cluster del-node <span class="number">192.168</span><span class="number">.0</span><span class="number">.64</span>:<span class="number">8007</span>  eb57a5700ee6f9ff099b3ce0d03b1a50ff247c3c</span><br></pre></td></tr></table></figure><p># 查看集群状态，一切还原为最初始状态啦！大功告成！</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image020.gif" alt="clipboard.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Redis–集群部署&quot;&gt;&lt;a href=&quot;#深入理解Redis–集群部署&quot; class=&quot;headerlink&quot; title=&quot;深入理解Redis–集群部署&quot;&gt;&lt;/a&gt;深入理解Redis–集群部署&lt;/h1&gt;&lt;h2 id=&quot;一、启动集群&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://deschen.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="http://deschen.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis--集群讲解</title>
    <link href="http://deschen.com/2019/07/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E8%AE%B2%E8%A7%A3/"/>
    <id>http://deschen.com/2019/07/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E9%9B%86%E7%BE%A4%E8%AE%B2%E8%A7%A3/</id>
    <published>2019-07-20T00:41:38.000Z</published>
    <updated>2019-07-23T02:51:22.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis集群详解"><a href="#Redis集群详解" class="headerlink" title="Redis集群详解"></a>Redis集群详解</h1><h2 id="一、Redis有三种集群模式"><a href="#一、Redis有三种集群模式" class="headerlink" title="一、Redis有三种集群模式"></a>一、Redis有三种集群模式</h2><ul><li>主从模式</li><li>Sentinel模式( 哨兵模式 )</li><li>Cluster模式( 集群模式 )</li></ul><p>PS ：集群查看命令： <code>info replication</code> </p><h2 id="二、主从模式"><a href="#二、主从模式" class="headerlink" title="二、主从模式"></a>二、主从模式</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>主从模式是三种模式中最简单的，在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)。</p><h3 id="2、工作机制："><a href="#2、工作机制：" class="headerlink" title="2、工作机制："></a>2、工作机制：</h3><p>当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。</p><h3 id="3、优缺点"><a href="#3、优缺点" class="headerlink" title="3、优缺点"></a>3、优缺点</h3><ul><li>优点：<ul><li>1、高可靠性，主从实时备份，有效解决单节点数据丢失问题。</li><li>2、可做读写分离，从库分担读操作，缓解主库压力</li></ul></li><li>缺点：主库异常，需要手动主从切换</li></ul><h2 id="三、Sentinel模式"><a href="#三、Sentinel模式" class="headerlink" title="三、Sentinel模式"></a>三、Sentinel模式</h2><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> 监控redis集群的运行状况 </p><h3 id="2、工作机制：-1"><a href="#2、工作机制：-1" class="headerlink" title="2、工作机制："></a>2、工作机制：</h3><ul><li><p>假设主节点宕机，第一个哨兵先检测到这个结果，第一个哨兵主标志为<strong>主观下线</strong>。</p></li><li><p>当后面的哨兵也检测到主节点为<strong>主观下线</strong>，并且数量达到一定值时，就会标志为<strong>客观下线</strong></p></li><li><p>在认为主节点<strong>客观下线</strong>的情况下,哨兵节点节点间会发起一次选举，如果超过半数以上的节点返回，则将该节点标记为leader的情况下，对<strong>故障的主节点</strong>所属的<strong>从节点中</strong>选取<strong>新的主节点</strong></p><p>当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的ip和port，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。 </p></li></ul><h3 id="3、优缺点-1"><a href="#3、优缺点-1" class="headerlink" title="3、优缺点"></a>3、优缺点</h3><ul><li>优点：有效解决主从模式主库异常手动主从切换的问题</li><li>缺点：运维复杂，哨兵选举期间，不能对外提供服务</li></ul><h2 id="四、Cluster模式"><a href="#四、Cluster模式" class="headerlink" title="四、Cluster模式"></a>四、Cluster模式</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。  </p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581473766762.png" alt="1581473766762"></p><h3 id="3、槽位"><a href="#3、槽位" class="headerlink" title="3、槽位"></a>3、槽位</h3><p>Redis Cluster 将所有数据划分为 <strong>16384</strong> 的 slots( 槽位 ）</p><p>当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p><h3 id="4、槽位定位算法"><a href="#4、槽位定位算法" class="headerlink" title="4、槽位定位算法"></a>4、槽位定位算法</h3><p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。</p><p>HASH_SLOT = CRC16(key) mod 16384</p><h3 id="5、跳转重定位"><a href="#5、跳转重定位" class="headerlink" title="5、跳转重定位"></a>5、跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581474165999.png" alt="1581474165999"></p><h3 id="6、网络抖动"><a href="#6、网络抖动" class="headerlink" title="6、网络抖动"></a>6、网络抖动</h3><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。</p><p>为解决这种问题，Redis Cluster 提供了一种选项cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p><h3 id="7、选举原理分析"><a href="#7、选举原理分析" class="headerlink" title="7、选举原理分析"></a>7、选举原理分析</h3><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p><p>1.slave发现自己的master变为FAIL</p><p>2.将自己记录的集群cluster_current_epoch(选举周期)加1( 查看命令：<code>cluster info</code>)，并广播FAILOVER_AUTH_REQUEST 信息</p><p>3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p><p>4.尝试failover的slave收集FAILOVER_AUTH_ACK</p><p>5.超过半数后变成新Master</p><p>6.广播通知其他集群节点。</p><p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p><p>延迟计算公式：</p><p> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p><p>•SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis集群详解&quot;&gt;&lt;a href=&quot;#Redis集群详解&quot; class=&quot;headerlink&quot; title=&quot;Redis集群详解&quot;&gt;&lt;/a&gt;Redis集群详解&lt;/h1&gt;&lt;h2 id=&quot;一、Redis有三种集群模式&quot;&gt;&lt;a href=&quot;#一、Redis有三种集
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://deschen.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="http://deschen.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引深入理解</title>
    <link href="http://deschen.com/2019/07/13/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://deschen.com/2019/07/13/MySQL%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2019-07-13T10:21:45.000Z</published>
    <updated>2019-07-14T10:23:15.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>[toc]</p><h2 id="一、什么是索引？"><a href="#一、什么是索引？" class="headerlink" title="一、什么是索引？"></a>一、什么是索引？</h2><p>索引是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></p><h2 id="二、底层知识铺垫-–-计算机组成原理"><a href="#二、底层知识铺垫-–-计算机组成原理" class="headerlink" title="二、底层知识铺垫 – 计算机组成原理"></a>二、底层知识铺垫 – 计算机组成原理</h2><blockquote><p>有没想过1、索引的数据结构为什么不是二叉排序树、红黑树、Hash、B树？而是B+树？2、为什么索引能是排好序的？</p><p>这些需要计算机组成原理的知识才能解决！希望大伙认真看，踊跃发言，互相学习</p></blockquote><h3 id="1、磁盘的读取原理"><a href="#1、磁盘的读取原理" class="headerlink" title="1、磁盘的读取原理"></a>1、磁盘的读取原理</h3><ul><li><p>索引存储在文件中，也就是说，查询索引就需要磁盘I/O操作，而磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。 </p></li><li><p>磁盘的机械运动是怎么样子的？时间消耗多大？</p><ul><li><p>磁盘结构图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTgvMTM1MDU0NjY2N184NjI4LmpwZw?x-oss-process=image/format,png" alt="img"> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctbXkuY3Nkbi5uZXQvdXBsb2Fkcy8yMDEyMTAvMTgvMTM1MDU0NjY3MF84ODI5LmpwZw?x-oss-process=image/format,png" alt="img"></p></li><li><p>概念：</p><ul><li><strong>磁道</strong>：以盘片中心为圆心，用不同的半径，划分出不同的很窄的圆环形区域，称为磁道</li><li><strong>扇区</strong>：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区.扇区是磁盘最小的物理存储单元</li><li><strong>柱面</strong>：上下一串盘片中，相同半径的磁道所组成的一个圆柱型的环壁，就称为柱面</li></ul></li><li><p>磁盘读取时间计算：</p><ul><li><strong>寻道时间</strong>：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快。主流磁盘一般在5ms以下；</li><li><strong>旋转延迟</strong>：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。比如： 一个 7200（转 / 每分钟）的硬盘，平均旋转延迟时间为 1 ÷ ( 7200 ÷ 60 ) ÷ 2＝4.17ms（最多旋转１圈，最少不用旋转，平均情况下，需要旋转半圈）。 </li><li><strong>数据传输时间</strong>：完成传输所请求的数据所需要的时间。一般在零点几毫秒，相对于前两个时间可以忽略不计。</li><li>可见，磁盘I/O时间取决于寻道时间和旋转延迟</li></ul></li></ul></li></ul><h3 id="2、内存的读取原理"><a href="#2、内存的读取原理" class="headerlink" title="2、内存的读取原理"></a>2、内存的读取原理</h3><ul><li><p>内存的地址：计算机使用的主存基本都是随机读写存储器（RAM），内存可以抽象概括为一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元由行和列构成唯一的地址。 </p></li><li><p>内存读取原理：当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。由图可见，内存的读取时间仅与读取的次数呈线性关系，无机械操作，查询时间短、效率高</p><p><img src="http://blog.codinglabs.org/uploads/pictures/theory-of-mysql-index/5.png" alt="img"> </p></li></ul><h3 id="3、-从内存读取到磁盘预读"><a href="#3、-从内存读取到磁盘预读" class="headerlink" title="3、 从内存读取到磁盘预读"></a>3、 <strong>从内存读取到磁盘预读</strong></h3><ul><li>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：  *<em>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。 *</em>  </li><li>另一个原因： 由于磁盘顺序读取的效率很高（<strong>不需要寻道时间</strong>，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 </li><li>预读的长度一般为<strong>页（page）的整倍数</strong>。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），<strong>主存和磁盘以页为单位交换数据</strong>。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</li></ul><h2 id="三、索引的数据结构"><a href="#三、索引的数据结构" class="headerlink" title="三、索引的数据结构"></a>三、索引的数据结构</h2><blockquote><p>第二部分主要用于B+树上,页的概念和预读十分重要,方便下面理解</p></blockquote><h3 id="1、不用二叉排序树、Hash、B树的分析"><a href="#1、不用二叉排序树、Hash、B树的分析" class="headerlink" title="1、不用二叉排序树、Hash、B树的分析"></a>1、不用二叉排序树、Hash、B树的分析</h3><ul><li><p>二叉排序树</p><ul><li>劣势：二叉排序树在极端情况下会有斜树，造成O(n)的时间复杂度</li></ul></li><li><p>Hash</p><ul><li>劣势：Hash是把索引数据进行Hash算法对应一个地址，我们会发现这个好像性能很好啊，直接找到，但是我们想想，它能满足我们日常开发大部分情况吗？比如通过大于或者小于去筛选数据，所以说也不合适，当然mysql还是提供了Hash索引，毕竟有些场合还是用起来也不错</li></ul></li><li><p>B树( 多路查找树 )</p><ul><li><p>概念:</p><ul><li>度(Degree)-节点的数据存储个数</li><li>叶节点具有相同的深度</li><li>叶节点的指针为空</li><li>节点中的数据key从左到右递增排列</li></ul></li><li><p>优势：二叉树存储的数据(海量数据可能来自文件，来自数据库)，不仅<strong>高度很高</strong>，而且每次查询，<strong>一个节点只有一个元素</strong>加载进内存，这样需要<strong>多次I/O</strong>操作，效率低下；而B树可以一次查询就有一个节点(数据库的话有一<strong>页</strong>节点)加载进内存，高度极大缩小，内存处理效率高又能减少I/O操作，查询效率高（为什么内存处理效率高？为什么要减少I/O操作？为什么是一页的数据？第二部分有讲解）</p><p>PS：一棵B 树的阶为1001 (即1 个结点包含1 000 个关键字) ，高度为2 ，它可以储存超过10 亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次I/O操作即可</p></li><li><p>不足：为什么不使用B树？因为一次I/O存入内存的<strong>节点数据</strong>会影响<strong>节点里面元素个数</strong>（存的容量有限，一页大小），而B+树解决这一问题</p></li><li><p>图解：</p><p> <img src="https://img2018.cnblogs.com/blog/1422817/201906/1422817-20190618113351277-845341592.png" alt="img"> </p></li><li><p>为什么不一开始节点是全部数据</p><p>因为内存与硬盘数据交互的单位是页，而一页是4K或8K，如果全部数据超过一页单位，就会有多次I/O操作，减低性能</p></li></ul></li></ul><h3 id="2、使用B-树的原因"><a href="#2、使用B-树的原因" class="headerlink" title="2、使用B+树的原因"></a>2、使用B+树的原因</h3><ul><li><p>概念：是B树的变形树</p><ul><li>非叶子节点不存储data，只存储key(索引值)，可以增大度</li><li>各个叶子节点的头和尾有指针连接，可以顺序访问，提高区间访问的性能</li></ul></li><li><p>优势：B+树非叶子节点存储的是索引值，这样一页的数据存储的个数比B树多，这样降低高度，从而查询次数也会减低、I/O操作次数减少，效率更高</p></li><li><p>图解：</p><p> <img src="https://img2018.cnblogs.com/blog/1422817/201906/1422817-20190618113402246-1099834253.png" alt="img"></p></li><li><p>B+Tree索引的性能分析</p><ul><li>一般使用磁盘I/O次数评价索引结构的优劣</li><li>预读：磁盘一般会顺序向后读取一定长度的数据(页的整数倍)放入内存</li><li>局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用</li><li>B+Tree节点的大小设为等于一个页，每次新建节点直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，就实现了一个节点的载入只需一次I/O</li><li>B+Tree的度d一般会超过100，因此h非常小(一般为3到5之间)</li></ul><h3 id="四、聚簇索引和非聚簇索引"><a href="#四、聚簇索引和非聚簇索引" class="headerlink" title="四、聚簇索引和非聚簇索引"></a>四、聚簇索引和非聚簇索引</h3></li></ul><ul><li><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</p></li><li><p>非聚簇索引：将数据存储与索引分开放置，找到索引就能找到数据的存储地址</p></li><li><p>MyISAM:</p><ul><li>主键索引数据结构</li></ul><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581586662878.png" alt="1581586662878"></p><ul><li><p>铺助索引数据结构</p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581586736313.png" alt="1581586736313"></p></li></ul></li><li><p>InnoDB</p><ul><li><p>主键索引数据结构</p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581586774007.png" alt="1581586774007"></p></li></ul><ul><li><p>铺助索引数据结构</p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581586792540.png" alt="1581586792540"></p></li><li><p>问题？</p><ul><li><p>为什么非主键索引结构叶子节点存储的是主键值？</p><p>如果辅助索引叶子节点存数据的话，就会造成插入、修改、删除数据时，主键和辅助索引要维护两份数据，会造成<strong>数据一致性</strong>问题，同时也<strong>增大存储空间</strong></p></li><li><p>为什么InnoDB表必须有主键？</p><p>InnoDB的数据文件本身就是按B+Tree组织的一个索引结构文件。（没有创建主键，数据表也会找其中一列做数据，数据不重复，如果没有不重复，后台会默认创建主键，而且时整形的。）</p></li><li><p>为什么不用UUID而用自增的整形id？</p><ul><li>UUID比较使用ASCII比较字符，一个一个比较肯定比整数比较慢</li><li>UUID存储的空间比整形存储空间大</li><li>整形自增id，数据会插入到最后面的叶子节点的后面，而UUID数据插入的话，无法保证插入的位置，可能在数据的中间，因为节点度满了，节点就会分裂，可能会造成上面很多的节点分裂</li></ul></li><li><p>联合索引的底层存储结构长什么样？</p><p>联合索引和单个索引差不多，索引有多个字段。在查找时，先比较第一个字段，比不了就比较下一个，一次类推。这样就是最左前缀原理由来。</p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1581588401436.png" alt="1581588401436"></p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL索引&quot;&gt;&lt;a href=&quot;#MySQL索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引&quot;&gt;&lt;/a&gt;MySQL索引&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、什么是索引？&quot;&gt;&lt;a href=&quot;#一、什么是索引？&quot; cl
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://deschen.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>详解五种单例模式</title>
    <link href="http://deschen.com/2019/07/04/%E8%AF%A6%E8%A7%A3%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://deschen.com/2019/07/04/%E8%AF%A6%E8%A7%A3%E4%BA%94%E7%A7%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-07-04T00:33:57.000Z</published>
    <updated>2019-07-08T00:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解五种单例模式"><a href="#详解五种单例模式" class="headerlink" title="详解五种单例模式"></a>详解五种单例模式</h1><h2 id="一、什么是单例模式"><a href="#一、什么是单例模式" class="headerlink" title="一、什么是单例模式"></a>一、什么是单例模式</h2><p>单例模式，属于创建类型的一种常用的软件设计模式。定义是：一个类有且只有<strong>唯一</strong>一个实例，提供系统使用。</p><h2 id="二、单例模式应用的场景"><a href="#二、单例模式应用的场景" class="headerlink" title="二、单例模式应用的场景"></a>二、单例模式应用的场景</h2><ul><li>Web应用配置文件的读取，由于配置文件是共享资源，一般采用单例模式</li><li>网站的计数器，一般也是采用单例模式实现，否则难以同步。</li><li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。</li><li>…</li></ul><h2 id="三、单例模式的优缺点"><a href="#三、单例模式的优缺点" class="headerlink" title="三、单例模式的优缺点"></a>三、单例模式的优缺点</h2><ul><li>优点：节约资源以及提高资源的利用率，如果一个应用总是产生相同的实例，实例一多，就会导致系统内存不足，运行响应缓慢，甚至宕机</li><li>缺点： 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失</li></ul><h2 id="四、单例模式四种模式"><a href="#四、单例模式四种模式" class="headerlink" title="四、单例模式四种模式"></a>四、单例模式四种模式</h2><blockquote><p>单例模式三个主要特点：1、构造方法私有化；2、实例化的变量引用私有化；3、获取实例的方法共有。 </p></blockquote><h3 id="0、idea-多线程debug调试"><a href="#0、idea-多线程debug调试" class="headerlink" title="0、idea 多线程debug调试"></a>0、idea 多线程debug调试</h3><p>在接下来讲解中，使用多线程测试，因此如何使用idea 多线程debug是非常重要的，以懒汉模式为例</p><ul><li>打下断点，右键改为Thread，点击Done</li><li>点击运行debug按钮</li></ul><p><img src="https://img-blog.csdnimg.cn/20200115212559409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020011521263358.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200115212718650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200115212739872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="1、懒汉模式"><a href="#1、懒汉模式" class="headerlink" title="1、懒汉模式"></a>1、懒汉模式</h3><blockquote><p>类初始化时不会立刻创建实例，而是当调用方法时创建</p><p>缺点：线程不安全，延迟初始化，严格意义上不是不是单例模式 ，因为可能创建多个实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断实例是否已创建</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread of creating instance: "</span> + Thread.currentThread().getName());</span><br><span class="line">            singleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            System.out.println(<span class="string">"Thread of instance: "</span> + singleton);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================测试======================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + LazySingleton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115212940983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、饿汉模式"><a href="#2、饿汉模式" class="headerlink" title="2、饿汉模式"></a>2、饿汉模式</h3><blockquote><p>类初始化时立刻创建实例，线程安全</p><p>缺点： 资源利用率不高，可能永远不被调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySinglenton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类初始化时就已经创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySinglenton singlenton = <span class="keyword">new</span> HungrySinglenton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySinglenton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类初始化就创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySinglenton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singlenton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==========================测试===============================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + HungrySinglenton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213038439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3、双重检测锁"><a href="#3、双重检测锁" class="headerlink" title="3、双重检测锁"></a>3、双重检测锁</h3><blockquote><p>进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<strong>singleton</strong>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<strong>volatile</strong>修饰<strong>signleton</strong>实例变量有效，解决该问题。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用volatile 防止 类初始化重排*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLockSingleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLockSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否存在，避免不要的实例,不过多线程可以进入</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">            <span class="comment">// 使用synchronized，单线程通行，防止多线程进入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread of passing the first lock："</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 再次判断是否存在，防止多线程创建，达到双重检测</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == singleton) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"thread of creating instance: "</span> + Thread.currentThread().getName());</span><br><span class="line">                    singleton = <span class="keyword">new</span> DoubleCheckLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">==============================测试===========================================</span><br><span class="line"><span class="comment">// 使用多线程测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + DoubleCheckLockSingleton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115212826332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="测试结果\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0e3T32EH-1579094660038)(C:\Users\20423\AppData\Roaming\Typora\typora-user-images\1579064576184.png)\]"></p><h3 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h3><blockquote><p>只有<strong>第一次</strong>调用方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。 </p><p>缺点：无法传参，由于是静态内部类的形式去创建单例的，故外部无法传递参数进去 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类被调用创建实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticInner.singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerSingleton singleton = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==============================测试===================================</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    System.out.println(StaticInnerSingleton.getInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"thread "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213112109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5、枚举单例"><a href="#5、枚举单例" class="headerlink" title="5、枚举单例"></a>5、枚举单例</h3><blockquote><p>在介绍枚举单例前说下，上面四种单例模式有一个缺点：能通过反射机制调用私有的构造器，创建新的实例，破坏单例模式；而枚举单例就是能解决这一问题</p></blockquote><h4 id="5-1-反射攻击双重检查锁单例模式"><a href="#5-1-反射攻击双重检查锁单例模式" class="headerlink" title="5.1  反射攻击双重检查锁单例模式"></a>5.1  反射攻击双重检查锁单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用多线程测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        DoubleCheckLockSingleton singleton1 = DoubleCheckLockSingleton.getInstance();</span><br><span class="line">        Constructor&lt;DoubleCheckLockSingleton&gt; constructor =</span><br><span class="line">                            DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 设置访问权限</span></span><br><span class="line">        DoubleCheckLockSingleton singleton3 = constructor.newInstance();</span><br><span class="line">        System.out.println(singleton3 == singleton1);</span><br><span class="line">               </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213146345.png" alt="在这里插入图片描述"></p><h4 id="5-2-如何防止反射破坏"><a href="#5-2-如何防止反射破坏" class="headerlink" title="5.2  如何防止反射破坏"></a>5.2  如何防止反射破坏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">在第四节第<span class="number">3</span>段的DoubleCheckLockSingleton类中的私有构造方法添加判断</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckLockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 防止多线程进入，会发布又没用同步代码库快的测试结果</span></span><br><span class="line">        <span class="keyword">synchronized</span>(DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="keyword">false</span>) &#123;</span><br><span class="line">                flag = !flag;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" come in"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例模式被侵犯！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">=============================测试================================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 非反射案例</span></span><br><span class="line">                DoubleCheckLockSingleton singleton1 = DoubleCheckLockSingleton.getInstance();</span><br><span class="line">                System.out.println(singleton1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread-1 "</span>).start();</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 反射</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Constructor&lt;DoubleCheckLockSingleton&gt; constructor =</span><br><span class="line">                            DoubleCheckLockSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">null</span>)</span>;</span><br><span class="line">                    constructor.setAccessible(<span class="keyword">true</span>);  <span class="comment">// 设置访问权限</span></span><br><span class="line">                    DoubleCheckLockSingleton singleton3 = constructor.newInstance();</span><br><span class="line">                    System.out.println(<span class="string">"反射创建实例是否为同一个："</span> + (singleton3 == singleton1));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread-3"</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果<br>没有使用synchronized的结果<br><img src="https://img-blog.csdnimg.cn/20200115213445603.png" alt="在这里插入图片描述"><br>使用synchronized的结果<br><img src="https://img-blog.csdnimg.cn/20200115213514483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="5-3-枚举单例的出现"><a href="#5-3-枚举单例的出现" class="headerlink" title="5.3  枚举单例的出现"></a>5.3  枚举单例的出现</h4><blockquote><p>在jdk1.5后出现枚举实现单例模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    ENUM_SINGLETON,</span><br><span class="line">    ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ENUM_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=================================测试============================================</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//四种单例多线程检测</span></span><br><span class="line"><span class="comment">//        multiThreadSingle();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射检测</span></span><br><span class="line"><span class="comment">//        invokeSingleton();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举检测</span></span><br><span class="line">        EnumSingleton singleton1=EnumSingleton.ENUM_SINGLETON;</span><br><span class="line">        EnumSingleton singleton2=EnumSingleton.ENUM_SINGLETON;</span><br><span class="line">        System.out.println(<span class="string">"非反射情况下是否为同一个实例："</span>+(singleton1==singleton2));</span><br><span class="line">        Constructor&lt;EnumSingleton&gt; constructor= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            constructor = EnumSingleton<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;<span class="comment">//其父类的构造器</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            EnumSingleton singleton3 = constructor.newInstance(<span class="string">"ENUM_SINGLETON"</span>, <span class="number">666</span>);</span><br><span class="line">            System.out.println(<span class="string">"反射情况下是否为单例："</span> + (singleton1==singleton3));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试结果<br><img src="https://img-blog.csdnimg.cn/20200115213537924.png" alt="在这里插入图片描述"></p><h4 id="5-4-枚举单例抵制反射分析"><a href="#5-4-枚举单例抵制反射分析" class="headerlink" title="5.4 枚举单例抵制反射分析"></a>5.4 枚举单例抵制反射分析</h4><ul><li><p>为什么使用<strong>getDeclaredConstructor(String.class,int.class)</strong>，而不是 <strong>getDeclaredConstructor()</strong>?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==========枚举Enum类，实际上就是Enum========</span></span><br><span class="line">    <span class="comment">// 所以反射调用父类构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Constructor</strong>类的<strong>newInstance</strong>方法源码中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Constructor</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">                checkAccess(caller, clazz, <span class="keyword">null</span>, modifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// =============================如果是枚举的话，反射失败====================================</span></span><br><span class="line">        <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM ) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;详解五种单例模式&quot;&gt;&lt;a href=&quot;#详解五种单例模式&quot; class=&quot;headerlink&quot; title=&quot;详解五种单例模式&quot;&gt;&lt;/a&gt;详解五种单例模式&lt;/h1&gt;&lt;h2 id=&quot;一、什么是单例模式&quot;&gt;&lt;a href=&quot;#一、什么是单例模式&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://deschen.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://deschen.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深入了解JVM--内存模型</title>
    <link href="http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-06-28T09:00:33.000Z</published>
    <updated>2020-01-28T09:03:41.957Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java" scheme="http://deschen.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://deschen.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis--解决Redis缓存穿透、雪崩、击穿问题</title>
    <link href="http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E8%A7%A3%E5%86%B3Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/"/>
    <id>http://deschen.com/2019/06/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redis-%E8%A7%A3%E5%86%B3Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98/</id>
    <published>2019-06-28T06:25:33.000Z</published>
    <updated>2020-02-12T07:05:18.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题"><a href="#深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题" class="headerlink" title="深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题"></a>深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题</h1><h2 id="一、缓存穿透"><a href="#一、缓存穿透" class="headerlink" title="一、缓存穿透"></a>一、缓存穿透</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>缓存穿透就是访问一个不存在的数据时，缓存没有命中，而访问数据库，在高并发情况下，数据库又因为压力而宕机</p><h3 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>布隆过滤器</p><ul><li>简介：布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</li><li>原理：当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。</li><li>优点：相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。而且它不存储元素本身，在某些对保密要求非常严格的场合有优势。</li><li>缺点：一定的误识别率和删除困难。<br>结合以上几点及去重需求（容忍误判，会误判在，在则丢，无妨），决定使用BlomFilter。</li></ul><h2 id="二、缓存雪崩"><a href="#二、缓存雪崩" class="headerlink" title="二、缓存雪崩"></a>二、缓存雪崩</h2><h3 id="1、介绍-1"><a href="#1、介绍-1" class="headerlink" title="1、介绍"></a>1、介绍</h3><p> 在缓存时设置相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，数据库瞬时压力过重雪崩。 </p><h3 id="2、解决方案-1"><a href="#2、解决方案-1" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><p>缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h2 id="三、缓存击穿"><a href="#三、缓存击穿" class="headerlink" title="三、缓存击穿"></a>三、缓存击穿</h2><h3 id="1、介绍-2"><a href="#1、介绍-2" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>某个数据设置过期时间，而该数据是被高并发访问的热点数据，一旦过期，可能就会造成缓存被击穿的可能</p><h3 id="2、解决方案-2"><a href="#2、解决方案-2" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><ul><li><p>使用互斥锁解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(key)</span> </span>&#123;  </span><br><span class="line">      String value = redis.get(key);  </span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//代表缓存值过期  </span></span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db  </span></span><br><span class="line">          <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  <span class="comment">//代表设置成功  </span></span><br><span class="line">               value = db.get(key);  </span><br><span class="line">               redis.set(key, value, expire_secs);  </span><br><span class="line">               redis.del(key_mutex);  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可  </span></span><br><span class="line">                      sleep(<span class="number">50</span>);  </span><br><span class="line">                      get(key);  <span class="comment">//重试  </span></span><br><span class="line">              &#125;  </span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              <span class="keyword">return</span> value;        </span><br><span class="line">          &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>将该数据不设置过期时间，就不会造成缓存击穿问题</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题&quot;&gt;&lt;a href=&quot;#深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题&quot; class=&quot;headerlink&quot; title=&quot;深入理解Redis–解决Redis缓存穿透、雪崩、击穿问题&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Java" scheme="http://deschen.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://deschen.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入了解Redis--Redis核心原理</title>
    <link href="http://deschen.com/2019/06/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis-Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>http://deschen.com/2019/06/12/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Redis-Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2019-06-12T06:24:12.000Z</published>
    <updated>2019-06-21T00:58:45.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入了解Redis–Redis核心原理"><a href="#深入了解Redis–Redis核心原理" class="headerlink" title="深入了解Redis–Redis核心原理"></a>深入了解Redis–Redis核心原理</h1><h2 id="一、Redis的单线程和高性能"><a href="#一、Redis的单线程和高性能" class="headerlink" title="一、Redis的单线程和高性能"></a>一、Redis的单线程和高性能</h2><h3 id="1、Redis-单线程为什么还能这么快？"><a href="#1、Redis-单线程为什么还能这么快？" class="headerlink" title="1、Redis 单线程为什么还能这么快？"></a>1、Redis 单线程为什么还能这么快？</h3><p>因为它所有的数据都在内存中，所有的运算都是<strong>内存级别的运算</strong>( 一个常规的命令，set/get操作，时间是<strong>纳秒</strong>级别的，redis理想情况下<strong>QPS为10W/s</strong>)，而且单线程<strong>避免了多线程的切换性能损耗</strong>问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。 </p><h3 id="2、Redis单线程如何处理那么多的并发客户端连接？"><a href="#2、Redis单线程如何处理那么多的并发客户端连接？" class="headerlink" title="2、Redis单线程如何处理那么多的并发客户端连接？"></a>2、Redis单线程如何处理那么多的并发客户端连接？</h3><p>Redis的<strong>IO多路复用</strong>：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1581431818149.png" alt="1581431818149"></p><h2 id="二、Redis持久化"><a href="#二、Redis持久化" class="headerlink" title="二、Redis持久化"></a>二、Redis持久化</h2><h3 id="1、RDB快照（snapshot）"><a href="#1、RDB快照（snapshot）" class="headerlink" title="1、RDB快照（snapshot）"></a>1、RDB快照（snapshot）</h3><p>在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。</p><p>你可以对 Redis  进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。</p><p>比如说， 以下设置会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集：</p><figure class="highlight plain"><figcaption><span>60 1000````</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">默认设置</span><br><span class="line"></span><br><span class="line"> ![1581432750276](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;1581432750276.png)</span><br><span class="line"></span><br><span class="line">### 2、AOF（append-only file）</span><br><span class="line"></span><br><span class="line">快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将修改的每一条指令记录进文件</span><br><span class="line"></span><br><span class="line">你可以通过修改配置文件来打开 AOF 功能：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96; appendonly yes</span><br></pre></td></tr></table></figure><p>从现在开始， 每当 Redis 执行一个改变数据集的命令时（比如 <a href="http://redisdoc.com/string/set.html#set" target="_blank" rel="noopener">SET</a>）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><p>你可以配置 Redis 多久才将数据 fsync (<strong>持久化</strong>)到磁盘一次。</p><p>有三个选项：</p><ol><li>`````appendfsync always````每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</li><li><code>appendfsync everysec</code>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。</li><li><code>appendfsync no</code> 从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择。</li></ol><p>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><figure class="highlight plain"><figcaption><span>appendonly.aof````查看aof文件内容，文件内容存储使用[Redis协议规范(RESP)](https://www.cnblogs.com/tommy-huang/p/6051577.html)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3、RDB 和 AOF ，我应该用哪一个？</span><br><span class="line"></span><br><span class="line"> 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</span><br><span class="line"></span><br><span class="line">&gt; 你们可能有这么一个疑问？可以把RDB的快照时间设为每秒，可是实际上，每次快照，就要把整个内存数据快照，一般企业的Redis都是GB级别，这样花时间就，效率低下</span><br><span class="line"></span><br><span class="line">有很多用户都只使用 AOF 持久化， 但并不推荐这种方式，因为如果aof文件非常大，如果有几个GB的话，Redis重启的话，Redis执行aof文件里面的命令，启动慢，效率低</span><br><span class="line"></span><br><span class="line">那么如何选择呢？就是接下来要讲的</span><br><span class="line"></span><br><span class="line">### 4、Redis 4.0 混合持久化</span><br><span class="line"></span><br><span class="line">重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。</span><br><span class="line"></span><br><span class="line">**AOF在重写**(aof文件里可能有太多没用指令，所以aof会定期根据内存的最新数据生成aof文件)**时将重写这一刻把内存进行rdb快照和增加修改内存数据的命令追加aof文件( aof文件是新的aof文件 )末尾，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换；**</span><br><span class="line"></span><br><span class="line">AOF根据配置规则在后台自动重写，也可以人为执行命令**bgrewriteaof**重写AOF。 于是在 Redis 重启的时候，可以**先加载 rdb 的内容**，然后再**重放增量 AOF 日志**就可以完全**替代**之前的 **AOF 全量文件重放**，重启效率因此大幅得到提升。</span><br><span class="line"></span><br><span class="line">开启混合持久化：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;aof-use-rdb-preamble yes&#96;&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">配置：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;auto-aof-rewrite-percentage 100&#96;&#96;&#96;&#96;：当容量一翻倍，aof就会重写</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;auto-aof-rewrite-min-size 64mb&#96;&#96;&#96;&#96;：当容量超过64M时，才会执行上一条指令翻倍重写</span><br><span class="line"></span><br><span class="line">混合持久化aof文件结构</span><br><span class="line"></span><br><span class="line">![1581434824790](https:&#x2F;&#x2F;root-1258715043.cos.ap-guangzhou.myqcloud.com&#x2F;blog&#x2F;1581434824790.png)</span><br><span class="line"></span><br><span class="line">​                                </span><br><span class="line"></span><br><span class="line">### 三、缓存淘汰策略</span><br><span class="line"></span><br><span class="line">当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)。交换会让 Redis 的性能急剧下降，对于访问量比较频繁的 Redis 来说，这样龟速的存取效率基本上等于不可用。</span><br><span class="line"></span><br><span class="line">在生产环境中我们是不允许 Redis 出现交换行为的，为了限制最大使用内存，Redis 提供了配置参数 maxmemory 来限制内存超出期望大小。 </span><br><span class="line"></span><br><span class="line">当实际内存超出 maxmemory 时，Redis 提供了几种可选策略 (maxmemory-policy) 来让用户自己决定该如何腾出新的空间以继续提供读写服务。</span><br><span class="line"></span><br><span class="line">  选择策略 &#96;&#96;&#96;&#96;maxmemory-policy XXXX</span><br></pre></td></tr></table></figure><p><strong>noeviction</strong> 不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略。</p><p><strong>volatile-lru</strong>  在设置了过期时间的所有键中，选取最近最少使用的数据抛弃。 </p><p><strong>volatile-ttl</strong>  在设置了过期时间的所有键，抛弃存活时间最短的数据。 </p><p><strong>volatile-random</strong>   在设置了过期时间的所有键，随机抛弃。 </p><p><strong>allkeys-lru</strong>  在所有键中，选取最近最少使用的数据抛弃。 </p><p><strong>allkeys-random</strong>  在所有键中，随机抛弃。 </p><p>volatile-xxx 策略只会针对带过期时间的 key 进行淘汰，allkeys-xxx 策略会对所有的 key 进行淘汰。如果你只是拿 Redis 做缓存，那应该使用 allkeys-xxx，客户端写缓存时不必携带过期时间。如果你还想同时使用 Redis 的持久化功能，那就使用 volatile-xxx 策略，这样可以保留没有设置过期时间的 key，它们是永久的 key 不会被 LRU 算法淘汰。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入了解Redis–Redis核心原理&quot;&gt;&lt;a href=&quot;#深入了解Redis–Redis核心原理&quot; class=&quot;headerlink&quot; title=&quot;深入了解Redis–Redis核心原理&quot;&gt;&lt;/a&gt;深入了解Redis–Redis核心原理&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://deschen.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="http://deschen.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Redis--Redis基本介绍</title>
    <link href="http://deschen.com/2019/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redi--Redis%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <id>http://deschen.com/2019/06/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redi--Redis%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</id>
    <published>2019-06-10T13:48:47.000Z</published>
    <updated>2019-06-12T03:34:58.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解Redis–Redis基本介绍"><a href="#深入理解Redis–Redis基本介绍" class="headerlink" title="深入理解Redis–Redis基本介绍"></a>深入理解Redis–Redis基本介绍</h1><h2 id="一、Redis简介"><a href="#一、Redis简介" class="headerlink" title="一、Redis简介"></a>一、Redis简介</h2><p>redis 简介<br> <strong>Redis</strong>是一个基于<strong>内存</strong>的高性能<strong>key-value</strong>数据库，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h2 id="二、Redis与Mecache区别"><a href="#二、Redis与Mecache区别" class="headerlink" title="二、Redis与Mecache区别"></a>二、Redis与Mecache区别</h2><ol><li>持久性<ul><li>Redis可以将内存中的数据保持在<strong>磁盘</strong>中，<strong>重启</strong>的时候可以<strong>再次加载</strong>进行使用，保证数据的持久性</li><li>Memecache把数据全部存在<strong>内存</strong>之中，<strong>断电后会挂掉</strong>，数据不能超过内存大小。</li></ul></li><li>数据类型<ul><li>Redis支持的数据类型要丰富得多,Redis不仅仅支持简单的<strong>k/v</strong>类型的数据，同时还提供<strong>String，List,Set,Hash,Sorted Set</strong>数据结构的存储。</li><li>memcache支持<strong>简单数据类型</strong>，需要客户端自己处理复杂对象 </li></ul></li><li>存储键值大小<ul><li>Redis单个value的最大限制是<strong>1GB</strong></li><li>memcached只能保存<strong>1MB</strong>的数据 </li></ul></li></ol><h2 id="三、Redis基本数据类型"><a href="#三、Redis基本数据类型" class="headerlink" title="三、Redis基本数据类型"></a>三、Redis基本数据类型</h2><ol><li><p>String</p><p>字符串 string 是 Redis 最简单的数据结构。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。字符串结构使用非常广泛，一个常见的用途就是<strong>缓存用户信息</strong>。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程    </p></li><li><p>list</p><p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p><p>Redis 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p></li><li><p>hash</p><p>Redis 的字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的<strong>数组 + 链表</strong>二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对 用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。 hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p></li><li><p>set</p><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值NULL。 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。 </p></li><li><p>zset</p><p>zset 似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。</p><p>zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。 </p><p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。</p></li></ol><h2 id="四、Redis命令注意点"><a href="#四、Redis命令注意点" class="headerlink" title="四、Redis命令注意点"></a>四、Redis命令注意点</h2><p>尽量不要使用<strong>keys</strong>作为模糊查询redis中的键，而是使用<strong>scan</strong>。</p><p>理由：</p><ol><li>因为Redis是单线程，如果Redis的key有1000W的话，使用keys模糊查询查询的时间<strong>很高</strong>，线程<strong>阻塞</strong>，其他线程命令就无法执行，降低性能。</li><li>使用scan<strong>，通过<code>scan 0 match &lt;关键字&gt; count &lt;数量&gt;</code>，能够</strong>根据关键字<strong>获取</strong>规定数量<strong>的</strong>键值**。可以多次使用该命令迭代获取全部数据，每次命令执行时间短，不会过多的阻塞其他线程</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解Redis–Redis基本介绍&quot;&gt;&lt;a href=&quot;#深入理解Redis–Redis基本介绍&quot; class=&quot;headerlink&quot; title=&quot;深入理解Redis–Redis基本介绍&quot;&gt;&lt;/a&gt;深入理解Redis–Redis基本介绍&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://deschen.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Redis" scheme="http://deschen.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux常见命令</title>
    <link href="http://deschen.com/2019/05/28/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://deschen.com/2019/05/28/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2019-05-28T06:25:33.000Z</published>
    <updated>2019-05-30T06:38:37.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux常见命令"><a href="#Linux常见命令" class="headerlink" title="Linux常见命令"></a>Linux常见命令</h1><h2 id="一、-bash-XX-command-not-found解决"><a href="#一、-bash-XX-command-not-found解决" class="headerlink" title="一、-bash: XX: command not found解决"></a>一、-bash: XX: command not found解决</h2><ul><li>yum -y install XX</li></ul><h2 id="二、文件及其文件夹命令"><a href="#二、文件及其文件夹命令" class="headerlink" title="二、文件及其文件夹命令"></a>二、文件及其文件夹命令</h2><ul><li><p>创建目录  mkdir [选项] 目录</p><ul><li><p>无 建立单个目录</p></li><li><p>-m, –mode=MODE    建立目录时同时设置目录的权限。 </p></li><li><p>-p, –parents      建立多级目录 </p></li><li><p>-v, –verbose     显示执行命令的信息</p></li></ul></li><li><p>删除目录、文件 rm [选项] 目录</p><ul><li>-f, –force     强制删除文件或目录 </li><li>-r, -R, –recursive  删除目录及其子目录</li><li>-d, –dir    删除空文件夹</li><li>-v, –verbose     显示执行命令的信息</li></ul></li><li><p>例子</p><ul><li><p>创建<strong>t01文件</strong>  mkdir t01</p></li><li><p>创建<strong>多级目录</strong> mkdir -p t02/t03</p></li><li><p><strong>创建并显示</strong>执行信息  mkdir -pv t04/t05</p></li><li><p>删除<strong>多级目录</strong> rm -rf t02/t03</p></li></ul></li></ul><h2 id="三、解压文件命令"><a href="#三、解压文件命令" class="headerlink" title="三、解压文件命令"></a>三、解压文件命令</h2><ul><li><p>解压、压缩文件 tar[选项1] 文件  [选项2] [目录]</p><ul><li><p>选项1（必选）</p><ul><li>-A 新增压缩文件到已存在的压缩</li><li>-B 设置区块大小</li><li>-c 建立新的压缩文件</li><li>-d 记录文件的差别</li><li>-r 添加文件到已经压缩的文件</li><li>-u 添加改变了和现有的文件到已经存在的压缩文件</li><li>-x 从压缩的文件中提取文件</li><li>-t 显示压缩文件的内容</li><li>-z 支持gzip解压文件</li><li>-j 支持bzip2解压文件</li><li>-Z 支持compress解压文件</li><li>-v 显示操作过程</li><li>-l 文件系统边界设置</li><li>-k 保留原有文件不覆盖</li><li>-m 保留文件不被覆盖</li><li>-W 确认压缩文件的正确性</li></ul></li><li><p>选项2 （可选）</p><ul><li>-b 设置区块数目</li><li>-C 切换到指定目录</li><li>-f 指定压缩文件</li><li>–help 显示帮助信息</li><li>–version 显示版本信息</li></ul></li></ul></li><li><p>例子</p><ul><li>解压<strong>nginx压缩包</strong>到<strong>/usr/local/application</strong>    tar -zxvf nginx-1.9.15.tar.gz -C /usr/local/application</li><li>把文件压缩<strong>t01.tar.gz</strong>   tar -zcvf  t01.tar.gz t.jpg</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux常见命令&quot;&gt;&lt;a href=&quot;#Linux常见命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常见命令&quot;&gt;&lt;/a&gt;Linux常见命令&lt;/h1&gt;&lt;h2 id=&quot;一、-bash-XX-command-not-found解决&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://deschen.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Security笔记---基本原理及认证流程</title>
    <link href="http://deschen.com/2019/05/23/Security%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/"/>
    <id>http://deschen.com/2019/05/23/Security%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-05-23T00:29:18.000Z</published>
    <updated>2020-02-12T00:38:34.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security笔记—基本原理及认证流程"><a href="#Spring-Security笔记—基本原理及认证流程" class="headerlink" title="Spring Security笔记—基本原理及认证流程"></a>Spring Security笔记—基本原理及认证流程</h1><h2 id="一、-基本原理"><a href="#一、-基本原理" class="headerlink" title="一、 基本原理"></a>一、 基本原理</h2><p><img src="https://img-blog.csdnimg.cn/20190820004415916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>黄色模块：SecurityContextPersistenceFilter是承接容器的session与spring security的重要filter，主要工作是从session中获取SecurityContext，然后放到上下文中，之后的filter大多依赖这个来获取登录态。其主要是通过HttpSessionSecurityContextRepository来存取的。</li><li>绿色模块：可选择添加的认证过滤器，用于验证用户登入信息是否正确，正确则保存在session,主要代码AbstractAuthenticationProcessingFilter抽象类的<code>SecurityContextHolder.getContext().setAuthentication(authResult)</code></li><li>橘色模块：FilterSecurityInterceptor 最后的大门，通过WebSecurityConfigurerAdapter或其实现类的<code>protected void configure(HttpSecurity http) throws Exception</code>的配置方法，来确定请求是否能访问</li><li>深蓝色模块：ExceptionTranslationFilter 用于获取橘色模块的异常信息，凡是橘色模块不通过的请求就会报错，被其接受</li></ul><h2 id="二、认证流程"><a href="#二、认证流程" class="headerlink" title="二、认证流程"></a>二、认证流程</h2><h3 id="1、-流程图"><a href="#1、-流程图" class="headerlink" title="1、 流程图"></a>1、 流程图</h3><p><img src="https://img-blog.csdnimg.cn/2019082000443247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2、认证源码大致方向"><a href="#2、认证源码大致方向" class="headerlink" title="2、认证源码大致方向"></a>2、认证源码大致方向</h3><ul><li>大致源码流程比较绕口，不过不是想象中麻烦，具体源码我会在2.3 源码详情追综，希望大伙能坚持一下</li><li>递进流程：用户提交登入信息 —》AbstractAuthenticationProcessingFilter 的 dofilter(…)方法 —》UsernamePasswordAuthenticationFilterr 的 attemptAuthentication(…)方法获取用户名和密码生成未认证的UsernamePasswordAuthenticationToken（是Authentication的子类） —》 ProviderManager（AuthenticatonManager的子类）的 authenticate(…) 方法接受UsernamePasswordAuthenticationToken参数  —》 AbstractUserDetailsAuthenticationProvider（AuthenticationProvider的子类）authenticate(….)的方法里面的的 retrieveUser(…)  —》DaoAuthenticationProvider的 retrieveUser(…) —-》CustomUserDetailService(自己写的，是UserDetailService的子类)的loadUserByUsername(…) 获取用户信息 </li><li>返回流程：CustomUserDetailService 的 loadUserByUsername(…) 获取用户信息后—》AbstractUserDetailsAuthenticationProvider 的 createSuccessAuthentication(…) 把未认证的UsernamePasswordAuthenticationToken变成已认证的状态 —》AbstractAuthenticationProcessingFilter的successfulAuthentication(…) 的SecurityContextHolder.getContext().setAuthentication(authResult)；把UsernamePasswordAuthenticationToken存到Session</li></ul><h3 id="3、-源码详解"><a href="#3、-源码详解" class="headerlink" title="3、 源码详解"></a>3、 源码详解</h3><blockquote><p>我会抠出 2.2 认证源码大致方向的代码里面关键部分并标序号注释讲解，建议大家用debug模式打点，亲自测试更好记忆</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"---------------AbstractAuthenticationProcessingFilter ---------------------------------"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">... 省略部分</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 调用UsernamePasswordAuthenticationFilterr(其子类)的attemptAuthentication(...)方法，跳到下个分割线处</span></span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> (authResult == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InternalAuthenticationServiceException failed) ...异常处理省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 16. 获取序号15的Authentication对象，调用该方法</span></span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">successfulAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Authentication success. Updating SecurityContextHolder to contain: "</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 17. 获取序号15的Authentication对象，保存在session中</span></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line"></span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fire event</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.eventPublisher != <span class="keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 18.成功处理</span></span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------------UsernamePasswordAuthenticationFilterr--------------------"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">           <span class="comment">// 请求方式必须是Post请求</span></span><br><span class="line"><span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(</span><br><span class="line"><span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String username = obtainUsername(request);   <span class="comment">// 获取用户名</span></span><br><span class="line">String password = obtainPassword(request);   <span class="comment">// 获取密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (username == <span class="keyword">null</span>) &#123;</span><br><span class="line">username = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password == <span class="keyword">null</span>) &#123;</span><br><span class="line">password = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">username = username.trim();</span><br><span class="line"><span class="comment">// 2. 生成UsernamePasswordAuthenticationToken（Authentication的子类）对象,跳到下个分割线处</span></span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line"></span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. this.getAuthenticationManager() 获取Authentication的实现类，即ProviderManager，跳到下个分割线处</span></span><br><span class="line">       <span class="comment">//  15.获取序号14的Authenticaition对象，返回上个分割线</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------UsernamePasswordAuthenticationToken构造方法------------------------------"</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3. 因为刚登入所以是false，未认证状态, 回到上个分割线处</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.principal = principal;</span><br><span class="line"><span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">setAuthenticated(<span class="keyword">false</span>);   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------------------------ProviderManager-----------------------------------"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">...省略部分</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 选择那种认证方式</span></span><br><span class="line"><span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!provider.supports(toTest)) &#123;   <span class="comment">// 判断该认证用那种AuthenticationProvider的实现类实现</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (debug) &#123;</span><br><span class="line">logger.debug(<span class="string">"Authentication attempt using "</span></span><br><span class="line">+ provider.getClass().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 6. 找到相应的认证方式的子类后，即AbstractUserDetailsAuthenticationProvider类调用方法，跳到下个分割线处</span></span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 13.把序号12的UserDetails对象，赋值到result(Authentication)对象</span></span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AccountStatusException e) ...异常处理省略</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line"><span class="comment">// Authentication is complete. Remove credentials and other secret data</span></span><br><span class="line"><span class="comment">// from authentication</span></span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">            <span class="comment">// 14. 序号13的result对象，到上个分割线</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"--------------------AbstractUserDetailsAuthenticationProvider----------------------"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">...省略部分</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 7. 通过DaoAuthenticationProvider(即AbstractUserDetailsAuthenticationProvide的子类)实现类方法来获取UserDetail对象，跳到下个分割线处</span></span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">                <span class="comment">// 11. 获取序号10的的UserDetails对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UsernameNotFoundException notFound) ... 异常处理省略</span><br><span class="line"></span><br><span class="line">Assert.notNull(user,</span><br><span class="line"><span class="string">"retrieveUser returned null - a violation of the interface contract"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// xxx.check(user) 用于验证用户信息是否合理,跟UserDetails构造方法有关，里面有一个为false，则报错不通过</span></span><br><span class="line">    <span class="comment">// User user = new User("zhangsan",  /// 用户名</span></span><br><span class="line">        <span class="comment">//      password,  // 密码</span></span><br><span class="line">        <span class="comment">//        true,  // 账号是否失效</span></span><br><span class="line">        <span class="comment">//        true,   // 账号是否过期</span></span><br><span class="line">        <span class="comment">//        true,  // 密码是否过期</span></span><br><span class="line">        <span class="comment">//        true,  // 账号是否冻结</span></span><br><span class="line">        <span class="comment">//        AuthorityUtils.commaSeparatedStringToAuthorityList("admin"));</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">preAuthenticationChecks.check(user);  </span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AuthenticationException exception) ...异常处理省略</span><br><span class="line"></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 12. 返回序号11的的UserDetails对象, 通过createSuccessAuthentication使其变成已认证状态</span></span><br><span class="line"><span class="keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"------------------------------------DaoAuthenticationProvider--------------------------"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username,</span></span></span><br><span class="line"><span class="function"><span class="params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">prepareTimingAttackProtection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 8. 通过自定义UserDetailService的子类来获取UserDetails对象---用户信息,跳到下个分割线</span></span><br><span class="line">UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line"><span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(</span><br><span class="line"><span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 10. 获取序号9的UserDetails对象，返回上个分割线</span></span><br><span class="line"><span class="keyword">return</span> loadedUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (UsernameNotFoundException ex) ...异常处理省略</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"----------------------CustomUserDetailService-----------------------------------"</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 9。获取用户信息，不连接数据库（虚拟账号），获取成功跳到上个分割线</span></span><br><span class="line">        log.info(<span class="string">"【CustomUserDetailService】根据用户名获取用户信息, username = &#123;&#125;"</span>, username);</span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">"123"</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"zhangsan"</span>,  <span class="comment">/// 用户名</span></span><br><span class="line">                password,  <span class="comment">// 密码</span></span><br><span class="line">                <span class="keyword">true</span>,  <span class="comment">// 账号是否失效</span></span><br><span class="line">                <span class="keyword">true</span>,   <span class="comment">// 账号是否过期</span></span><br><span class="line">                <span class="keyword">true</span>,  <span class="comment">// 密码是否过期</span></span><br><span class="line">                <span class="keyword">true</span>,  <span class="comment">// 账号是否冻结</span></span><br><span class="line">                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>));</span><br><span class="line">        log.info(<span class="string">"【CustomUserDetailService】 password = &#123;&#125;"</span>, password);</span><br><span class="line">        log.info(<span class="string">"【CustomUserDetailService】获取User对象，user = &#123;&#125;"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Security笔记—基本原理及认证流程&quot;&gt;&lt;a href=&quot;#Spring-Security笔记—基本原理及认证流程&quot; class=&quot;headerlink&quot; title=&quot;Spring Security笔记—基本原理及认证流程&quot;&gt;&lt;/a&gt;Sprin
      
    
    </summary>
    
    
      <category term="安全框架" scheme="http://deschen.com/categories/%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="security" scheme="http://deschen.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Restful风格设计</title>
    <link href="http://deschen.com/2019/05/12/Restful%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1/"/>
    <id>http://deschen.com/2019/05/12/Restful%E9%A3%8E%E6%A0%BC%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-05-12T00:22:11.000Z</published>
    <updated>2019-05-13T00:18:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Restful风格设计"><a href="#Restful风格设计" class="headerlink" title="Restful风格设计"></a>Restful风格设计</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="Restful-其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的-API-设计规范，用于-Web-数据接口的设计"><a href="#Restful-其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的-API-设计规范，用于-Web-数据接口的设计" class="headerlink" title="Restful 其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的 API 设计规范，用于 Web 数据接口的设计"></a>Restful 其实不是什么新技术或服务，而是一种对web进行一些标准和约束，是目前最流行的 API 设计规范，用于 Web 数据接口的设计</h3><h2 id="二-为什么使用Restful风格"><a href="#二-为什么使用Restful风格" class="headerlink" title="二. 为什么使用Restful风格"></a>二. 为什么使用Restful风格</h2><h3 id="1-普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢"><a href="#1-普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢" class="headerlink" title="1. 普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢"></a>1. 普通http请求，没有一种规范去约束，开发不只是一个人的事，无规律的http请求，时间一久连你自己都可能忘记何况拿给别人看呢</h3><h3 id="2-，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率"><a href="#2-，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率" class="headerlink" title="2.，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率"></a>2.，Restful请求具有自描述性，需要在形式上给人以直觉上的关联，使其一目了然，更好与其他人进行交，而且大大减少时间成本，要知道时间就是效率</h3><h2 id="三、Restful的规范"><a href="#三、Restful的规范" class="headerlink" title="三、Restful的规范"></a>三、Restful的规范</h2><blockquote><p>Restful很简单，就像数学公式一样，知道一些要点就会灵活运用，切记死记硬背</p></blockquote><h3 id="1-Url链接模式：动词-宾语"><a href="#1-Url链接模式：动词-宾语" class="headerlink" title="1.Url链接模式：动词+宾语"></a>1.Url链接模式：动词+宾语</h3><h3 id="2-动词：代表请求方式"><a href="#2-动词：代表请求方式" class="headerlink" title="2. 动词：代表请求方式"></a>2. 动词：代表请求方式</h3><ul><li>GET：获取（Get）</li><li>POST：添加（Create）</li><li>PUT：更新（Update）</li><li>DELETE：删除（Delete）</li></ul><h3 id="3-宾语：必须是名词"><a href="#3-宾语：必须是名词" class="headerlink" title="3. 宾语：必须是名词"></a>3. 宾语：必须是名词</h3><ul><li><a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a>   user:就是名词，想用复数表示的话，就跟英语一样，直接在后面加s，即<a href="http://localhost:8080/users" target="_blank" rel="noopener">http://localhost:8080/users</a></li><li>尽量避免多级请求：<a href="http://localhost:8080/management/1/user/1" target="_blank" rel="noopener">http://localhost:8080/management/1/user/1</a> 应该为：<a href="http://localhost:8080/management/1?user=1" target="_blank" rel="noopener">http://localhost:8080/management/1?user=1</a> (具体意思和用处后面详解)</li></ul><h3 id="4根据上面两点组合起来"><a href="#4根据上面两点组合起来" class="headerlink" title="4根据上面两点组合起来"></a>4根据上面两点组合起来</h3><ul><li>GET：<a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> 获取用户id=1信息</li><li>POST：<a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a>  添加用户信息（post请求的参数无法查看）</li><li>PUT：<a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a>  更新用户信息 todo:待完成</li><li>DELETE：<a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> 删除用户id=1信息</li></ul><h3 id="5-测试用例-详细代码"><a href="#5-测试用例-详细代码" class="headerlink" title="5.测试用例,详细代码"></a>5.测试用例,详细代码</h3><blockquote><p>接下来之后显示跟本次主题相关的代码，详细代码请见：<a href="https://github.com/ChaASuc/restful-demo.git，" target="_blank" rel="noopener">https://github.com/ChaASuc/restful-demo.git，</a> 如果觉得可以就fork一下，谢谢。有问题请发言，鄙人会虚心听取<br>该项目使用SpringBoot + tkMapper + H2数据库模式，直接运行即可使用<br>里面封装后台开发通用代码，也可以看我的实际项目—-个人博客系统：<a href="https://github.com/ChaASuc/myblog.git，" target="_blank" rel="noopener">https://github.com/ChaASuc/myblog.git，</a> 该项目内容更全，技术点更多，希望对你有帮助</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190812220550723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-1、添加用户"><a href="#5-1、添加用户" class="headerlink" title="5.1、添加用户"></a>5.1、添加用户</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//请求方式：Post;</span></span><br><span class="line">  <span class="comment">//请求路径 http://localhost:8080/user;</span></span><br><span class="line">  <span class="comment">// 请求参数User对象</span></span><br><span class="line">  <span class="comment">// 含义：把user对象添加数据库中</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultVO <span class="title">insertUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          @RequestBody User user</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      userService.insertUser(user);</span><br><span class="line">      ResultVO.success();</span><br><span class="line">      <span class="keyword">return</span> ResultVO.success();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812215824743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-2、获取用户信息"><a href="#5-2、获取用户信息" class="headerlink" title="5.2、获取用户信息"></a>5.2、获取用户信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求方式：Get;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/user/&#123;id&#125;;</span></span><br><span class="line"><span class="comment">// 含义：把根据id获取用户信息</span></span><br><span class="line"><span class="comment">// @PathVariable 获取链接&#123;&#125;里面的值：例如http://localhost:8080/user/1 即 id = 1</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">selectUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable Long id</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    User user = userService.selectUser(id);</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812223401709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求方式：Get;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/users;   users是复数形式</span></span><br><span class="line"><span class="comment">// 含义：获取所有用户信息</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">selectUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userService.selectUsers();</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812223617463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-3、更新用户信息"><a href="#5-3、更新用户信息" class="headerlink" title="5.3、更新用户信息"></a>5.3、更新用户信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求方式：Put;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/user;</span></span><br><span class="line"><span class="comment">// 请求参数User对象 </span></span><br><span class="line"><span class="comment">// 含义：根据用户对象更新数据库</span></span><br><span class="line"><span class="meta">@PutMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">updateUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestBody User user</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    userService.updateUser(user);</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812224405307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190812224442895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="5-4、删除用户信息"><a href="#5-4、删除用户信息" class="headerlink" title="5.4、删除用户信息"></a>5.4、删除用户信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//请求方式：Delete;</span></span><br><span class="line"><span class="comment">//请求路径 http://localhost:8080/user/&#123;id&#125;;</span></span><br><span class="line"><span class="comment">// 含义：根据id删除用户信息</span></span><br><span class="line"><span class="meta">@DeleteMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultVO <span class="title">deleteUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable Long id</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    userService.deleteUser(id);</span><br><span class="line">    <span class="keyword">return</span> ResultVO.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190812224924274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190812225235496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTE0Nzg4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Restful风格设计&quot;&gt;&lt;a href=&quot;#Restful风格设计&quot; class=&quot;headerlink&quot; title=&quot;Restful风格设计&quot;&gt;&lt;/a&gt;Restful风格设计&lt;/h1&gt;&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://deschen.com/categories/Java/"/>
    
    
      <category term="接口设计" scheme="http://deschen.com/tags/%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
