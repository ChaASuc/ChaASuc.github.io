<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deschen Blog</title>
  
  <subtitle>以Java开发为主的个人博客，记录自己在学习、工作和成长的笔记和心得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.deschen.cn/"/>
  <updated>2021-12-29T13:46:03.201Z</updated>
  <id>https://blog.deschen.cn/</id>
  
  <author>
    <name>Deschen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo-百度收录</title>
    <link href="https://blog.deschen.cn/2021/12/29/Hexo-%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/"/>
    <id>https://blog.deschen.cn/2021/12/29/Hexo-%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/</id>
    <published>2021-12-29T02:40:29.188Z</published>
    <updated>2021-12-29T13:46:03.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-百度收录"><a href="#Hexo-百度收录" class="headerlink" title="Hexo-百度收录"></a>Hexo-百度收录</h1><h2 id="一、安装Hexo插件"><a href="#一、安装Hexo插件" class="headerlink" title="一、安装Hexo插件"></a>一、安装Hexo插件</h2><ul><li><p>Hexo相关版本及配置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hexo版本: <span class="number">4.2</span>.<span class="number">0</span> (命令：hexo -v)  </span><br><span class="line"><span class="keyword">node</span><span class="title">版本: v12</span>.<span class="number">18.3</span>（命令：<span class="keyword">node</span> <span class="title">-v</span>）</span><br><span class="line">npm版本: <span class="number">6.14</span>.<span class="number">8</span>（命令：npm -v）</span><br></pre></td></tr></table></figure></li><li><p>切换到项目的根目录，安装对应的插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-baidu-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li><p>修改配置（位置：项目根目录的_config.yml文件）</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 配置域名（域名生成规则，可以看文件尾部）</span></span><br><span class="line"><span class="symbol">url:</span> https:<span class="comment">//blog.deschen.cn</span></span><br><span class="line"><span class="meta"># 自动生成sitemap</span></span><br><span class="line"><span class="symbol">sitemap:</span></span><br><span class="line"><span class="symbol">path:</span> sitemap.xml</span><br><span class="line"><span class="symbol">baidusitemap:</span></span><br><span class="line"><span class="symbol">path:</span> baidusitemap.xml</span><br></pre></td></tr></table></figure></li><li><p>hexo重新生成，查看根目录public目录是否存在sitemap.xml以及baidusitemap.xml就表示成功了</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二、百度收录"><a href="#二、百度收录" class="headerlink" title="二、百度收录"></a>二、百度收录</h2><ul><li><p>添加站点</p><p>登录<a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度资源管理平台</a>，依次点击 <strong>用户中心</strong>-&gt;<strong>站点管理</strong>-&gt;<strong>添加网站</strong></p><ul><li><p>输入网址： <a href="https://blog.deschen.cn">https://blog.deschen.cn</a></p></li><li><p>验证网站</p><ol><li><p>请点击 下载验证文件 </p><p>获取验证文件（当前最新：baidu_verify_code-h9UuMfy7H4.html）</p><p>将验证文件放置于您所配置域名(<a href="https://blog.deschen.cn)的根目录下" target="_blank" rel="noopener">https://blog.deschen.cn)的根目录下</a></p><p>点击这里确认验证文件可以正常访问</p><p>请点击“完成验证”按钮</p><p>为保持验证通过的状态,成功验证后请不要删除HTML文件</p></li><li><p>HTML标签验证（没试过，以下是摘抄某博客）</p><p>在themes/next/layout/_partials/head.swig内：修改meta标签为站长网站上给出的标签即可：</p><p>同时，在themes/next/_config.yml中将google-site-verification和baidu_site_verification的值设置为true即可。</p></li><li><p>CNAME 验证（没试过，以下是摘抄某博客）</p></li></ol><p>​    </p></li></ul></li></ul><ul><li><p>下载后的插件存放位置（解读收录的URL生成规则）</p><figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">项目根目录\node_modules\hexo-generator-sitemap</span></span><br><span class="line"><span class="xml">项目根目录\node_modules\hexo-generator-baidu-sitemap</span></span><br><span class="line"><span class="xml">URL生成规则</span></span><br><span class="line"><span class="xml">路径：项目根目录\node_modules\hexo-generator-baidu-sitemap\baidusitemap.ejs</span></span><br><span class="line"><span class="xml">源码：baiduUrl即使URL的域名，而获取方式通过config.url和config.baidusitemap.url，且后者优先级高，而config表示的是hexo的_config.yml配置文件，其后面的配置属性对应文件的配置属性。因此，可以通过_config.yml设置域名（如：url: 域名 | baidusitemap:url: 域名）</span></span><br><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">urlset</span> <span class="attr">xmlns</span>=<span class="string">"http://www.sitemaps.org/schemas/sitemap/0.9"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">%</span></span></span></span><br><span class="line"><span class="ruby">          var baiduUrl = config.url  </span></span><br><span class="line"></span><br><span class="line"><span class="ruby">          <span class="keyword">if</span> (config.baidusitemap.url) &#123;</span></span><br><span class="line"><span class="ruby">            baiduUrl = config.baidusitemap.url</span></span><br><span class="line"><span class="ruby">          &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="ruby">          var url = baiduUrl + config.root;</span></span><br><span class="line"><span class="ruby">          posts.forEach(function(post)&#123;</span></span><br><span class="line"><span class="ruby">          <span class="keyword">if</span>(post.categories)&#123; </span><span class="xml">-%&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">loc</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span></span></span><span class="ruby"> encodeURI(url + post.path) </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> post.updated.toDate().toISOString().replace(<span class="regexp">/T.*$/i</span>, <span class="string">""</span>) <span class="params">||</span> post.date.toDate().toISOString().replace(<span class="regexp">/T.*$/i</span>, <span class="string">""</span>) </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby">&#125;&#125;) </span><span class="xml"><span class="tag"><span class="attr">-</span>%&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">urlset</span>&gt;</span> -%&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo-百度收录&quot;&gt;&lt;a href=&quot;#Hexo-百度收录&quot; class=&quot;headerlink&quot; title=&quot;Hexo-百度收录&quot;&gt;&lt;/a&gt;Hexo-百度收录&lt;/h1&gt;&lt;h2 id=&quot;一、安装Hexo插件&quot;&gt;&lt;a href=&quot;#一、安装Hexo插件&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Yapi的部署和使用</title>
    <link href="https://blog.deschen.cn/2021/05/10/Yapi%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.deschen.cn/2021/05/10/Yapi%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-10T00:07:50.255Z</published>
    <updated>2021-05-12T05:44:40.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Yapi-的部署和使用"><a href="#Yapi-的部署和使用" class="headerlink" title="Yapi 的部署和使用"></a>Yapi 的部署和使用</h1><h2 id="一、基于-docker-compose-部署-Yapi"><a href="#一、基于-docker-compose-部署-Yapi" class="headerlink" title="一、基于 docker-compose 部署 Yapi"></a>一、基于 docker-compose 部署 Yapi</h2><blockquote><p>如何部署 docker-compose，点击我博客的<a href="https://deschen.gitee.io/2021/03/23/docker-compose%20+%20jenkins%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">链接</a></p></blockquote><ul><li>部署 Yapi 的 docker-compose.yml。PS：因为 Yapi 的数据库就是MongoDB，所以部署 Yapi 要同时部署 MongoDB</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.1'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">yapi:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mrjin/yapi:latest</span></span><br><span class="line">    <span class="comment"># build: ./</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">yapi</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">VERSION=1.5.6</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LOG_PATH=/tmp/yapi.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HOME=/home</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PORT=3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_EMAIL=me@jinfeijie.cn</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_SERVER=mongo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=yapi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=27017</span></span><br><span class="line">    <span class="comment"># restart: always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">13000</span><span class="string">:3000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9090</span><span class="string">:9090</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./log/yapi.log:/home/vendors/log</span> <span class="comment"># log dir</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">"bash /wait-for-it.sh mongo:27017 -- entrypoint.sh"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yapi</span></span><br><span class="line">  <span class="attr">mongo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo</span></span><br><span class="line">    <span class="comment"># restart: always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../mongodb/db:/data/db</span> <span class="comment">#db dir</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yapi</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">yapi:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><h2 id="二、IDEA-关于-Yapi-的使用"><a href="#二、IDEA-关于-Yapi-的使用" class="headerlink" title="二、IDEA 关于 Yapi 的使用"></a>二、IDEA 关于 Yapi 的使用</h2><ul><li><p>先下载 YapiUpload 插件，用于把接口上传到 Yapi 应用上</p></li><li><p>在 .idea 文件夹下的 misc.xml 插入 关于 Yapi 的配置,</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- yapi配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">"yapi"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"projectToken"</span>&gt;</span>22bffb576415df1b8d088176dd9090cd2d5a29141a23d059f68f8988d1823d20<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"projectId"</span>&gt;</span>11<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"yapiUrl"</span>&gt;</span>http://192.168.163.138:3000<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">name</span>=<span class="string">"projectType"</span>&gt;</span>api<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Yapi-的部署和使用&quot;&gt;&lt;a href=&quot;#Yapi-的部署和使用&quot; class=&quot;headerlink&quot; title=&quot;Yapi 的部署和使用&quot;&gt;&lt;/a&gt;Yapi 的部署和使用&lt;/h1&gt;&lt;h2 id=&quot;一、基于-docker-compose-部署-Yapi&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker命令集</title>
    <link href="https://blog.deschen.cn/2021/03/23/docker%E5%91%BD%E4%BB%A4%E9%9B%86/"/>
    <id>https://blog.deschen.cn/2021/03/23/docker%E5%91%BD%E4%BB%A4%E9%9B%86/</id>
    <published>2021-03-23T03:03:10.963Z</published>
    <updated>2021-03-29T02:56:07.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker命令集"><a href="#docker命令集" class="headerlink" title="docker命令集"></a>docker命令集</h1><p>[toc]</p><h2 id="一、docker-基本命令"><a href="#一、docker-基本命令" class="headerlink" title="一、docker 基本命令"></a>一、docker 基本命令</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker 远程访问</span></span><br><span class="line">- 打开docker.<span class="symbol">service:</span> vim /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">docker</span>.<span class="title">service</span></span></span><br><span class="line">- ExecStart修改参数：</span><br><span class="line">- 如果是centos7，修改为：ExecStart=<span class="regexp">/usr/bin</span><span class="regexp">/dockerd -H tcp:/</span><span class="regexp">/0.0.0.0:2375 -H unix:/</span><span class="regexp">/var/run</span><span class="regexp">/docker.sock</span></span><br><span class="line"><span class="regexp">- 如果是centos7以下，修改为：ExecStart=/usr</span><span class="regexp">/bin/dockerd</span> -H <span class="symbol">fd:</span>/<span class="regexp">/ -H tcp:/</span><span class="regexp">/0.0.0.0:2375</span></span><br><span class="line"><span class="regexp">- 输入网址，出现json参数则远程访问成功：http:/</span><span class="regexp">/ip:2375/info</span></span><br></pre></td></tr></table></figure><h2 id="二、docker镜像命令"><a href="#二、docker镜像命令" class="headerlink" title="二、docker镜像命令"></a>二、docker镜像命令</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 搜索镜像</span></span><br><span class="line">docker search [option] keyword</span><br><span class="line"><span class="bullet">- </span>option子命令</span><br><span class="line"><span class="bullet">- </span>-f, --filter 过滤输出的内容，而过滤的条件名是标题名</span><br><span class="line"><span class="bullet">- </span>--limit int 指定搜索内容个数</span><br><span class="line"><span class="bullet">- </span>--no-trunc 不截断输出内容</span><br><span class="line"><span class="bullet">- </span>例子</span><br><span class="line"><span class="bullet">- </span>docker search --filter "is-official=true" mysql</span><br><span class="line"><span class="bullet">- </span>docker search --filter "stars=500" mysql</span><br><span class="line"><span class="section"># 查看镜像文件</span></span><br><span class="line">docker images</span><br><span class="line"><span class="section"># 下拉镜像文件</span></span><br><span class="line">docker pull [OPTIONS] NAME[:TAG]</span><br><span class="line"><span class="bullet">- </span>OPTIONS</span><br><span class="line"><span class="bullet">- </span>-a :拉取所有 tagged 镜像</span><br><span class="line"><span class="bullet">- </span>--disable-content-trust :忽略镜像的校验,默认开启</span><br><span class="line"><span class="bullet">- </span>TAG：版本号，可以在官方网找具体版本 https://hub.docker.com/r/library/</span><br><span class="line"><span class="section"># 删除镜像(前提是要删除对应容器，否则使用docker rmi -f命令强制删除)</span></span><br><span class="line">docker rmi REPOSITORY:TAG 或者 docker rmi IMAGE_ID</span><br></pre></td></tr></table></figure><h2 id="三、docker-容器命令"><a href="#三、docker-容器命令" class="headerlink" title="三、docker 容器命令"></a>三、docker 容器命令</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps [<span class="keyword">option</span>]</span><br><span class="line">- <span class="keyword">option</span>子命令</span><br><span class="line">- -a 查找所有容器，包括未运行的容器；没填则默认显示启动的容器</span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker run [<span class="keyword">option</span>] [-d] [image]</span><br><span class="line">- <span class="keyword">option</span> 子命令</span><br><span class="line">-  --privileged=<span class="keyword">true</span> 使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限。例如：普通用户不允许docker内启动docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker命令集&quot;&gt;&lt;a href=&quot;#docker命令集&quot; class=&quot;headerlink&quot; title=&quot;docker命令集&quot;&gt;&lt;/a&gt;docker命令集&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、docker-基本命令&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker-compose + jenkins搭建部署</title>
    <link href="https://blog.deschen.cn/2021/03/23/docker-compose%20+%20jenkins%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/"/>
    <id>https://blog.deschen.cn/2021/03/23/docker-compose%20+%20jenkins%E6%90%AD%E5%BB%BA%E9%83%A8%E7%BD%B2/</id>
    <published>2021-03-23T00:53:17.288Z</published>
    <updated>2021-03-25T01:25:25.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-compose-jenkins搭建部署"><a href="#docker-compose-jenkins搭建部署" class="headerlink" title="docker-compose + jenkins搭建部署"></a>docker-compose + jenkins搭建部署</h1><p>[toc]</p><h2 id="一、docker的下载安装"><a href="#一、docker的下载安装" class="headerlink" title="一、docker的下载安装"></a>一、docker的下载安装</h2><ul><li><p>docker安装环境条件</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Docker安装环境条件</span><br><span class="line"># <span class="number">1</span>、Docker 运行在 CentOS <span class="number">7</span> 上，要求系统为<span class="number">64</span>位、系统内核版本为 <span class="number">3.10</span> 以上。</span><br><span class="line"># <span class="number">2</span>、Docker 运行在 CentOS<span class="number">-6.5</span> 或更高的版本的 CentOS 上，要求系统为<span class="number">64</span>位、系统内核版本为 <span class="number">2.6</span><span class="number">.32</span><span class="number">-431</span> 或者更高版本。内核编译时需要激活namespace,CGgroup,netfilter,veth等特性，还对iptablest等工具版有依赖要求。</span><br><span class="line"></span><br><span class="line"># 查看linux版本 需要CentOS7版本以上</span><br><span class="line">rpm -q centos-release</span><br><span class="line"># 查看内核版本</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure></li><li><p>卸载旧的docker</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载旧的安装的组件</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">yum remove docker \</span></span><br><span class="line">                  <span class="meta">docker-client</span> <span class="string">\</span></span><br><span class="line">                  <span class="meta">docker-client-latest</span> <span class="string">\</span></span><br><span class="line">                  <span class="meta">docker-common</span> <span class="string">\</span></span><br><span class="line">                  <span class="meta">docker-latest</span> <span class="string">\</span></span><br><span class="line">                  <span class="meta">docker-latest-logrotate</span> <span class="string">\</span></span><br><span class="line">                  <span class="meta">docker-logrotate</span> <span class="string">\</span></span><br><span class="line">                  <span class="attr">docker-engine</span></span><br></pre></td></tr></table></figure></li><li><p>安装依赖及设置存储库</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装yum-utils</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">yum install -y yum-utils</span></span><br><span class="line"><span class="comment"># 设置稳定的存储库</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">yum-config-manager \</span></span><br><span class="line">    <span class="meta">--add-repo</span> <span class="string">\</span></span><br><span class="line">    <span class="attr">http</span>:<span class="string">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure></li><li><p>安装docker</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接安装最新Docker引擎和容器</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">yum -y install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line"><span class="comment"># 安装完成后查看版本</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">-v</span></span><br></pre></td></tr></table></figure><p>或者安装指定版本</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 列出可用版本</span><br><span class="line">yum <span class="keyword">list</span> docker-<span class="keyword">ce</span> --showduplicates | <span class="keyword">sort</span> -r</span><br><span class="line"># 安装指定版本</span><br><span class="line">sudo yum install docker-<span class="keyword">ce</span>-<span class="symbol">&lt;VERSION_STRING&gt;</span> docker-<span class="keyword">ce</span>-cli-<span class="symbol">&lt;VERSION_STRING&gt;</span> containerd.io</span><br><span class="line"># 例子</span><br><span class="line">sudo yum install docker-<span class="keyword">ce</span>-<span class="number">18.09</span>.<span class="number">1</span> docker-<span class="keyword">ce</span>-cli-<span class="number">18.09</span>.<span class="number">1</span> containerd.io</span><br></pre></td></tr></table></figure></li><li><p>docker的操作</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="comment"># 停止docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="comment"># 设置开机自启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"><span class="comment"># 查看信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment"># 查看帮助文档</span></span><br><span class="line">docker --help</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">- <span class="comment"># 1、卸载 Docker 引擎、CLI 和容器包</span></span><br><span class="line">    sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line">- <span class="comment"># 2、主机上的图像、容器、卷或自定义配置文件不会自动删除。要删除所有图像、容器和卷</span></span><br><span class="line">    sudo rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span></span></span><br><span class="line">- <span class="comment"># 3、必须手动删除任何编辑的配置文件</span></span><br><span class="line">    sudo rm 配置文件</span><br></pre></td></tr></table></figure></li><li><p>验证docker是否安装成功</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下拉并运行hello-world镜像</span></span><br><span class="line">docker <span class="keyword">run</span><span class="bash"> hello-world</span></span><br></pre></td></tr></table></figure></li><li><p>阿里镜像源做为docker镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">》注册阿里账号》搜索：容器镜像》镜像加速器》选择CentOS》直接复制命令运行</span><br></pre></td></tr></table></figure><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210323111816853.png" alt="image-20210323111816853"></p></li></ul><h2 id="二、docker-compose安装"><a href="#二、docker-compose安装" class="headerlink" title="二、docker-compose安装"></a>二、docker-compose安装</h2><ul><li><p>docker-compose安装</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https:<span class="regexp">//gi</span>thub.com<span class="regexp">/docker/</span>compose<span class="regexp">/releases/</span>download<span class="regexp">/1.21.2/</span>docker-compose-$(uname -s)-$(uname -m) -o <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br><span class="line">sudo chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br><span class="line"><span class="comment"># 1.21.2 是docker-compose版本，可以根据自己需求在github查找版本</span></span><br><span class="line"><span class="comment"># docker-compose-$(uname -s)-$(uname -m)  在centos7中输出为docker-compose-Linux-x86_64</span></span><br></pre></td></tr></table></figure></li><li><p>docker-compose命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose 命令默认使用的配置文件是当前目录中的 docker-compose.yml 文件</span></span><br><span class="line">docker<span class="literal">-compose</span> up</span><br><span class="line"><span class="comment"># -f 指定其他配置文件。可以添加多个 -f 选项，docker-compose 会自动合并它们，当然也会根据先后顺序把一些重复的配置项覆盖掉</span></span><br><span class="line"><span class="comment"># 自动完成包括构建镜像，(重新)创建服务，启动服务，并关联服务相关容器的一系列操作。不过在前台打印信息，ctrl+c容器就会停止</span></span><br><span class="line">docker<span class="literal">-compose</span> <span class="operator">-f</span> docker<span class="literal">-compose</span>.yml <span class="operator">-f</span> docker<span class="literal">-compose</span><span class="literal">-dev</span> up </span><br><span class="line"><span class="comment"># 后台启动并运行</span></span><br><span class="line">docker<span class="literal">-compose</span> <span class="operator">-f</span> docker<span class="literal">-compose</span>.yml <span class="operator">-f</span> docker<span class="literal">-compose</span><span class="literal">-dev</span> up <span class="literal">-d</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="三、docker-compose-jenkins部署"><a href="#三、docker-compose-jenkins部署" class="headerlink" title="三、docker-compose+jenkins部署"></a>三、docker-compose+jenkins部署</h2><ul><li><p>关于jenkins的docker-compose.yml文件</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: '3.1'</span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    image: jenkins/jenkins:lts</span><br><span class="line">    volumes:       # 挂载目录  本地文件夹目录:容器文件夹目录</span><br><span class="line">      -<span class="ruby"> /data/jenkins/<span class="symbol">:/var/jenkins_home</span></span></span><br><span class="line"><span class="ruby">      - <span class="regexp">/var/run</span><span class="regexp">/docker.sock:/var</span><span class="regexp">/run/docker</span>.sock</span></span><br><span class="line"><span class="ruby">      - <span class="regexp">/usr/bin</span><span class="regexp">/docker:/usr</span><span class="regexp">/bin/docker</span></span></span><br><span class="line"><span class="ruby">      - <span class="regexp">/usr/lib</span><span class="regexp">/x86_64-linux-gnu/libltdl</span>.so.<span class="number">7</span><span class="symbol">:/usr/lib/x86_64-linux-gnu/libltdl</span>.so.<span class="number">7</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">ports:</span>   <span class="comment"># 绑定端口</span></span></span><br><span class="line"><span class="ruby">      - <span class="string">"8080:8080"</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">expose:</span>  <span class="comment"># 暴露端口</span></span></span><br><span class="line"><span class="ruby">      - <span class="string">"8080"</span></span></span><br><span class="line"><span class="ruby">      - <span class="string">"50000"</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">privileged:</span> <span class="literal">true</span></span></span><br><span class="line"><span class="ruby">    <span class="symbol">user:</span> root</span></span><br><span class="line"><span class="ruby">    <span class="symbol">restart:</span> always</span></span><br><span class="line"><span class="ruby">    <span class="symbol">container_name:</span> jenkins</span></span><br><span class="line"><span class="ruby">    <span class="symbol">environment:</span></span></span><br><span class="line"><span class="ruby">      <span class="symbol">JAVA_OPTS:</span> <span class="string">'-Djava.util.logging.config.file=/var/jenkins_home/log.properties'</span></span></span><br></pre></td></tr></table></figure></li><li><p>在docker-compose.yml的目录输入<code>docker-compose up -d</code></p></li><li><p>输入网址 ip + 端口访问，若显示页面，则jenkins启动成功</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210325092428652.png" alt="image-20210325092428652"></p></li></ul><h2 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h2><ol><li>如果创建任务时，没有maven项目选项，则在下载安装对应maven插件</li><li>如果构建环境没有send ssh选项，则下载安装对应Publish Over SSH插件</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker-compose-jenkins搭建部署&quot;&gt;&lt;a href=&quot;#docker-compose-jenkins搭建部署&quot; class=&quot;headerlink&quot; title=&quot;docker-compose + jenkins搭建部署&quot;&gt;&lt;/a&gt;docker
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java开发规范</title>
    <link href="https://blog.deschen.cn/2021/03/21/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://blog.deschen.cn/2021/03/21/Java%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2021-03-21T08:01:51.336Z</published>
    <updated>2021-03-21T13:45:12.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java开发规范"><a href="#Java开发规范" class="headerlink" title="Java开发规范"></a>Java开发规范</h1><p>[toc]</p><h2 id="一、使用-Deprecated使用时，要注解为什么废弃，新的接口是什么。"><a href="#一、使用-Deprecated使用时，要注解为什么废弃，新的接口是什么。" class="headerlink" title="一、使用@Deprecated使用时，要注解为什么废弃，新的接口是什么。"></a>一、使用@Deprecated使用时，要注解为什么废弃，新的接口是什么。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">模板：</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 对象、对象属性、方法的功能描述 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">  * 参考示例：对象、对象属性、方法的用法和结果 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">  * 废弃原因：为什么被废弃 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">  * 替代方案： &#123;<span class="doctag">@link</span> 相应的对象、对象属性、方法&#125; &lt;br/&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Deprecated</span></span><br><span class="line">  对象、对象属性、方法;</span><br><span class="line">    </span><br><span class="line">  替代的对象、对象属性、方法;</span><br><span class="line">    </span><br><span class="line">  同时，需要用单元测试判断是否能新的是否能替换旧的，使用单元测试校验 Assert.assertEquals()...</span><br><span class="line">    </span><br><span class="line">示例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderParam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象详情 </span></span><br><span class="line"><span class="comment">     * 参考示例：'[&#123;"count":22,"name":"商品1"&#125;,&#123;"count":33,"name":"商品2"&#125;]'</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 废弃原因：订单详情由JSON传参，改为对象传参。</span></span><br><span class="line"><span class="comment">     * 替代方案： &#123;<span class="doctag">@link</span> OrderCreateParam#orderItemParams&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">private</span> String orderItemDetail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItemParam&gt; orderItemParams;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他属性</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单元测试替代方案是否能替换过期属性</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderParam orderParam = <span class="keyword">new</span> OrderParam();</span><br><span class="line">        orderParam.setOrderItemDetail(<span class="string">"[&#123;\"count\":22,\"name\":\"商品1\"&#125;,&#123;\"count\":33,\"name\":\"商品2\"&#125;]"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;OrderItemParam&gt; orderItemParamList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        OrderItemParam orderItemParam1 = <span class="keyword">new</span> OrderItemParam();</span><br><span class="line">        orderItemParam1.setCount(<span class="number">22</span>);</span><br><span class="line">        orderItemParam1.setName(<span class="string">"商品1"</span>);</span><br><span class="line">        OrderItemParam orderItemParam2 = <span class="keyword">new</span> OrderItemParam();</span><br><span class="line">        orderItemParam2.setCount(<span class="number">33</span>);</span><br><span class="line">        orderItemParam2.setName(<span class="string">"商品2"</span>);</span><br><span class="line">        orderItemParamList.add(orderItemParam1);</span><br><span class="line">        orderItemParamList.add(orderItemParam2);</span><br><span class="line">        orderParam.setOrderItemParamList(orderItemParamList);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(orderParam.getOrderItemDetail(), JSON.toJSONString(orderParam.getOrderItemParamList()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java开发规范&quot;&gt;&lt;a href=&quot;#Java开发规范&quot; class=&quot;headerlink&quot; title=&quot;Java开发规范&quot;&gt;&lt;/a&gt;Java开发规范&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、使用-Deprecated使用时，要注解为什么废弃，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="https://blog.deschen.cn/2021/03/13/Java%E5%8F%8D%E5%B0%84/"/>
    <id>https://blog.deschen.cn/2021/03/13/Java%E5%8F%8D%E5%B0%84/</id>
    <published>2021-03-13T15:16:43.162Z</published>
    <updated>2021-03-14T05:22:23.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><p>[toc]</p><h2 id="一、什么是反射？"><a href="#一、什么是反射？" class="headerlink" title="一、什么是反射？"></a>一、什么是反射？</h2><ul><li><p>反射实在程序时动态加载类并获取类的详细信息，从而操作类或对象属性和方法。</p></li><li><p>本质在JVM中获取class对象，在对class对象反编译，从而获取对象的各种信息</p></li><li><p>类加载与反射原理图</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210313232232665.png" alt="image-20210313232232665"></p></li></ul><h2 id="二、反射的优缺点"><a href="#二、反射的优缺点" class="headerlink" title="二、反射的优缺点"></a>二、反射的优缺点</h2><ul><li>优点<ul><li>增加程序的灵活性，避免程序写死在代码里<ul><li>因为Java是先编译后运行的语言，要想实例一个类，那么必须修改源代码重新编译。而反射不需要通过编译获取，比如反射可以通过配置文件里面的类信息实例化某类</li></ul></li></ul></li><li>缺点<ul><li>影响程序性能：反射包括一些动态类型，所以JVM无法对代码进行修改，因此效率比非反射要低得多。在性能方面要求高的代码最好不要使用反射</li><li>内部暴露：反射可以执行一些正常情况下不允许的操作（比如访问私有方法和属性），所以反射会导致出乎意料的事件发生——代码有功能上错误，破坏抽象性</li></ul></li></ul><h3 id="三、反射的用途"><a href="#三、反射的用途" class="headerlink" title="三、反射的用途"></a>三、反射的用途</h3><ul><li>框架的开发，比如Spring框架的配置化，读取XML文件配置的Bean进行加载。</li></ul><h2 id="四、反射常用的类"><a href="#四、反射常用的类" class="headerlink" title="四、反射常用的类"></a>四、反射常用的类</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java.lang.Class;</span><br><span class="line"></span><br><span class="line">Java.lang.reflect<span class="function">.<span class="keyword">Constructor</span>;</span></span><br><span class="line"></span><br><span class="line">Java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">Java.lang.reflect<span class="function">.<span class="keyword">Method</span>;</span></span><br><span class="line"></span><br><span class="line">Java.lang.reflect.Modifier;</span><br></pre></td></tr></table></figure><h2 id="五、反射的基本使用"><a href="#五、反射的基本使用" class="headerlink" title="五、反射的基本使用"></a>五、反射的基本使用</h2><ul><li><p>获取Class</p><ul><li><p>调用对象的getClass方法</p></li><li><p>调用类的静态属性 class属性</p></li><li><p>调用Class的静态方法forName(“类全限定名“)(最常用)</p></li><li><p>三种比较判断</p><ul><li>三种方式中，常用第三种，第一种对象都有了还要反射干什么，第二种需要导入类包，依赖太强，不导包就抛编译错误。一般都使用第三种，一个字符串可以传入也可以写在配置文件中等多种方法。    </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类的三种方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、调用对象的getClass方法</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">12</span>);</span><br><span class="line">        Class&lt;? extends Person&gt; personClass1 = person.getClass();</span><br><span class="line">        System.out.println(personClass1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、调用类的静态属性 class属性</span></span><br><span class="line">        Class&lt;Person&gt; personClass2 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(personClass2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、调用Class的静态方法forName("类全限定名“)</span></span><br><span class="line">        Class&lt;?&gt; personClass3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            personClass3 = Class.forName(<span class="string">"cn.deschen.features.jdk8.cn.deschen.reflect.Person"</span>);</span><br><span class="line">            System.out.println(personClass3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行期间，一个类，只有一个Class对象产生，所以打印结果都是true；</span></span><br><span class="line">        System.out.println(personClass1 == personClass2);</span><br><span class="line">        System.out.println(personClass2 == personClass3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>判断是否为某个类的示例</p><ul><li>一般的，我们使用instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中Class对象的isInstance()方法来判断时候为某个类的实例，他是一个native方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否为某类实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isInstanceTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 1、使用instanceof判断</span></span><br><span class="line">      System.out.println(person <span class="keyword">instanceof</span> Person);</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 2、使用类.isInstance(实例)</span></span><br><span class="line">      System.out.println(Person<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">person</span>))</span>;</span><br><span class="line">      System.out.println(ReflectCase<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">person</span>))</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建实例：通过反射来生成对象主要有两种方法</p><ul><li>使用Class对象的newInstance()方法来创建Class对象对应类的实例。</li><li>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、使用Class对象的newInstance()方法来创建Class对象对应类的实例</span></span><br><span class="line">        Person person1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            person1 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(person1.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建对象，这种方法可以用指定的构造器构造类的实例。</span></span><br><span class="line">        Person person2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;Person&gt; constructor = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>()</span>;</span><br><span class="line">            person2 = constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exceptionalness e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(person2.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java反射&quot;&gt;&lt;a href=&quot;#Java反射&quot; class=&quot;headerlink&quot; title=&quot;Java反射&quot;&gt;&lt;/a&gt;Java反射&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、什么是反射？&quot;&gt;&lt;a href=&quot;#一、什么是反射？&quot; class=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nginx工作原理详解</title>
    <link href="https://blog.deschen.cn/2021/03/09/Nginx%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.deschen.cn/2021/03/09/Nginx%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-03-09T12:54:34.158Z</published>
    <updated>2021-03-09T13:16:20.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx工作原理讲解"><a href="#Nginx工作原理讲解" class="headerlink" title="Nginx工作原理讲解"></a>Nginx工作原理讲解</h1><p>[toc]</p><h2 id="一、Nginx工作过程"><a href="#一、Nginx工作过程" class="headerlink" title="一、Nginx工作过程"></a>一、Nginx工作过程</h2><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210309210052409.png" alt="image-20210309210052409"></p><ol><li>在nginx启动后，会有一个master进程和多个worker进程，master进程主要用来管理worker进程，包括：接受信号，将信号分发给worker进程，监听worker进程工作状态，当worker进程退出时(非正常)，启动新的worker进程。基本的网络事件会交给worker进程处理。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的 。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。 worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的 。</li><li>当master接收到重新加载的信号会怎么处理(./nginx -s reload)?，master会重新加载配置文件，然后启动新的进程，使用的新的worker进程来接受请求，并告诉老的worker进程他们可以退休了，老的worker进程将不会接受新的，老的worker进程处理完手中正在处理的请求就会退出。</li><li>worker进程是如何处理用户的请求呢？首先master会根据配置文件生成一个监听相应端口的socket，然后创建多个worker进程，这样每个worker就可以接受从socket过来的消息。当一个连接过来的时候，每一个worker都能接收到通知，但是只有一个worker能和这个连接建立关系，其他的worker都会连接失败，这就是所谓的惊群现象。为了解决这个问题，nginx提供一个共享锁accept_mutex，有了这个共享锁后，就会只有一个worker去接收这个连接。当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。</li></ol><h2 id="二、nginx的事件驱动机制"><a href="#二、nginx的事件驱动机制" class="headerlink" title="二、nginx的事件驱动机制"></a>二、nginx的事件驱动机制</h2><ul><li>为什么几个worker进程能同时接收上万的请求呢？这是因为nginx事件处理机制是异步非阻塞的。nginx将一个请求划分为多个阶段来异步处理模块，每个阶段只是处理请求的一部分，如果请求的这一部分发生阻塞，nginx不会等待，它会处理其他的请求的某一部分。</li><li>与传统web服务不同之处<ul><li>传统web服务器的每个事件消费者独占一个进程(线程)资源,这种情况对于用户规模较小的情况来说,用户响应速度快,但是当并发规模达到数十万上百万的时候,由于线程(进程)数目过多,会频繁的切换,而且当线程阻塞的时候会进行睡眠,也会造成资源的浪费,这样服务器就会产生瓶颈.</li><li>nginx服务器采用的事件驱动机制不同,他不会为每个消费事件创建一个进程或线程,这样就不会产生由于进程间频繁切换占用cpu而产生的瓶颈,而且nginx不会让事件阻塞,即采用无阻塞事件驱动模型,这样就不会因为事件阻塞使进程睡眠而造成的资源浪费.</li></ul></li></ul><h2 id="三、epoll库"><a href="#三、epoll库" class="headerlink" title="三、epoll库"></a>三、epoll库</h2><ul><li>epoll库是Nginx服务器支持的高性能事件驱动库之一。它是公认的最好的事件驱动模型。和poll库及select库有很大的区别。</li><li>poll和select都是创建一个待处理事件列表，然后把这个列表发给内核，返回的时候，再去轮询检查这个列表。以判断这个事件是否发生。在描述符太多的情况下，就会明显效率低下了。</li><li>epoll是这么做的，它把事件描述符列表的管理交给内核复制。一旦有某个事件发生，内核将发生事件的事件描述符交给Nginx的进程，而不是将整个事件描述符列表交给进程，让进程去轮询具体是哪个描述符。epoll()避免了轮询整个事件描述符列表。所以显得更高效。</li><li>epoll库的基本步骤：<ul><li>epoll库通过相关调用通知内核创建一个有N个描述符的事件列表，然后给这个事件列表设置自己关心的事件。并把它添加到内核中。在具体的代码中还可以实现对相关调用的事件描述符列表进行修改和删除。</li><li>一旦设置完成就一直等待内核通知事件发生了，某一事件发生后，内核就将发生事件的描述符给epoll库，epoll库去处理事件。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx工作原理讲解&quot;&gt;&lt;a href=&quot;#Nginx工作原理讲解&quot; class=&quot;headerlink&quot; title=&quot;Nginx工作原理讲解&quot;&gt;&lt;/a&gt;Nginx工作原理讲解&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、Nginx工作过程&quot;&gt;&lt;a 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Freemarker学习</title>
    <link href="https://blog.deschen.cn/2021/03/05/Freemarker%E5%AD%A6%E4%B9%A0/"/>
    <id>https://blog.deschen.cn/2021/03/05/Freemarker%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-05T10:42:58.000Z</published>
    <updated>2021-03-17T16:29:59.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Freemarker学习"><a href="#Freemarker学习" class="headerlink" title="Freemarker学习"></a>Freemarker学习</h1><p>[toc]</p><blockquote><p>注意点：</p><p>1、Freemarker得注释是&lt;#–注释的内容–&gt;</p><p>2、Freemarker的标签必须完整，否则报错、失效</p></blockquote><h2 id="一、如何显示数据语法"><a href="#一、如何显示数据语法" class="headerlink" title="一、如何显示数据语法"></a>一、如何显示数据语法</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$&#123;num&#125;  # num八大基础类型</span><br><span class="line">$&#123;emp.name&#125;  # obj是对象，并且要满足javaBean的规范，以及该类要以public修饰，否则无法获取其属性</span><br><span class="line">$&#123;emp.date ? <span class="keyword">string</span>（'yyyy -MM-dd'）&#125;   # 日期输出 </span><br><span class="line"><span class="comment"># list遍历，item_has_next返回true / false，需要以string返回，否则报错</span></span><br><span class="line">&lt;#<span class="keyword">list</span> <span class="keyword">list</span> as item&gt;</span><br><span class="line">    &lt;div&gt;对象：$&#123;item&#125;, 索引：$&#123;item_index&#125;，是否有下一个：$&#123;item_has_next ? <span class="keyword">string</span>&#125;&lt;/div&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line"><span class="comment"># map遍历</span></span><br><span class="line">&lt;#<span class="keyword">list</span> map?keys as key&gt;</span><br><span class="line">&lt;div&gt;键：$&#123;key&#125; 键值：$&#123;map[key]&#125;, 索引：$&#123;key_index&#125;，是否有下一个：$&#123;key_has_next ? <span class="keyword">string</span>&#125;&lt;/div&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量存在，输出该变量，否则不输出</span></span><br><span class="line"><span class="variable">$&#123;</span>emp.name ? if_exists&#125;  </span><br><span class="line"><span class="variable">$&#123;</span>emp.name ! &#125;</span><br><span class="line"><span class="comment"># 变量不存在，取默认值xxx</span></span><br><span class="line"><span class="variable">$&#123;</span>emp.name ? default(<span class="string">"xxx"</span>)&#125;</span><br><span class="line"><span class="variable">$&#123;</span>emp.name ! <span class="string">"xxx"</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"123&lt;br&gt;456"</span> ? html&#125;    　<span class="comment"># 对字符串进行HTML编码，对html中特殊字符进行转义，即网页显示该字符串内容</span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"str"</span> ? cap_first&#125;    　　<span class="comment"># 使字符串第一个字母大写</span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"str"</span> ? uncap_first&#125;    　　<span class="comment"># 使字符串第一个字母大写</span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"Str"</span> ? lower_case&#125;       <span class="comment"># 将字符串转换成小写</span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"Str"</span> ? upper_case&#125;       <span class="comment"># 将字符串转换成大写</span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">" str "</span> ? trim&#125;           <span class="comment"># 去掉字符串前后的空白字符</span></span><br><span class="line"><span class="variable">$&#123;</span>str ? contains(<span class="string">"xx"</span>) ? string&#125;  <span class="comment"># 字符串是否包含"xxx",返回"true"或"false"</span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"你好 $&#123;emp.name !&#125;"</span>&#125;    <span class="comment"># 输出你好+变量名  </span></span><br><span class="line"><span class="variable">$&#123;</span><span class="string">"你好 "</span> + emp.name !&#125;        <span class="comment"># 使用+号来连接，输出你好+变量名</span></span><br><span class="line"><span class="variable">$&#123;</span>emp ? length&#125;      <span class="comment"># 字符串的长度</span></span><br><span class="line"><span class="variable">$&#123;</span>str ? index_of（<span class="string">"x"</span>）&#125;   <span class="comment"># 字符串对应"x"所在位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取子串</span></span><br><span class="line">&lt;<span class="comment">#assign str ="abcdefghijklmn"/&gt;</span></span><br><span class="line"><span class="variable">$&#123;</span>str ? substring(0 , <span class="number">4</span>)&#125;   <span class="comment"># 1、截取第0位到第3位，输出abcd</span></span><br><span class="line"><span class="variable">$&#123;</span>str[0]&#125; <span class="variable">$&#123;</span>str[<span class="number">4</span>]&#125;   <span class="comment"># 2、截取第0位和第4位结果是ae</span></span><br><span class="line"><span class="variable">$&#123;</span>str[<span class="number">1</span>..<span class="number">4</span>]&#125;         <span class="comment"># 3、截取第1位到第4位结果是bcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split分割字符串</span></span><br><span class="line">&lt;<span class="comment">#list "a|b|c" ? split("|") as item&gt;</span></span><br><span class="line"><span class="variable">$&#123;</span>item&#125;</span><br><span class="line">&lt;<span class="regexp">/#list&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、数字语法"><a href="#三、数字语法" class="headerlink" title="三、数字语法"></a>三、数字语法</h2><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign <span class="symbol">x</span> = <span class="number">2.582</span> /&gt;</span><br><span class="line">$&#123;<span class="symbol">x</span> ? <span class="built_in">string</span>.number&#125;  # 数字 <span class="number">2.582</span></span><br><span class="line">$&#123;<span class="symbol">x</span> ? <span class="built_in">string</span>.currency&#125;  # 货币 ￥<span class="number">2.58</span>  小数点<span class="number">2</span>位</span><br><span class="line">$&#123;<span class="symbol">x</span> ? <span class="built_in">string</span>.percent&#125;  # 百分号 <span class="number">258</span>%  无小数点</span><br><span class="line">$&#123;<span class="symbol">x</span> ? int&#125;  # 整型<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 数字格式化插值可采用＃&#123;expr; format&#125;形式来格式化数字，其中格式可以是</span><br><span class="line"># mX：小数部分最小X位</span><br><span class="line"># MX：小数部分最大X位</span><br><span class="line">&lt;#assign <span class="symbol">x</span> = <span class="number">2.582</span> /&gt;</span><br><span class="line">&lt;#assign <span class="symbol">y</span> = <span class="number">4</span> /&gt; </span><br><span class="line">&#123;<span class="symbol">x</span>; M2&#125; <span class="comment">//输出2.58 </span></span><br><span class="line">&#123;<span class="symbol">y</span>; M2&#125; <span class="comment">//输出4 </span></span><br><span class="line">&#123;<span class="symbol">x</span>; m2&#125; <span class="comment">//输出2.58 </span></span><br><span class="line">&#123;Y; m2&#125; <span class="comment">//输出4.0</span></span><br><span class="line">&#123;<span class="symbol">x</span>; m1M2&#125; <span class="comment">//输出2.58 </span></span><br><span class="line">&#123;<span class="symbol">x</span>; m1M2&#125; <span class="comment">//输出4.0</span></span><br></pre></td></tr></table></figure><h2 id="四、运算算符"><a href="#四、运算算符" class="headerlink" title="四、运算算符"></a>四、运算算符</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">表达式中支持的比较运算符符如下几个：</span><br><span class="line">=或==：判断两个值是否相等。</span><br><span class="line">！=：判断两个值是否不等。</span><br><span class="line">&gt; 或 gt：判断左边值是否大于右边值</span><br><span class="line">&lt;= 或 lte：判断左边值是否小于等于右边值</span><br><span class="line"></span><br><span class="line">算数运算符</span><br><span class="line">加减乘除：+, -, *, /, ％</span><br><span class="line">注意：</span><br><span class="line">（<span class="number">1</span>）运算符两边必须是数字</span><br><span class="line">（<span class="number">2</span>）使用+运算符时，如果一边是数字，一边是字符串，就会自动将数字转换为字符串再连接，</span><br><span class="line">     如：$ &#123;<span class="number">3</span> +“<span class="number">5</span>”&#125;，结果是：<span class="number">35</span></span><br><span class="line">     </span><br><span class="line">逻辑运算符</span><br><span class="line">逻辑与：&amp;&amp; </span><br><span class="line">逻辑或：|| </span><br><span class="line">逻辑非：！</span><br><span class="line">逻辑运算符只能作用于布尔值，否则将产生错误</span><br><span class="line"></span><br><span class="line">运算符优先级如下（由高到低排列）</span><br><span class="line"><span class="number">1</span>、一元运算符：！</span><br><span class="line"><span class="number">2</span>、内建函数：</span><br><span class="line"><span class="number">3</span>、乘除法：*，/，％</span><br><span class="line"><span class="number">4</span>、加减法： - ，+ </span><br><span class="line"><span class="number">5</span>、比较：&gt;，&lt;，&gt; =，&lt;=（lt，lte，gt，gte）</span><br><span class="line"><span class="number">6</span>、相等：==，=， ！= </span><br><span class="line"><span class="number">7</span>、逻辑与：&amp;&amp; </span><br><span class="line"><span class="number">8</span>、逻辑或：|| </span><br><span class="line"><span class="number">9</span>、数字范围：.. 实际上，我们在开发过程中应该使用括号来严格区分，这样的可读性好，出错少</span><br></pre></td></tr></table></figure><h2 id="五、条件判断"><a href="#五、条件判断" class="headerlink" title="五、条件判断"></a>五、条件判断</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> else逻辑判断</span><br><span class="line"><span class="comment"># 示例中conditioinN, N位序号。若其中不为空则执行该条件语句</span></span><br><span class="line">&lt;<span class="comment">#if condition1&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">&lt;<span class="comment">#elseif condition2&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">&lt;<span class="comment">#elseif condition3&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">&lt;<span class="comment">#else&gt;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">&lt;/<span class="comment">#if&gt;</span></span><br><span class="line"><span class="comment"># 注意点：$&#123;..&#125;只能用于文本部分,不能用于表达式</span></span><br><span class="line">比如：</span><br><span class="line">&lt;<span class="comment">#if $&#123;isBig&#125;&gt;Wow!&lt;/#if&gt;   # 错误</span></span><br><span class="line">&lt;<span class="comment">#if isBig&gt;Wow!&lt;/#if&gt; #正确</span></span><br><span class="line"></span><br><span class="line">switch</span><br><span class="line"><span class="comment"># 跟java的switch一样，注意break，若无break，则执行后不跳出，而是直接执行下面的语句</span></span><br><span class="line">&lt;<span class="comment">#switch value&gt; </span></span><br><span class="line">&lt;<span class="comment">#case refValue1&gt; </span></span><br><span class="line"><span class="string">....</span></span><br><span class="line">&lt;<span class="comment">#break&gt; </span></span><br><span class="line">&lt;<span class="comment">#case refValue2&gt; </span></span><br><span class="line"><span class="string">....</span></span><br><span class="line">&lt;<span class="comment">#break&gt; </span></span><br><span class="line">&lt;<span class="comment">#case refValueN&gt; </span></span><br><span class="line"><span class="string">....</span></span><br><span class="line">&lt;<span class="comment">#break&gt; </span></span><br><span class="line">&lt;<span class="comment">#default&gt; </span></span><br><span class="line"><span class="string">....</span> </span><br><span class="line">&lt;/<span class="comment">#switch&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六、支持转义字符"><a href="#六、支持转义字符" class="headerlink" title="六、支持转义字符"></a>六、支持转义字符</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\"</span> ：双引号(u0022)</span><br><span class="line"><span class="string">\'</span> ：单引号(u0027)</span><br><span class="line"><span class="string">\\</span> ：反斜杠(u005C)</span><br><span class="line"><span class="string">\n</span> ：换行(u000A)</span><br><span class="line"><span class="string">\r</span> ：回车(u000D)</span><br><span class="line"><span class="string">\t</span> ：Tab(u0009)</span><br><span class="line"><span class="string">\b</span> ：退格键(u0008)</span><br><span class="line"><span class="string">\f</span> ：Form feed(u000C)</span><br><span class="line"><span class="string">\l</span> ：&lt;</span><br><span class="line"><span class="string">\g</span> ：&gt;</span><br><span class="line"><span class="string">\a</span> ：&amp;</span><br><span class="line"><span class="string">\&#123;</span> ：&#123;</span><br><span class="line"><span class="string">\xCode</span> ：直接通过<span class="number">4</span>位的<span class="number">16</span>进制数来指定Unicode码,输出该unicode码对应的字符.</span><br><span class="line"></span><br><span class="line">如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:</span><br><span class="line">$&#123;r<span class="string">"$&#123;foo&#125;"</span>&#125; <span class="regexp">// 输出 $&#123;foo&#125;</span></span><br><span class="line"><span class="regexp">$&#123;r"C:/foo/bar"&#125; //</span> 输出 C:/foo/bar</span><br></pre></td></tr></table></figure><h2 id="七、include指令"><a href="#七、include指令" class="headerlink" title="七、include指令"></a>七、include指令</h2><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"># include指令的作用类似于JSP的包含指令: 用于导入文件,它可以在模版中插入其他的静态文件,或者是freemarker模版如：宏组件</span></span><br><span class="line"><span class="xml"># 注意点：引入同名的变量时就会被后引入的或者新定义的覆盖.这样就不是很好,因为只想让它们在"My Test Library"命名空间中.就需要用 import代替include了</span></span><br><span class="line"><span class="xml">//父页面ftl</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">#include</span> "/<span class="attr">inc</span>/<span class="attr">top.ftl</span>"/&gt;</span>  </span></span><br><span class="line"><span class="xml">        姓名：$</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        性别：$</span><span class="template-variable">&#123;student.studentSex&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        年龄：$</span><span class="template-variable">&#123;student.studentAge&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        生日：$</span><span class="template-variable">&#123;(student.studentBirthday)?string("yyyy-MM-dd")&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        网站地址：$</span><span class="template-variable">&#123;student.studentAddr&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        QQ：$</span><span class="template-variable">&#123;student.studentQQ&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#if</span> <span class="attr">student.studentAge</span> <span class="attr">lt</span> <span class="attr">12</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">不是一个初中生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#elseif</span> <span class="attr">student.studentAge</span> <span class="attr">lt</span> <span class="attr">15</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">不是一个高中生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#elseif</span> <span class="attr">student.studentAge</span> <span class="attr">lt</span> <span class="attr">18</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">不是一个大学生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#else</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">是一个大学生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">#if</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">//子页面ftl</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎，进入学生管理系统！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="xml">// 结果</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎，进入学生管理系统！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">         姓名：$</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        性别：$</span><span class="template-variable">&#123;student.studentSex&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        年龄：$</span><span class="template-variable">&#123;student.studentAge&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        生日：$</span><span class="template-variable">&#123;(student.studentBirthday)?string("yyyy-MM-dd")&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        网站地址：$</span><span class="template-variable">&#123;student.studentAddr&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        QQ：$</span><span class="template-variable">&#123;student.studentQQ&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#if</span> <span class="attr">student.studentAge</span> <span class="attr">lt</span> <span class="attr">12</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">不是一个初中生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#elseif</span> <span class="attr">student.studentAge</span> <span class="attr">lt</span> <span class="attr">15</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">不是一个高中生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#elseif</span> <span class="attr">student.studentAge</span> <span class="attr">lt</span> <span class="attr">18</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">不是一个大学生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">#else</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">             $</span><span class="template-variable">&#123;student.studentName&#125;</span><span class="xml">是一个大学生  </span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">#if</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="八、import指令"><a href="#八、import指令" class="headerlink" title="八、import指令"></a>八、import指令</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 类似于jsp里的import：它导入文件，然后就可以在当前文件里使用被导入文件里的宏组件。除了不能像include一样导入静态文件外，其他都一样。为防止出现覆盖问题，把其放入另一个空间中。</span></span><br><span class="line"><span class="regexp"># mylib.ftl</span></span><br><span class="line"><span class="regexp">&lt;#macro copyright date&gt;   </span></span><br><span class="line"><span class="regexp">&lt;p&gt;Copyright (C) $&#123;date&#125; Julia Smith. All rights reserved.   </span></span><br><span class="line"><span class="regexp">&lt;/</span><span class="comment">#macro&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># common.ftl</span></span><br><span class="line">&lt;<span class="comment">#import "/libs/mylib.ftl" as my&gt;</span></span><br><span class="line">&lt;@my.copyright date=<span class="string">"1999-2002"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&lt;p&gt;Copyright (C) <span class="number">1999</span>-<span class="number">2002</span> Julia Smith. All rights reserved.   </span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 上面的代码将导入/lib</span><span class="regexp">/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中，"my"在freemarker里被称作namespace，防止同一变量被覆盖</span></span><br></pre></td></tr></table></figure><h2 id="九、macro宏指令"><a href="#九、macro宏指令" class="headerlink" title="九、macro宏指令"></a>九、macro宏指令</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;#-- 定义宏 --&gt;</span><br><span class="line"># <span class="keyword">test</span>是自定义标签名，并且注意自定义标签名会影响同名变量</span><br><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">test</span> foo bar=<span class="string">"Bar"</span> baaz=-1&gt; </span><br><span class="line">　　Text: <span class="variable">$&#123;foo&#125;</span>, <span class="variable">$&#123;bar&#125;</span>, <span class="variable">$&#123;baaz&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;#-- 使用宏 --&gt;</span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span> baaz=5*5/&gt;  <span class="comment">// 输出：Text: a, b, 25</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> bar=<span class="string">"b"</span>/&gt;    　　　　<span class="comment">// 输出：Text: a, b, -1</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span> baaz=5*5-2/&gt; 　　　　<span class="comment">// 输出：Text: a, Bar, 23</span></span><br><span class="line">&lt;@<span class="keyword">test</span> foo=<span class="string">"a"</span>/&gt;                   <span class="comment">// 输出：Text: a, Bar, -1</span></span><br><span class="line"></span><br><span class="line">&lt;#-- 定义一个循环输出的宏 --&gt;</span><br><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">list</span> title items&gt; </span><br><span class="line">　　<span class="variable">$&#123;title&#125;</span></span><br><span class="line">　　&lt;#<span class="keyword">list</span> items <span class="keyword">as</span> x&gt;</span><br><span class="line">　　　　<span class="variable">$&#123;x&#125;</span></span><br><span class="line">　　&lt;/#<span class="keyword">list</span>&gt; </span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt; </span><br><span class="line"></span><br><span class="line">&lt;#-- 使用宏 --&gt;</span><br><span class="line">&lt;@<span class="keyword">list</span> items=[<span class="string">"mouse"</span>, <span class="string">"elephant"</span>, <span class="string">"python"</span>] title=<span class="string">"Animals"</span>/&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Freemarker学习&quot;&gt;&lt;a href=&quot;#Freemarker学习&quot; class=&quot;headerlink&quot; title=&quot;Freemarker学习&quot;&gt;&lt;/a&gt;Freemarker学习&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意点：
      
    
    </summary>
    
    
      <category term="模板引擎" scheme="https://blog.deschen.cn/categories/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
    
      <category term="Freemarker" scheme="https://blog.deschen.cn/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>ELK部署——CentOS7.X</title>
    <link href="https://blog.deschen.cn/2021/02/03/ELK%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94CentOS7.X/"/>
    <id>https://blog.deschen.cn/2021/02/03/ELK%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94CentOS7.X/</id>
    <published>2021-02-03T10:42:58.000Z</published>
    <updated>2021-03-01T10:24:53.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELK部署——CentOS7-X"><a href="#ELK部署——CentOS7-X" class="headerlink" title="ELK部署——CentOS7.X"></a>ELK部署——CentOS7.X</h1><h2 id="一、创建用户角色"><a href="#一、创建用户角色" class="headerlink" title="一、创建用户角色"></a>一、创建用户角色</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">创建用户组：groupadd <span class="built_in">es</span></span><br><span class="line">创建用户加入用户组：useradd <span class="built_in">es</span> -g <span class="built_in">es</span></span><br></pre></td></tr></table></figure><h2 id="二、下载和安装"><a href="#二、下载和安装" class="headerlink" title="二、下载和安装"></a>二、下载和安装</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">下载：</span><br><span class="line">    wget https:<span class="comment">//artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.3.tar.gz</span></span><br><span class="line">    wget https:<span class="comment">//artifacts.elastic.co/downloads/logstash/logstash-6.2.3.tar.gz</span></span><br><span class="line">    wget https:<span class="comment">//artifacts.elastic.co/downloads/kibana/kibana-6.2.3-linux-x86_64.tar.gz</span></span><br><span class="line">解压：</span><br><span class="line">tar -zxvf elasticsearch<span class="number">-6.2</span><span class="number">.3</span>.tar.gz -C /usr/local</span><br><span class="line">tar -zxvf logstash<span class="number">-6.2</span><span class="number">.3</span>.tar.gz -C /usr/local</span><br><span class="line">tar -zxvf kibana<span class="number">-6.2</span><span class="number">.3</span>-linux-x86_64.tar.gz -C /usr/local</span><br><span class="line">给es授权</span><br><span class="line">chown -R es.es /usr/local/elasticsearch<span class="number">-6.2</span><span class="number">.3</span></span><br><span class="line">chown -R es.es /usr/local/logstash<span class="number">-6.2</span><span class="number">.3</span></span><br><span class="line">chown -R es.es /usr/local/kibana<span class="number">-6.2</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch配置：</span><br><span class="line">允许远程配置：</span><br><span class="line"><span class="keyword">cd</span> /usr/local/elasticsearch-<span class="number">6.2</span>.<span class="number">3</span></span><br><span class="line">elasticsearch-plugin install http<span class="variable">s:</span>//github.<span class="keyword">com</span>/medcl/elasticsearch-analysis-ik/releases/download/v7.<span class="number">6.2</span>/elasticsearch-analysis-ik-<span class="number">6.2</span>.<span class="number">3</span>.zip</span><br><span class="line"><span class="keyword">vi</span> config/elasticsearch.yml </span><br><span class="line">network.hos<span class="variable">t:</span> <span class="number">0.0</span>.<span class="number">0.0</span>  #改为<span class="number">0.0</span>.<span class="number">0.0</span>对外开放，如对特定ip开放则改为指定ip</span><br><span class="line">http.por<span class="variable">t:</span> <span class="number">9200</span>      #可更改端口不为<span class="number">9200</span></span><br><span class="line">修改配置，否则报异常：<span class="built_in">max</span> <span class="keyword">file</span> descriptors [<span class="number">4096</span>] <span class="keyword">for</span> elasticsearch process <span class="keyword">is</span> too low, increase <span class="keyword">to</span> at least [<span class="number">65535</span>]...</span><br><span class="line"><span class="keyword">vi</span> /etc/security/limits.<span class="keyword">conf</span>  # 在文末添加下面四个配置</span><br><span class="line">* soft nofile <span class="number">65536</span></span><br><span class="line">* hard nofile <span class="number">131072</span></span><br><span class="line">* soft nproc <span class="number">2048</span></span><br><span class="line">* hard nproc <span class="number">4096</span></span><br><span class="line">         <span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span></span><br><span class="line">         <span class="keyword">vm</span>.max_map_count=<span class="number">655360</span></span><br><span class="line">        </span><br><span class="line"> logstash配置：</span><br><span class="line"> <span class="keyword">cd</span> /usr/local/logstash-<span class="number">6.2</span>.<span class="number">3</span></span><br><span class="line"> logstash-plugin install logstash-codec-json_lines</span><br><span class="line"> <span class="keyword">vi</span> default.<span class="keyword">conf</span></span><br><span class="line"> # 监听<span class="number">5044</span>端口作为输入</span><br><span class="line">        <span class="built_in">input</span> &#123;</span><br><span class="line">            beats &#123;</span><br><span class="line">                port =&gt; <span class="string">"5044"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # 数据过滤</span><br><span class="line">        <span class="built_in">filter</span> &#123;</span><br><span class="line">            grok &#123;</span><br><span class="line">                <span class="keyword">match</span> =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"%&#123;COMBINEDAPACHELOG&#125;"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            geoip &#123;</span><br><span class="line">                <span class="keyword">source</span> =&gt; <span class="string">"clientip"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        # 输出配置为本机的<span class="number">9200</span>端口，这是ElasticSerach服务的监听端口</span><br><span class="line">        output &#123;</span><br><span class="line">            elasticsearch &#123;</span><br><span class="line">                hosts =&gt; [<span class="string">"127.0.0.1:9200"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">Kibana远程配置：</span><br><span class="line"><span class="keyword">cd</span> /usr/local/kibana-<span class="number">6.2</span>.<span class="number">3</span>-linux-x86_64</span><br><span class="line"><span class="keyword">vi</span> config/kibana.yml</span><br><span class="line">server.hos<span class="variable">t:</span> <span class="string">"0.0.0.0"</span></span><br><span class="line">elasticsearch.requestTimeou<span class="variable">t:</span> <span class="number">90000</span>  # 默认<span class="number">3000</span>会导致es连接失败</span><br></pre></td></tr></table></figure><h2 id="四、启动"><a href="#四、启动" class="headerlink" title="四、启动"></a>四、启动</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch</span><br><span class="line">切换账号：<span class="keyword">su</span> es</span><br><span class="line">启动：</span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/elasticsearch-6.2.3</span><br><span class="line">bin/elasticsearch -<span class="keyword">d</span>  # -<span class="keyword">d</span>后台启动</span><br><span class="line">     查看日志：tail -f logs/elasticsearch.<span class="keyword">log</span></span><br><span class="line">     测试：curl 127.0.0.1:9200</span><br><span class="line">     响应成功：</span><br><span class="line">     &#123;</span><br><span class="line">              <span class="string">"name"</span> : <span class="string">"mNuYQ8h"</span>,</span><br><span class="line">              <span class="string">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">              <span class="string">"cluster_uuid"</span> : <span class="string">"1JsAZO0sTnuBYCREW97RDw"</span>,</span><br><span class="line">              <span class="string">"version"</span> : &#123;</span><br><span class="line">                <span class="string">"number"</span> : <span class="string">"6.2.3"</span>,</span><br><span class="line">                <span class="string">"build_hash"</span> : <span class="string">"c59ff00"</span>,</span><br><span class="line">                <span class="string">"build_date"</span> : <span class="string">"2018-03-13T10:06:29.741383Z"</span>,</span><br><span class="line">                <span class="string">"build_snapshot"</span> : false,</span><br><span class="line">                <span class="string">"lucene_version"</span> : <span class="string">"7.2.1"</span>,</span><br><span class="line">                <span class="string">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">                <span class="string">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">            &#125;</span><br><span class="line">logstash</span><br><span class="line">启动：</span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/logstash-6.2.3</span><br><span class="line">bin/logstash -f default.<span class="keyword">conf</span> &amp;</span><br><span class="line">    查看日志：tail -f logs/logstash-plain.<span class="keyword">log</span></span><br><span class="line">Kibana</span><br><span class="line">切换账号：<span class="keyword">su</span> es</span><br><span class="line">启动：</span><br><span class="line"><span class="keyword">su</span></span><br><span class="line"><span class="keyword">cd</span> /usr/<span class="keyword">local</span>/kibana-6.2.3-linux-x86_64</span><br><span class="line">nohup bin/kibana &amp;</span><br><span class="line">查看日志：tail -f nohup.<span class="keyword">out</span></span><br></pre></td></tr></table></figure><h2 id="五、自启动"><a href="#五、自启动" class="headerlink" title="五、自启动"></a>五、自启动</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">以ES自启动为例</span><br><span class="line">cd /etc/init.d</span><br><span class="line">vim es-server</span><br><span class="line"></span><br><span class="line"><span class="comment">## 编写启动脚本</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#chkconfig: 345 63 37</span></span><br><span class="line"><span class="comment">#description: elasticsearch</span></span><br><span class="line"><span class="comment">#processname: elasticsearch-6.2.3</span></span><br><span class="line"><span class="comment">## 这个目录是你Es所在文件夹的目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ES_HOME</span>=/usr/local/elasticsearch-6.2.3</span><br><span class="line">case <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">        start)</span><br><span class="line">        ## es 是启动es的账户，如果你的不是这个记得调整</span><br><span class="line">                su es&lt;&lt;!</span><br><span class="line">                cd <span class="variable">$ES_HOME</span></span><br><span class="line">                ./bin/elasticsearch -d -p pid</span><br><span class="line">                exit</span><br><span class="line">!</span><br><span class="line">                echo <span class="string">"elasticsearch is started"</span></span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                <span class="attribute">pid</span>=`cat <span class="variable">$ES_HOME</span>/pid`</span><br><span class="line">                kill -9 <span class="variable">$pid</span></span><br><span class="line">                echo <span class="string">"elasticsearch is stopped"</span></span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                <span class="attribute">pid</span>=`cat <span class="variable">$ES_HOME</span>/pid`</span><br><span class="line">                kill -9 <span class="variable">$pid</span></span><br><span class="line">                echo <span class="string">"elasticsearch is stopped"</span></span><br><span class="line">                sleep 1</span><br><span class="line">                su elk&lt;&lt;!     【es 这个是启动es的账户，如果你的不是这个记得调整】</span><br><span class="line">                cd <span class="variable">$ES_HOME</span></span><br><span class="line">                ./bin/elasticsearch -d -p pid</span><br><span class="line">                exit</span><br><span class="line">!</span><br><span class="line">                echo <span class="string">"elasticsearch is started"</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo <span class="string">"start|stop|restart"</span></span><br><span class="line">        ;; </span><br><span class="line">esac</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line"><span class="comment">## 退出</span></span><br><span class="line">:wq!</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改文件权限</span></span><br><span class="line">chmod 777 es-server</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加系统服务，开机自启</span></span><br><span class="line">chkconfig --<span class="builtin-name">add</span> es-server</span><br><span class="line"></span><br><span class="line"><span class="comment">##  启动，关闭、重启服务</span></span><br><span class="line">service es-server start</span><br><span class="line">service es-server stop</span><br><span class="line">service es-server restart</span><br></pre></td></tr></table></figure><h2 id="六、切换ELK-7-x异常处理"><a href="#六、切换ELK-7-x异常处理" class="headerlink" title="六、切换ELK 7.x异常处理"></a>六、切换ELK 7.x异常处理</h2><p>ES问题：</p><ol><li><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210220152128686.png" alt="image-20210220152128686"></p></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">切换到es <span class="number">7</span>.x 目录：cd /usr/local/elasticsearch-<span class="number">7.6</span>.<span class="number">2</span></span><br><span class="line">修改配置文件：vi config/elasticsearch.yml</span><br><span class="line"><span class="keyword">node</span>.name:<span class="title"> node-1</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"node-1"</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210301143942570.png" alt="image-20210301143942570"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">切换到es <span class="number">7.</span>x 目录：cd /usr/local/elasticsearch<span class="number">-7.6</span><span class="number">.2</span></span><br><span class="line">配置文件添加：config/elasticsearch.yml</span><br><span class="line">xpack.ml.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210301144616286.png" alt="image-20210301144616286"></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">切换到root用户修改配置sysctl.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span> </span><br><span class="line"><span class="keyword">vm</span>.max_map_count=<span class="number">655360</span></span><br><span class="line">sysctl -<span class="keyword">p</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ELK部署——CentOS7-X&quot;&gt;&lt;a href=&quot;#ELK部署——CentOS7-X&quot; class=&quot;headerlink&quot; title=&quot;ELK部署——CentOS7.X&quot;&gt;&lt;/a&gt;ELK部署——CentOS7.X&lt;/h1&gt;&lt;h2 id=&quot;一、创建用户角色&quot;
      
    
    </summary>
    
    
      <category term="ELK" scheme="https://blog.deschen.cn/categories/ELK/"/>
    
    
      <category term="ELK" scheme="https://blog.deschen.cn/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>VMware——CentOS7.X部署</title>
    <link href="https://blog.deschen.cn/2021/01/28/VMware%E2%80%94%E2%80%94CentOS7-X%E9%83%A8%E7%BD%B2/"/>
    <id>https://blog.deschen.cn/2021/01/28/VMware%E2%80%94%E2%80%94CentOS7-X%E9%83%A8%E7%BD%B2/</id>
    <published>2021-01-28T02:26:20.000Z</published>
    <updated>2021-01-29T01:37:27.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMware——CentOS7-x部署"><a href="#VMware——CentOS7-x部署" class="headerlink" title="VMware——CentOS7.x部署"></a>VMware——CentOS7.x部署</h1><p>[toc]</p><h2 id="一、新建虚拟器"><a href="#一、新建虚拟器" class="headerlink" title="一、新建虚拟器"></a>一、新建虚拟器</h2><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210129093554506.png" alt="image-20210129093554506"></p><ul><li>确定好版本，要与自己软件一致</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210129093623268.png" alt="image-20210129093623268"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221170614834.png" alt="image-20201221170614834"></p><ul><li>要选择<strong>Linux</strong>系统，版本要跟自己下载的<strong>centos7.x</strong>一致</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221170652989.png" alt="image-20201221170652989"></p><ul><li><p>建议存放位置放在自定义的文件夹，方便管理</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221171956274.png" alt="image-20201221171956274"></p></li><li><p>设置处理器的和数，<strong>定情况而定</strong></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172108411.png" alt="image-20201221172108411"></p></li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172132879.png" alt="image-20201221172132879"></p><ul><li><p>接下来一直点击<strong>下一步</strong>，直到出现<strong>完成</strong>的这个界面，<strong>自定义硬件</strong></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172350769.png" alt="image-20201221172350769"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172534237.png" alt="image-20201221172534237"></p></li></ul><h2 id="二、安装centos-7-X"><a href="#二、安装centos-7-X" class="headerlink" title="二、安装centos 7.X"></a>二、安装centos 7.X</h2><blockquote><p>当看不见鼠标时，说明你点击了虚拟机，这时可以使用<strong>ctrl+alt</strong>跳出虚拟机</p></blockquote><ul><li><p>选择红框选项，按下回车键</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221172836938.png" alt="image-20201221172836938"></p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163036413.png" alt="image-20201221163036413" style="zoom: 67%;" /></li><li><p>设置时间，建议时区选择上海</p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163656843.png" alt="image-20201221163656843" style="zoom:80%;" /><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163629221.png" alt="image-20201221163629221" style="zoom:80%;" /></li><li><p>显示界面（这里我使用原始界面）</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221163927355.png" alt="image-20201221163927355"></p><p>PS：想要图形界面的话，可以选择方框选项</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164005808.png" alt="image-20201221164005808"></p></li><li><p>磁盘划分</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164114006.png" alt="image-20201221164114006"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164157112.png" alt="image-20201221164157112"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221164758435.png" alt="image-20201221164758435"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221165029626.png" alt="image-20201221165029626"></p></li></ul><h2 id="三、连接虚拟机"><a href="#三、连接虚拟机" class="headerlink" title="三、连接虚拟机"></a>三、连接虚拟机</h2><ul><li><p>启动虚拟机，输入<strong>ip addr</strong>，获取虚拟机的ip</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175212858.png" alt="image-20201221175212858"></p></li><li><p>本地使用<strong>CMD</strong>输入<strong>ping 192.168.163.132</strong>查看本地是否与虚拟机联通</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175344603.png" alt="image-20201221175344603"></p></li><li><p>虚拟机使用<strong>ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></strong> 查看虚拟机是否能联网</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175507224.png" alt="image-20201221175507224"></p></li><li><p>因为VM操作麻烦，建议使用xshell或其他软件连接虚拟机</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175924060.png" alt="image-20201221175924060"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221175800476.png" alt="image-20201221175800476"></p><p>PS：如果出现ping不通的情况，解决方法</p><ol><li><p>查看是否是网络适配器红框部分禁用了，如果是，就右键启动</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221180143248.png" alt="image-20201221180143248"></p></li><li><p>服务列表关于VM部分是否没启用</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20201221180327045.png" alt="image-20201221180327045"></p></li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VMware——CentOS7-x部署&quot;&gt;&lt;a href=&quot;#VMware——CentOS7-x部署&quot; class=&quot;headerlink&quot; title=&quot;VMware——CentOS7.x部署&quot;&gt;&lt;/a&gt;VMware——CentOS7.x部署&lt;/h1&gt;&lt;p&gt;[t
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IDEA Debug调试</title>
    <link href="https://blog.deschen.cn/2020/08/05/IDEA%20Debug%E8%B0%83%E8%AF%95/"/>
    <id>https://blog.deschen.cn/2020/08/05/IDEA%20Debug%E8%B0%83%E8%AF%95/</id>
    <published>2020-08-05T08:02:06.000Z</published>
    <updated>2021-03-21T15:59:06.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA-Debug调试"><a href="#IDEA-Debug调试" class="headerlink" title="IDEA Debug调试"></a>IDEA Debug调试</h1><p>[toc]</p><h2 id="一、为什么要调试"><a href="#一、为什么要调试" class="headerlink" title="一、为什么要调试"></a>一、为什么要调试</h2><ul><li>调试和日志是排查问题的两个主要手段。</li><li>如果没有调试功能，很多问题的排查更多地将依赖日志。但是日志我无法直观地了解代码运行的状态，无法实时地观察待调试地对象地各种属性值等</li><li>现在调试工具非常强大，很多调试器支持 “回退”，自定义表达式，远程调试等功能，对我们的学习和排查问题有很大帮助</li></ul><h2 id="二、调试的基本操作"><a href="#二、调试的基本操作" class="headerlink" title="二、调试的基本操作"></a>二、调试的基本操作</h2><ol><li>设置断点</li><li>调试模式运行</li><li>单步调试</li></ol><ul><li><p>以IDEA为例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321215809557.png" alt="image-20210321215809557"></p><ul><li>常见的调试功能按钮如上图所示（标有1~6的红框）<ul><li>1 表示 Step Over 即跳过，执行到下一行；</li><li>2 表示 Step Into 即步入，可以进入自定义的函数；</li><li>3 表示Force Step Into 即强制进入，可以进入到任何方法（包括第三方库或JDK源码）</li><li>4 表示 Step Out 即跳出，如果当前调试的方法没问题，可以使用此功能跳出当前函数；</li><li>5 表示 Drop frame 即移除帧，相当于回退到上一级；（以 “ JVM每执行一个方法会出现栈帧 ”理解）</li><li>6 表示 Run to Cursor 即执行到鼠标所在的代码行数。</li></ul></li><li>Variables（变量区）：用于观察 “当前” 的数据变化状况</li><li>Frames（栈帧）：用于记录执行的方法</li></ul></li></ul><h2 id="三、调试的高级技巧"><a href="#三、调试的高级技巧" class="headerlink" title="三、调试的高级技巧"></a>三、调试的高级技巧</h2><ol><li><p>多线程断点</p><ul><li><p>场景：直观调试多线程执行情况</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321222516302.png" alt="image-20210321222516302"></p></li><li><p>操作步骤</p><ul><li>设置断点时，在断点上右键可以选择断点的模式，选择 “Thread” 模式，可以开启多线程调试。</li><li>可以将一个线程断下来，通过 “Frames” 选项卡切换到不同线程线程（红框部分表示线程），控制不同线程的运<br>行。</li></ul></li></ul></li><li><p>条件断点</p><ul><li><p>场景：在测试环境中，如果设置普通断点，这样会对所有的请求暂停，影响其他功能调试</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321223027976.png" alt="image-20210321223027976"></p></li><li><p>操作步骤</p><ul><li>对断点设置条件，只有满足设置的条件才会生效。（这里使当 i 等于 4 时打上断点）</li></ul></li><li><p>PS：如果我们想对某个成员变量修改的地方打断点，但是修改的地方特别多怎么办？</p><ul><li><p>可以对属性设置条件</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321224048609.png" alt="image-20210321224048609"></p></li></ul></li></ul></li><li><p>“后悔药”，即回退方法</p><ul><li><p>场景：当我们有Resume Program或者Step Over跳到方法里面时，我们想要看到调用方法前的情况。</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321225511239.png" alt="image-20210321225511239"></p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321225517980.png" alt="image-20210321225517980"></p></li><li><p>操作步骤</p><ul><li>按<strong>红框的按键</strong>表示 Drop frame 即移除帧，相当于回退到上一级，这给我们提供了 “后悔药”。</li></ul></li></ul></li><li><p>“偷天换日”，即修改参数</p><ul><li><p>场景：我们实际调试代码时，会有这样的场景，调用的参数传错了。修改参数重新运行？</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321230027010.png" alt="image-20210321230027010"></p></li><li><p>操作步骤</p><ul><li>在 variables 选项卡中选中变量（这里时 count ），然后右键，选择 “set value” 菜单，即可对变<br>量的值进行修改。</li></ul></li></ul></li><li><p>表达式</p><ul><li><p>场景：设置或获取额外的信息，这对排查问题有很大帮助。</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321232011161.png" alt="image-20210321232011161"></p><ul><li>操作步骤有两种<ul><li>右键 <code>Evaluate Expression</code>，输入表达式获取额外信息</li></ul></li></ul></li></ul></li><li><p>watch</p><ul><li><p>场景：查看某个对象的某个属性，总是使用表达式很不方便，是否可以将表达式计算的结果总是显示在变量区域呢？</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321232017547.png" alt="image-20210321232017547"></p></li><li><p>操作步骤</p><ul><li>变量区<code>Variables</code>点击 <code>+</code> ，输入想要观察的表达式</li></ul></li></ul></li><li><p>看内存对象</p><ul><li><p>场景：想通过代码调试来研究内存对象</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321233053826.png" alt="image-20210321233053826"></p></li><li><p>操作步骤</p><ul><li>在 Memory 选项栏下，搜索 Integer 就可以看到该类对象的数量，双击就可以通过表达式来过滤，非常强大。</li></ul></li></ul></li><li><p>异常断点</p><ul><li><p>在一个循环中有一个数据报错，想在报错的时候断点，无法使用条件断点，而且循环次数很多，一次一次断掉放过非常麻烦。</p></li><li><p>测试用例</p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321234105069.png" alt="image-20210321234105069" style="zoom:150%;" /><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321234155317.png" alt="image-20210321234155317"></p></li><li><p>操作步骤</p><ul><li>第一步，在研究的地方断点（出异常的条件）</li><li>第二步：点击左下角的红色断点标记，打开断点设置界面</li><li>第三步：点击左上角的 + 号，添加 <code>Java Excepiton Breakpoints</code> 将异常（<code>IllegalArgumentException</code>)添加进去；</li><li>第四步：切换到我们的断点处，在断点处（如图所示<code>OrderParamTest.java:80</code>）的 处，在 “Disable untilbreakpoint is hit” 处选择该异常。</li><li>第五步：再执行断点调试，即可捕捉到发生异常的那次调用。通过调用栈查看整个调用过程，还可以通过移除 frame 来回退到上一层</li></ul></li></ul></li><li><p>远程调试</p><ul><li><p>场景：现在大多数公司的测试环境都会配置支持远程调试。</p></li><li><p>要求：远程调试要求本地代码和远程服务器的代码一致，如果使用 git ，切换到同一个分支的同一次提<br>交即可。</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321235336115.png" alt="image-20210321235336115"></p></li><li><p>操作步骤</p><ul><li>点击Edit Configurations</li><li>点击左上角 <code>+</code>，选择<code>Remote JVM Debug</code>，设置远程 host 及端口 port </li></ul></li></ul></li><li><p>其他</p><ul><li><p>例如主动抛出异常</p></li><li><p>测试用例</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210321235716527.png" alt="image-20210321235716527"></p><ul><li>操作步骤<ul><li>在 <code>Frames</code> 选择栈帧，右键选择 <code>Throw Exception</code> 抛出异常</li></ul></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IDEA-Debug调试&quot;&gt;&lt;a href=&quot;#IDEA-Debug调试&quot; class=&quot;headerlink&quot; title=&quot;IDEA Debug调试&quot;&gt;&lt;/a&gt;IDEA Debug调试&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、为什么要调试&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="编程工具" scheme="https://blog.deschen.cn/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>docker部署svn</title>
    <link href="https://blog.deschen.cn/2020/05/13/docker%E9%83%A8%E7%BD%B2svn/"/>
    <id>https://blog.deschen.cn/2020/05/13/docker%E9%83%A8%E7%BD%B2svn/</id>
    <published>2020-05-13T10:21:45.000Z</published>
    <updated>2021-03-26T09:32:13.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker部署svn"><a href="#docker部署svn" class="headerlink" title="docker部署svn"></a>docker部署svn</h1><p>[toc]</p><h2 id="一、下载svn的镜像文件"><a href="#一、下载svn的镜像文件" class="headerlink" title="一、下载svn的镜像文件"></a>一、下载svn的镜像文件</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索svn镜像</span></span><br><span class="line"><span class="attribute">docker</span> search svn</span><br></pre></td></tr></table></figure><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210326171514270.png" alt="image-20210326171514270"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 下拉镜像</span></span><br><span class="line">docker pull garethflowers/svn-<span class="keyword">server</span></span><br></pre></td></tr></table></figure><h2 id="二、运行svn容器"><a href="#二、运行svn容器" class="headerlink" title="二、运行svn容器"></a>二、运行svn容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行命令，将容器的svn挂在到本地svn，这样可以在本地修改，不用到容器内部修改</span></span><br><span class="line">docker run -v /opt/svn:/var/opt/svn --name svn -p 3690:3690 -d garethflowers/svn-server</span><br><span class="line"><span class="comment"># 跳转到/opt/svn目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt/svn</span><br><span class="line"><span class="comment"># 创建仓库，仓库名test</span></span><br><span class="line">svnadmin <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 修改配置文件授予权限</span></span><br><span class="line">- <span class="comment"># 跳转到/opt/svn/test/conf目录</span></span><br><span class="line">  <span class="built_in">cd</span> /opt/svn/<span class="built_in">test</span>/conf</span><br><span class="line">- <span class="comment"># 修改svnserve.conf,把注释去掉</span></span><br><span class="line">  anon-access = none     <span class="comment">#控制非鉴权用户访问版本库的权限</span></span><br><span class="line">  auth-access = write    <span class="comment">#控制鉴权用户访问版本库的权限</span></span><br><span class="line">  password-db = passwd   <span class="comment">#指定用户名口令文件名</span></span><br><span class="line">  authz-db = authz       <span class="comment">#指定权限配置文件</span></span><br><span class="line">- <span class="comment"># 修改passwd，添加用户和密码</span></span><br><span class="line">  <span class="built_in">test</span> = test123</span><br><span class="line">- <span class="comment"># 设置仓库权限</span></span><br><span class="line">  <span class="built_in">test</span> = <span class="built_in">test</span>  <span class="comment"># 第一个test是组名，第二个test是用户名</span></span><br><span class="line">  [<span class="built_in">test</span>:/]   <span class="comment"># test仓库名</span></span><br><span class="line">  @<span class="built_in">test</span> = rw   <span class="comment"># @组名</span></span><br><span class="line">  * = r</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 重启svn</span></span><br><span class="line">docker restart svn</span><br></pre></td></tr></table></figure><h2 id="三、测试svn是否可以访问"><a href="#三、测试svn是否可以访问" class="headerlink" title="三、测试svn是否可以访问"></a>三、测试svn是否可以访问</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本机测试</span></span><br><span class="line"><span class="attribute">curl</span> http://127.0.0.1:3690/test  <span class="comment"># test仓库名</span></span><br><span class="line">响应是如下图，则启动成功</span><br></pre></td></tr></table></figure><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210326172855979.png" alt="image-20210326172855979"></p><h2 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异常</span></span><br><span class="line">docker: <span class="builtin-name">Error</span> response <span class="keyword">from</span> daemon: driver failed programming external connectivity on endpoint svn (6de16f10af6e0d3c8865e8172c501c1872cc17947001d25b73011fc28cb9081c):  (iptables failed: iptables --wait -t<span class="built_in"> nat </span>-A DOCKER -p tcp -d 0/0 --dport 3690 -j DNAT --to-destination 172.17.0.2:3690 ! -i docker0: iptables: <span class="literal">No</span> chain/target/match by that name.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决方法</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker部署svn&quot;&gt;&lt;a href=&quot;#docker部署svn&quot; class=&quot;headerlink&quot; title=&quot;docker部署svn&quot;&gt;&lt;/a&gt;docker部署svn&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、下载svn的镜像文件&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="docker" scheme="https://blog.deschen.cn/categories/docker/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么使用ThreadPoolExecutor创建线程池</title>
    <link href="https://blog.deschen.cn/2020/03/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8ThreadPoolExecutor%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://blog.deschen.cn/2020/03/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8ThreadPoolExecutor%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-03-28T09:00:33.000Z</published>
    <updated>2021-03-20T15:04:37.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么使用ThreadPoolExecutor创建线程池"><a href="#为什么使用ThreadPoolExecutor创建线程池" class="headerlink" title="为什么使用ThreadPoolExecutor创建线程池"></a>为什么使用ThreadPoolExecutor创建线程池</h1><p>[toc]</p><h2 id="一、为什么要使用线程池"><a href="#一、为什么要使用线程池" class="headerlink" title="一、为什么要使用线程池"></a>一、为什么要使用线程池</h2><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h2 id="二、为什么不使用Excutors创建线程"><a href="#二、为什么不使用Excutors创建线程" class="headerlink" title="二、为什么不使用Excutors创建线程"></a>二、为什么不使用Excutors创建线程</h2><ul><li><p>阿里编程规范</p><ul><li><p>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors返回的线程池对象的弊端如下： </p><ul><li><p><code>FixedThreadPool和SingleThreadPool</code>： 允许的<strong>请求队列</strong>长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量的请求，从而导致OOM。 </p></li><li><p><code>CachedThreadPool和ScheduledThreadPool</code>： 允许的创建<strong>线程数量</strong>为<code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致OOM。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个单线程化线程池，它只会用唯一的工作线程执行任务，保证所有任务按照指定顺序（FIFO，LIFO，优先级）执行</span></span><br><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</span></span><br><span class="line">Executors.newFixedThreadPool();</span><br><span class="line"><span class="comment">// 创建一个定长线程池，可控制线程最大并发数，超出线程会在队列中等待</span></span><br><span class="line">Executors.newCachedThreadPool();  </span><br><span class="line"><span class="comment">// 创建一个定长线程池，支持定时及周期性任务执行</span></span><br><span class="line">Executors.newScheduledThreadPool();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ThreadPoolExecutor创建线程池的优势</p><ul><li>在创建线程池时需根据自己的情况来合理设置线程池。ThreadPoolExecutor构造方法提供了多种参数定义线程池。具体说明如下</li></ul></li></ul></li></ul><h2 id="三、使用ThreadPoolExecutor创建线程池"><a href="#三、使用ThreadPoolExecutor创建线程池" class="headerlink" title="三、使用ThreadPoolExecutor创建线程池"></a>三、使用ThreadPoolExecutor创建线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">    * parameters and default thread factory.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">    *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">    *        pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">    *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">    *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">    *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">    *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">    *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">    *         or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), handler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><code>corePoolSize</code> &amp; <code>maximumPoolSize</code><ul><li><code>corePoolSize</code>：核心线程数。如果没有设置<code>allowCoreThreadTimeOut</code>超时时间，那么空闲的线程不会销毁</li><li>````maximumPoolSize``：最大线程数。线程池允许的最大线程数</li><li>当一个新任务被提交到池中，如果当前运行线程小于核心线程数<code>corePoolSize</code>，即使当前有空闲线程，也会新建一个线程来处理新提交的任务；如果当前运行线程数大于核心线程数<code>corePoolSize</code>并小于最大线程数<code>maximumPoolSize</code>，只有当等待队列已满的情况下才会新建线程。</li></ul></li><li><code>keepAliveTime</code> &amp; <code>unit</code><ul><li><code>keepAliveTime</code>：超过核心线程数的线程最大空闲时间。</li><li><code>unit</code>：<code>keepAliveTime</code>的时间单位</li></ul></li><li><code>workQueue</code>：等待队列：用于移交或者保存提交（执行``execute<code>方法）的任务（</code>Runnable`的任务），但线程池中线程执行完后就执行队列任务。<ul><li>如果运行线程数小于<code>corePoolSize</code>，提交新任务时就会新建一个线程来运行；</li><li>如果运行线程数大于或等于<code>corePoolSize</code>，新提交的任务就会入列等待；如果队列已满，并且运行线程数小于<code>maximumPoolSize</code>，也将会新建一个线程来运行；</li><li>如果线程数大于<code>maximumPoolSize</code>，新提交的任务将会根据<strong>拒绝策略</strong>来处理。</li><li>三种通用的<strong>入队策略</strong>（PS：<strong>不是拒绝策略</strong>）<ul><li><strong>直接传递</strong>：通过·<code>SynchronousQueue</code> 直接把任务传递给线程。如果当前没可用线程，尝试入队操作会失败，然后再创建一个新的线程。当处理可能具有内部依赖性的请求时，该策略会避免请求被锁定。直接传递通常需要无界的最大线程数（<code>maximumPoolSize</code>），避免拒绝新提交的任务。当任务持续到达的平均速度超过可处理的速度时，可能导致线程的无限增长。</li><li><strong>无界队列</strong>：使用无界队列（如 <code>LinkedBlockingQueue</code>）作为等待队列，当所有的核心线程都在处理任务时， 新提交的任务都会进入队列等待。因此，不会有大于 <code>corePoolSize</code> 的线程会被创建（<code>maximumPoolSize</code>也将失去作用）。这种策略适合每个任务都完全独立于其他任务的情况；例如网站服务器。这种类型的等待队列可以使瞬间爆发的高频请求变得平滑。当任务持续到达的平均速度超过可处理速度时，可能导致等待队列无限增长。</li><li><strong>有界队列</strong>：当使用有限的最大线程数时，有界队列（如 <code>ArrayBlockingQueue</code>）可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用：使用大的队列和小的线程数可以减少CPU使用率、系统资源和上下文切换的开销，但是会导致吞吐量变低，如果任务频繁地阻塞（例如被I/O限制），系统就能为更多的线程调度执行时间。使用小的队列通常需要更多的线程数，这样可以最大化CPU使用率，但可能会需要更大的调度开销，从而降低吞吐量。</li></ul></li></ul></li><li><code>handler</code>：当线程池已经关闭或达到饱和（最大线程和队列都已满）状态时，新提交的任务将会被拒绝。<ul><li>ThreadPoolExecutor 定义了四种拒绝策略：<ul><li><strong>AbortPolicy</strong>：默认策略，在需要拒绝任务时抛出``RejectedExecutionException`；</li><li><strong>CallerRunsPolicy</strong>：直接在 <code>execute</code> 方法的调用线程中运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃；</li><li><strong>DiscardPolicy</strong>：直接丢弃任务；</li><li><strong>DiscardOldestPolicy</strong>：丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池已经关闭，任务将被丢弃。</li></ul></li><li>我们也可以自定义拒绝策略，只需要实现<code>RejectedExecutionHandler</code>；需要注意的是，拒绝策略的运行需要指定线程池和队列的容量</li></ul></li></ul></li></ul><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>线程池执行流程图</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210320222223985.png" alt="image-20210320222223985"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadPoolExecutor创建线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//核心线程数</span></span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//超过 corePoolSize 线程数量的线程最大空闲时间</span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//以秒为时间单位</span></span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">        <span class="comment">//创建工作队列，用于存放提交的等待执行任务</span></span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建线程池</span></span><br><span class="line">            threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">                    maximumPoolSize,</span><br><span class="line">                    keepAliveTime,</span><br><span class="line">                    unit,</span><br><span class="line">                    workQueue,</span><br><span class="line">                    <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环提交任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//提交任务的索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = (i + <span class="number">1</span>);</span><br><span class="line">                threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="comment">//线程打印输出</span></span><br><span class="line">                    System.out.println(<span class="string">"大家好，我是线程："</span> + index);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//模拟线程执行时间，10s</span></span><br><span class="line">                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                        <span class="comment">// System.out.println("线程" + index + "执行完");</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//每个任务提交后休眠500ms再提交下一个任务，用于保证提交顺序</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPoolExecutor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 单元测试中主线程执行完，不管子线程是否执行都会关闭程序，所以要使主线程等待到子线程全部执行完</span></span><br><span class="line">            <span class="comment">// 而mian()方法则不会，他会等待子线程执行完关闭程序</span></span><br><span class="line">            Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果预估</p><ul><li><p>因为最大线程数<code>maximumPoolSize</code>是6，<code>队列</code>容量是2时，即执行线程数超过8时，就会执行拒绝策略</p></li><li><p>不超过就执行<strong>流程图中流程2</strong>的过程</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210320223342834.png" alt="image-20210320223342834"></p></li><li><p>超过之后根据拒绝策略，判断是否放弃任务</p><ul><li><p>把执行的任务数量变成9，策略是<code>AbortPolicy</code>，在需要拒绝任务时抛出``RejectedExecutionException`</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210320223912156.png" alt="image-20210320223912156"></p></li><li><p>把执行的任务数量变成9，策略是<code>CallerRunsPolicy</code>，直接在 <code>execute</code> 方法的调用线程中运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210320224101466.png" alt="image-20210320224101466"></p></li><li><p>把执行的任务数量变成9，策略是<code>DiscardPolicy</code>，直接丢弃任务</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210320224212232.png" alt="image-20210320224212232"></p></li><li><p>把执行的任务数量变成9，策略是<code>DiscardOldestPolicy</code>，丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池已经关闭，任务将被丢弃</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210320224346228.png" alt="image-20210320224346228"></p></li></ul></li></ul><h2 id="五、线程池设置设置多大比较合适"><a href="#五、线程池设置设置多大比较合适" class="headerlink" title="五、线程池设置设置多大比较合适"></a>五、线程池设置设置多大比较合适</h2><ul><li><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul></li><li><p>如何判断是 CPU 密集任务还是 IO 密集任务？</p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么使用ThreadPoolExecutor创建线程池&quot;&gt;&lt;a href=&quot;#为什么使用ThreadPoolExecutor创建线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么使用ThreadPoolExecutor创建线程池&quot;&gt;&lt;/a&gt;为什
      
    
    </summary>
    
    
      <category term="多线程" scheme="https://blog.deschen.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadPoolExecutor" scheme="https://blog.deschen.cn/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>HashMap与ConcurrentHashMap原理</title>
    <link href="https://blog.deschen.cn/2020/03/05/HashMap%E4%B8%8EConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.deschen.cn/2020/03/05/HashMap%E4%B8%8EConcurrentHashMap%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-05T08:02:06.000Z</published>
    <updated>2021-02-03T11:56:47.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap与ConcurrentHashMap原理"><a href="#HashMap与ConcurrentHashMap原理" class="headerlink" title="HashMap与ConcurrentHashMap原理"></a>HashMap与ConcurrentHashMap原理</h1><h2 id="一、HashMap的数据结构"><a href="#一、HashMap的数据结构" class="headerlink" title="一、HashMap的数据结构"></a>一、HashMap的数据结构</h2><p>HashMap有数组+链表+红黑树组成</p><ul><li><p>通过hash函数得到存储地址，进而保存到数组中</p></li><li><p>当出现hash冲突时， hashmap采用的就是链地址法 ，在冲突的地址上生成一个链表，将冲突的元素的key，通过equals进行比较，相同即覆盖，不同则添加到链表</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 判断是否是同一个</span></span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="comment">// 判断键和值是否相同</span></span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>jdk1.8之后，就会转换为红黑树，理由：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     HashMap在JDK1.8及以后的版本中引入了红黑树结构，若桶中链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</span></span><br><span class="line"><span class="comment">还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</span></span><br><span class="line"><span class="comment">     虽然红黑树的时间复杂度时O(log(n))，比链表的时间复杂度O(n)低，</span></span><br><span class="line"><span class="comment">     而树节点的空间是普通节点空间的两倍</span></span><br><span class="line"><span class="comment">     规定：当节点数量小于8（移除或者扩容）时，就会变为链表，原因如下</span></span><br><span class="line"><span class="comment">     * Because TreeNodes are about twice the size of regular nodes, we</span></span><br><span class="line"><span class="comment">     * use them only when bins contain enough nodes to warrant use</span></span><br><span class="line"><span class="comment">     * (see TREEIFY_THRESHOLD). And when they become too small (due to</span></span><br><span class="line"><span class="comment">     * removal or resizing) they are converted back to plain bins.  In</span></span><br><span class="line"><span class="comment">     * usages with well-distributed user hashCodes, tree bins are</span></span><br><span class="line"><span class="comment">     * rarely used.  Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="comment">     * nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment">     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment">     * parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment">     * threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment">     * resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment">     * occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment">     * factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0:    0.60653066</span></span><br><span class="line"><span class="comment">     * 1:    0.30326533</span></span><br><span class="line"><span class="comment">     * 2:    0.07581633</span></span><br><span class="line"><span class="comment">     * 3:    0.01263606</span></span><br><span class="line"><span class="comment">     * 4:    0.00157952</span></span><br><span class="line"><span class="comment">     * 5:    0.00015795</span></span><br><span class="line"><span class="comment">     * 6:    0.00001316</span></span><br><span class="line"><span class="comment">     * 7:    0.00000094</span></span><br><span class="line"><span class="comment">     * 8:    0.00000006</span></span><br><span class="line"><span class="comment">     // 根据泊松分布得到hash冲突到第8个数的概率时千万分之6，接下来就概率时小于千万分之一</span></span><br><span class="line"><span class="comment">     // 因此时间和空间的权衡下，采用8作为链表和红黑树的阈值</span></span><br><span class="line"><span class="comment">     * more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h2 id="二、HashMap的构造方法"><a href="#二、HashMap的构造方法" class="headerlink" title="二、HashMap的构造方法"></a>二、HashMap的构造方法</h2><ul><li><p>默认构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =======================默认参数====================================</span></span><br><span class="line">    <span class="comment">// 默认容器为16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量2的30次方</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认加载因子 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转为红黑树的阈值8</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>自定义构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// 若初始化容量大于最大容量，就为最大容量2的30次方</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;  <span class="comment">// 加载因子0.75</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);   <span class="comment">// 容量的取值，取最近2的幂次的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 若n小于0，为1</span></span><br><span class="line">        <span class="comment">// 若n大于等于最大容量，为最大容量，否则为n+1</span></span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么要取2的幂次呢？</p><ul><li><p>取余的模运算与位运算相等,而且取模运算效率低于位运算效率。</p></li><li><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> % <span class="number">8</span> = <span class="number">4</span></span><br><span class="line"><span class="number">100</span> &amp; (<span class="number">8</span>-<span class="number">1</span>) = <span class="number">001100110</span> &amp; <span class="number">0111</span> = <span class="number">0110</span> = <span class="number">4</span> 等价</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组扩容时，仅仅关注 “特殊位” 就可以重新定位元素 </p><ul><li><p>因为数组扩容变成原来的2倍，即二进制向左移动一位，此时重新计算定位。按照公式`hash&amp;(length-1)``，原本扩容前被舍弃的<strong>高位部分的最后一位</strong>，也参与计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">扩容前 <span class="number">100</span> &amp; (<span class="number">8</span>-<span class="number">1</span>) = <span class="number">001100100</span> &amp; <span class="number">0111</span> = <span class="number">0100</span> = <span class="number">4</span></span><br><span class="line">扩容后 <span class="number">100</span> &amp; (<span class="number">16</span>-<span class="number">1</span>) = <span class="number">001100100</span> &amp; <span class="number">01111</span> = <span class="number">00100</span> = <span class="number">4</span></span><br><span class="line">===================================================</span><br><span class="line">扩容前 <span class="number">108</span> &amp; (<span class="number">8</span>-<span class="number">1</span>) = <span class="number">001101100</span> &amp; <span class="number">0111</span> = <span class="number">0100</span> = <span class="number">4</span></span><br><span class="line">扩容后 <span class="number">108</span> &amp; (<span class="number">16</span>-<span class="number">1</span>) = <span class="number">001101100</span> &amp; <span class="number">01111</span> = <span class="number">1100</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure></li><li><p>从中可以看出，根据高位最后一位为0，还是原来的索引，为1，就是原来索引+原来数组长</p></li></ul></li><li><p>hashmap在put时才会初始化数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2><ul><li>泊松分布： 是一种统计与概率学里常见到的离散机率分布 。 泊松分布适合于描述单位时间内随机事件发生的次数。  </li></ul><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583994301694.png" alt="1583994301694"></p><p>+ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap与ConcurrentHashMap原理&quot;&gt;&lt;a href=&quot;#HashMap与ConcurrentHashMap原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap与ConcurrentHashMap原理&quot;&gt;&lt;/a&gt;HashM
      
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.deschen.cn/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--类加载器</title>
    <link href="https://blog.deschen.cn/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://blog.deschen.cn/2020/02/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</id>
    <published>2020-02-29T09:37:09.000Z</published>
    <updated>2020-03-20T11:15:34.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–类加载器"><a href="#深入理解JVM–类加载器" class="headerlink" title="深入理解JVM–类加载器"></a>深入理解JVM–类加载器</h1><h2 id="一、类与类加载器的关系"><a href="#一、类与类加载器的关系" class="headerlink" title="一、类与类加载器的关系"></a>一、类与类加载器的关系</h2><ul><li><p>任意一个类,都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</p></li><li><p>每个类加载器都有各自的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。 </p></li></ul><h2 id="二、类加载器种类"><a href="#二、类加载器种类" class="headerlink" title="二、类加载器种类"></a>二、类加载器种类</h2><p>启动类加载器： 由C++编写，无法通过程序得到。主要负责加载JAVA中的 一些核心类库，主要是位于<JAVA_HOME>/lib/rt.jar中 </p><p>扩展类加载器： 要加载JAVA中的一些拓展类，主要位于<JAVA_HOME>/lib/ext </p><p>系统类加载器： 主要用于加载CLASSPATH路径下的类 </p><h2 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a>三、类加载机制</h2><p>全盘委托： 指当一个类加载器加载一个类时，除非显示地使用另一个类加载器，否则该类所依赖与引用的类也由这个类加载器加载。 </p><p>双亲委派： 一个类加载器要加载一个类时，先判断是否已被加载，如果没有，它会先委托自己的父类加载器来加载， 以此类推，直到启动类加载器无法加载，向下委托子类加载器加载 </p><h2 id="四、双亲委派模型源码分析"><a href="#四、双亲委派模型源码分析" class="headerlink" title="四、双亲委派模型源码分析"></a>四、双亲委派模型源码分析</h2><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583074859678.png" alt="1583074859678"></p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583075146217.png" alt="1583075146217">)<img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583075296256.png" alt="1583075296256"></p><p><img src="C:%5CUsers%5C20423%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583075400741.png" alt="1583075400741"></p><h2 id="五、自定义类加载器"><a href="#五、自定义类加载器" class="headerlink" title="五、自定义类加载器"></a>五、自定义类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.deschen.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        CustomClassLoader loader01 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"F:\\java-note\\jvm-note\\classes\\"</span>, <span class="string">".class"</span>, <span class="string">"loader01"</span>);</span><br><span class="line">        CustomClassLoader loader02 = <span class="keyword">new</span> CustomClassLoader(<span class="string">"F:\\java-note\\jvm-note\\classes\\"</span>, <span class="string">".class"</span>, <span class="string">"loader02"</span>);</span><br><span class="line">        Class&lt;?&gt; class01 = loader01.loadClass(<span class="string">"cn.deschen.jvm.gc.C"</span>);</span><br><span class="line">        System.out.println(<span class="string">"class01 类加载器："</span> + class01.getClassLoader());</span><br><span class="line">        Class&lt;?&gt; class02 = loader02.loadClass(<span class="string">"cn.deschen.jvm.gc.C"</span>);</span><br><span class="line">        System.out.println(<span class="string">"class02 类加载器："</span> + class02.getClassLoader());</span><br><span class="line">        <span class="comment">// 结果是false</span></span><br><span class="line">        <span class="comment">// 为什么都是C类，结果是false呢？ =》因为loader01与loader02不是同一个类加载器，因此类的命令空间不同，因此两个类是不一样的</span></span><br><span class="line">        System.out.println(<span class="string">"class01 == class02："</span> + (class01 == class02));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: java-note</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: deschen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义类加载器</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String loadPath;   <span class="comment">// 文件路径</span></span><br><span class="line">    <span class="keyword">private</span> String filePrefix;   <span class="comment">// 文件后缀</span></span><br><span class="line">    <span class="keyword">private</span> String loaderName;   <span class="comment">// 类加载器名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认应用类加载器作为自定义类加载器的父类加载器</span></span><br><span class="line"><span class="comment">     * 调用父类构造方法</span></span><br><span class="line"><span class="comment">     * java.lang.ClassLoader.ClassLoader()&#123;</span></span><br><span class="line"><span class="comment">     *     this(checkCreateClassLoader(), getSystemClassLoader());</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * getSystemClassLoader()就是应用程序类加载器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String loadPath, String filePrefix, String loaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.loadPath = loadPath;</span><br><span class="line">        <span class="keyword">this</span>.filePrefix = filePrefix;</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(ClassLoader parent, String loadPath, String filePrefix, String loaderName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置应用类加载器的父类加载器</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.loadPath = loadPath;</span><br><span class="line">        <span class="keyword">this</span>.filePrefix = filePrefix;</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoadPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loadPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadPath</span><span class="params">(String loadPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadPath = loadPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFilePrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> filePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilePrefix</span><span class="params">(String filePrefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePrefix = filePrefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoaderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoaderName</span><span class="params">(String loaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loaderName = loaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * class文件转换为字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  类的二进制名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bao = <span class="keyword">null</span>;</span><br><span class="line">        name = name.replace(<span class="string">"."</span>, <span class="string">"//"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(loadPath + name + filePrefix);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = fis.read())) &#123;</span><br><span class="line">               bao.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != bao) &#123;</span><br><span class="line">                    bao.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != fis) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bao.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、打破双亲委派机制"><a href="#六、打破双亲委派机制" class="headerlink" title="六、打破双亲委派机制"></a>六、打破双亲委派机制</h2><img src=" https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584533309335.png " alt="1584533309335" style="zoom:200%;" /><p>`</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–类加载器&quot;&gt;&lt;a href=&quot;#深入理解JVM–类加载器&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–类加载器&quot;&gt;&lt;/a&gt;深入理解JVM–类加载器&lt;/h1&gt;&lt;h2 id=&quot;一、类与类加载器的关系&quot;&gt;&lt;a href=&quot;#一、
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://blog.deschen.cn/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA 配置Gradle</title>
    <link href="https://blog.deschen.cn/2020/01/05/IDEA%20%E9%85%8D%E7%BD%AEGradle/"/>
    <id>https://blog.deschen.cn/2020/01/05/IDEA%20%E9%85%8D%E7%BD%AEGradle/</id>
    <published>2020-01-05T08:02:06.000Z</published>
    <updated>2021-03-22T09:24:54.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA-配置Gradle"><a href="#IDEA-配置Gradle" class="headerlink" title="IDEA 配置Gradle"></a>IDEA 配置Gradle</h1><p>[toc]</p><h2 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h2><ul><li><a href="https://gradle.org/releases/" target="_blank" rel="noopener">下载网址</a></li><li>解压到磁盘（如：D:\Gradle6.5.1）</li></ul><h2 id="二、配置win10环境变量"><a href="#二、配置win10环境变量" class="headerlink" title="二、配置win10环境变量"></a>二、配置win10环境变量</h2><ul><li><p>我的电脑 》右键》属性》高级系统设置 》高级》环境变量 》系统变量 》Path添加gradle的bin路径</p><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210322161606954.png" alt="image-20210322161606954"></p></li></ul><h2 id="三、IDEA配置Gradle"><a href="#三、IDEA配置Gradle" class="headerlink" title="三、IDEA配置Gradle"></a>三、IDEA配置Gradle</h2><ul><li><p>IDEA 》 setting 》Build，Execution… 》Build Tools 》 Gradle</p><ul><li>设置Gradle user home，用于存储 jar 包的仓库（可在全局setting设置）</li><li>点击项目，在Build and run using 和 Run tests using 设置为 IntelliJ IDEA，不然build很慢的</li><li>设置Use Gradle from 为 Specified location ，右边是gradle的安装目录</li><li>PS：全局setting只有Gradle user home，其他步骤只有在项目设置才会显示</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210322172320885.png" alt="image-20210322172320885"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IDEA-配置Gradle&quot;&gt;&lt;a href=&quot;#IDEA-配置Gradle&quot; class=&quot;headerlink&quot; title=&quot;IDEA 配置Gradle&quot;&gt;&lt;/a&gt;IDEA 配置Gradle&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;一、下载安装包&quot;
      
    
    </summary>
    
    
      <category term="编程工具" scheme="https://blog.deschen.cn/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是中台？</title>
    <link href="https://blog.deschen.cn/2019/12/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0%EF%BC%9F/"/>
    <id>https://blog.deschen.cn/2019/12/20/%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E5%8F%B0%EF%BC%9F/</id>
    <published>2019-12-20T12:53:20.000Z</published>
    <updated>2019-12-20T13:06:52.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是中台？"><a href="#什么是中台？" class="headerlink" title="什么是中台？"></a>什么是中台？</h1><h2 id="一、中台的介绍"><a href="#一、中台的介绍" class="headerlink" title="一、中台的介绍"></a>一、中台的介绍</h2><p>中台就是把企业各个业务线共用的、复用性高的功能独立开来，整合分析，变成为企业内部服务的功能</p><h2 id="二、举个栗子"><a href="#二、举个栗子" class="headerlink" title="二、举个栗子"></a>二、举个栗子</h2><p>我们都知道阿里上有淘宝、饿了么等各个不同体系的系统，对用户的分析就需要结合数据。如果没有中台概念，那么每个系统都回查询自己的用户中心，还要考虑同步数据的问题（即注册了淘宝账号，就要同步到其他系统的用户中心），这样开发成本高，维护难。</p><p>而中台就是把各个系统公共的功能独立开来，例如：把用户中心、订单中心、商品中心等独立开来，这些功能与各个系统对接，这样成本低，效率高。程序员可以更加专注业务方面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是中台？&quot;&gt;&lt;a href=&quot;#什么是中台？&quot; class=&quot;headerlink&quot; title=&quot;什么是中台？&quot;&gt;&lt;/a&gt;什么是中台？&lt;/h1&gt;&lt;h2 id=&quot;一、中台的介绍&quot;&gt;&lt;a href=&quot;#一、中台的介绍&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="中台" scheme="https://blog.deschen.cn/categories/%E4%B8%AD%E5%8F%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--七种垃圾收集器</title>
    <link href="https://blog.deschen.cn/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%83%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://blog.deschen.cn/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%83%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2019-10-11T08:18:05.000Z</published>
    <updated>2021-03-04T09:57:45.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–七种垃圾收集器"><a href="#深入理解JVM–七种垃圾收集器" class="headerlink" title="深入理解JVM–七种垃圾收集器"></a>深入理解JVM–七种垃圾收集器</h1><h2 id="一、垃圾收集器"><a href="#一、垃圾收集器" class="headerlink" title="一、垃圾收集器"></a>一、垃圾收集器</h2><ul><li><p>七种垃圾收集器组合</p><p> <img src="http://img.blog.csdn.net/20170102225015393" alt="img"></p></li><li><p>区域划分</p><ul><li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li><li>老年代收集器：Serial Old、Parallel Old、CMS；</li><li>整堆收集器：G1；</li></ul></li></ul><h2 id="二、并发垃圾收集和并行垃圾收集的区别"><a href="#二、并发垃圾收集和并行垃圾收集的区别" class="headerlink" title="二、并发垃圾收集和并行垃圾收集的区别"></a>二、并发垃圾收集和并行垃圾收集的区别</h2><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；如：ParNew、Parallel Scavenge、Parallel Old；</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）；用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1（也有并行）；</li></ul><h2 id="三、收集器详解"><a href="#三、收集器详解" class="headerlink" title="三、收集器详解"></a>三、收集器详解</h2><h3 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h3><p>Serial（串行）收集器收集器是<strong>最基本、历史最悠久</strong>的垃圾收集器了。大家看名字就知道这个收集器是一个<strong>单线程收集器</strong>了。它的单线程的意义不仅仅意味着它<strong>只会使用一条垃圾收集线程去完成垃圾收集</strong>工作，更重要的是<strong>它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521520253.png" alt="1584521520253"></p><h3 id="2、ParNew收集器"><a href="#2、ParNew收集器" class="headerlink" title="2、ParNew收集器"></a>2、ParNew收集器</h3><p>ParNew收集器其实就是<strong>Serial收集器的多线程版本</strong>，除了<strong>使用多线程进行垃圾收集外</strong>，<strong>其余行为</strong>（控制参数、收集算法、回收策略等等）和Serial收集器<strong>完全一样</strong>。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521563004.png" alt="1584521563004"></p><h3 id="3、Parallel-Scavenge收集器"><a href="#3、Parallel-Scavenge收集器" class="headerlink" title="3、Parallel Scavenge收集器"></a>3、Parallel Scavenge收集器</h3><p>Parallel Scavenge 收集器<strong>类似于ParNew 收集器，是Server 模式</strong>（内存大于2G，2个cpu）下的<strong>默认收集器</strong>，那么它有什么特别之处呢？</p><p>Parallel Scavenge收集器<strong>关注点是吞吐量（高效率的利用CPU）</strong>。所谓吞吐量就是<strong>CPU中用于运行用户代码的时间与CPU总消耗时间的比值</strong>。 </p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521574511.png" alt="1584521574511"></p><h3 id="4、Serial-Old收集器"><a href="#4、Serial-Old收集器" class="headerlink" title="4、Serial Old收集器"></a>4、Serial Old收集器</h3><p><strong>Serial</strong>收集器的<strong>老年代版本</strong>，它同样是一个<strong>单线程</strong>收集器。它主要有两大用途：一种用途是在<strong>JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用</strong>，另一种用途是作<strong>为CMS收集器的后备方案</strong>。  </p><h3 id="5、Parallel-Old收集器"><a href="#5、Parallel-Old收集器" class="headerlink" title="5、Parallel Old收集器"></a>5、Parallel Old收集器</h3><p> <strong>Parallel Scavenge</strong>收集器的<strong>老年代</strong>版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h3 id="6、CMS收集器"><a href="#6、CMS收集器" class="headerlink" title="6、CMS收集器"></a>6、CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标的收集器</strong>。它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让<strong>垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程(<strong>STW</strong>)，并记录下<strong>直接与root相连的对象，速度很快</strong> ；</li><li><strong>并发标记：</strong> <strong>同时开启GC和用户线程</strong>，用一个<strong>闭包结构</strong>去<strong>记录可达对象</strong>。但在这个阶段结束，这个闭包结构<strong>并不能保证包含当前所有的可达对象</strong>。因为<strong>用户线程</strong>可能会<strong>不断的更新引用域</strong>，所以GC线程无法保证可达性分析的<strong>实时性</strong>。所以这个算法里会<strong>跟踪记录这些发生引用更新的地方</strong>。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了<strong>修正</strong>并发标记期间因为用户程序继续运行而导致<strong>标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间一般<strong>会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</strong></li><li><strong>并发清除：</strong> 开启用户线程，同时<strong>GC线程开始对未标记的区域做清扫</strong>。</li></ul><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584521588277.png" alt="1584521588277"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li>对<strong>CPU资源敏感</strong>（会和服务抢资源）；</li><li><strong>无法处理浮动垃圾(</strong>在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；</li><li>它使用的回收算法<strong>-“标记-清除”</strong>算法会导致收集结束时会有大量空间碎片产生<strong>。</strong></li></ul><h3 id="7、G1收集器-XX-UseG1GC"><a href="#7、G1收集器-XX-UseG1GC" class="headerlink" title="7、G1收集器(-XX:+UseG1GC)"></a>7、G1收集器(-XX:+UseG1GC)</h3><p><strong>G1</strong> (Garbage-First)是一款<strong>面向服务器的垃圾收集器</strong>,主要针对配备<strong>多颗处理器及大容量内存的机器</strong>. 以极<strong>高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</strong>.</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image002.gif" alt="截图.png"></p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image004.gif" alt="截图.png"></p><p>G1将<strong>Java堆划分为多个大小相等的独立区域</strong>（<strong>Region</strong>），虽保留新生代和老年代的<strong>概念</strong>，但不再是<strong>物理隔阂</strong>了，它们都是（可以不连续）<strong>Region</strong>的集合。</p><p><strong>分配大对象</strong>（直接进<strong>Humongous区</strong>，专门<strong>存放短期巨型对象</strong>， <strong>当分配的对象大于等于Region大小的一半</strong>的时候就会被认为是巨型对象 ）不会因为无法找到连续空间而提前触发下一次GC。</p><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong>（initial mark，STW）：在此阶段，标记 GC Roots能直接关联到的对象。 需要停顿线程，但耗时很短 </li><li><strong>并发标记</strong>（Concurrent Marking）： GC Root开始对堆中对象进行<strong>可达性分析，找出存活的对象，</strong>这阶段耗时较长，但可与用户程序并发执行 </li><li><strong>最终标记</strong>（Remark，STW）： 修正在并发标记期间因<strong>用户程序继续运作而导致标记产生变动的那一部分标记记录</strong> </li><li><strong>筛选回收</strong>（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，<strong>根据用户所期望的GC停顿时间来制定回收计划</strong>.</li></ul><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/01/clip_image006.gif" alt="clipboard.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–七种垃圾收集器&quot;&gt;&lt;a href=&quot;#深入理解JVM–七种垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–七种垃圾收集器&quot;&gt;&lt;/a&gt;深入理解JVM–七种垃圾收集器&lt;/h1&gt;&lt;h2 id=&quot;一、垃圾收集器&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://blog.deschen.cn/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--四种垃圾收集算法</title>
    <link href="https://blog.deschen.cn/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%9B%9B%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.deschen.cn/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%9B%9B%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</id>
    <published>2019-10-11T07:56:36.000Z</published>
    <updated>2020-03-18T11:37:07.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–四种垃圾收集算法"><a href="#深入理解JVM–四种垃圾收集算法" class="headerlink" title="深入理解JVM–四种垃圾收集算法"></a>深入理解JVM–四种垃圾收集算法</h1><h2 id="一、标记-清除算法"><a href="#一、标记-清除算法" class="headerlink" title="一、标记-清除算法"></a>一、标记-清除算法</h2><p>算法分为“标记”和“清除”阶段：首先<strong>标记所有存活</strong>的对象，在标记完成后<strong>统一回收所有未标记</strong>的对象。它是最基础的收集算法，效率也很高。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584530746245.png" alt="1584530746245"></p><p>优点：执行效率高</p><p>缺点：1、标记清除后会产生大量不连续的碎片；2、分配速度慢，因为存在大量不连续碎片，每次分配都需要遍历空闲链表，找到足够大的内存空间存放对象</p><h2 id="二、复制算法"><a href="#二、复制算法" class="headerlink" title="二、复制算法"></a>二、复制算法</h2><p>为了解决标记-清除算法问题，“复制”收集算法出现了。它可以将<strong>内存分为大小相同的两块</strong>，<strong>每次使用其中的一块</strong>。当这一块的内存<strong>使用完后</strong>，就将<strong>还存活的对象有序复制到另一块</strong>去，然后再<strong>把使用的空间一次清理</strong>掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584530755486.png" alt="1584530755486"></p><p>优点：不存在大量不连续的内存碎片</p><p>缺点：使用效率低下，因为每次只使用其中一块内存空间</p><h2 id="三、标记-整理算法"><a href="#三、标记-整理算法" class="headerlink" title="三、标记-整理算法"></a>三、标记-整理算法</h2><p>根据老年代的特点特出的一种标记算法，<strong>标记</strong>过程仍然与<strong>“标记-清除”算法一样</strong>，清除的过程不同，让<strong>所有存活的对象向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>。</p><p><img src="https://root-1258715043.cos.ap-guangzhou.myqcloud.com/blog/1584530762589.png" alt="1584530762589"></p><p>优点：不存在大量不连续的内存碎片</p><p>缺点： 整理会花一定的时间 </p><h2 id="四、分代收集算法"><a href="#四、分代收集算法" class="headerlink" title="四、分代收集算法"></a>四、分代收集算法</h2><p>当前<strong>虚拟机的垃圾收集都采用分代收集算法</strong>，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块</strong>。一般将java堆分为新生代和老年代，这样我们就可以根据<strong>各个年代的特点选择合适的垃圾收集算法</strong>。</p><p>比如在<strong>新生代</strong>中，每次收集都会有<strong>大量对象死去</strong>，所以可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没<strong>有额外的空间对它进行分配担保</strong>，所以我们必须选择<strong>“标记-清除”或“标记-整理”</strong>算法进行垃圾收集。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–四种垃圾收集算法&quot;&gt;&lt;a href=&quot;#深入理解JVM–四种垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–四种垃圾收集算法&quot;&gt;&lt;/a&gt;深入理解JVM–四种垃圾收集算法&lt;/h1&gt;&lt;h2 id=&quot;一、标记-清除算法
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://blog.deschen.cn/categories/JVM/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解JVM--对象存活分析算法</title>
    <link href="https://blog.deschen.cn/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%A4%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.deschen.cn/2019/10/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%A4%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</id>
    <published>2019-10-11T06:24:15.000Z</published>
    <updated>2021-02-12T11:14:04.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JVM–对象存活分析算法"><a href="#深入理解JVM–对象存活分析算法" class="headerlink" title="深入理解JVM–对象存活分析算法"></a>深入理解JVM–对象存活分析算法</h1><blockquote><p> 堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p></blockquote><h2 id="一、引用计数法"><a href="#一、引用计数法" class="headerlink" title="一、引用计数法"></a>一、引用计数法</h2><ul><li><p>概念：给对象中添加一个<strong>引用计数器</strong>，每当有一个地方<strong>引用</strong>它，计数器就<strong>加1</strong>；当<strong>引用失效</strong>，计数器就减1；任何时候计数器<strong>为0</strong>的对象就是<strong>不可能再被使用</strong>的。</p></li><li><p>分析：这个方法实现<strong>简单，效率高</strong>，但是目前<strong>主流的虚拟机</strong>中并<strong>没有选择这个算法</strong>来管理内存，其最主要的<strong>原因是</strong>它很难解决<strong>对象之间相互循环引用</strong>的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象<strong>testA</strong> 和 <strong>testB</strong> <strong>相互引用</strong>着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的<strong>引用计数器都不为0</strong>，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test testA = <span class="keyword">new</span> Test();</span><br><span class="line">        Test testA = <span class="keyword">new</span> Test();</span><br><span class="line">        testA.setObj(testB);</span><br><span class="line">        testB.setObj(testA);</span><br><span class="line">        testA = <span class="keyword">null</span>;</span><br><span class="line">        testB = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、可达性分析算法"><a href="#二、可达性分析算法" class="headerlink" title="二、可达性分析算法"></a>二、可达性分析算法</h2><ul><li>概念：这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</li><li><strong>GC Roots</strong>根节点：<strong>类加载器</strong>、<strong>Thread</strong>、虚拟机栈的本地变量表、<strong>static成员</strong>、<strong>常量引用</strong>、本地方法栈的变量等等</li></ul><p><img src="https://deschen-storage.oss-cn-guangzhou.aliyuncs.com/image-20210212191352321.png" alt="image-20210212191352321"></p><ul><li><strong>finalize()</strong>方法最终判定对象<strong>是否存活</strong><ul><li>即使在可达性分析算法中<strong>不可达的对象</strong>，也<strong>并非是一定会被回收</strong>的。要真正宣告一个对象死亡，至少要经历<strong>再次标记</strong>过程。</li><li>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</li><li>标记过程：<ul><li>第一次标记。筛选的条件是此对象是否<strong>有必要执行finalize()</strong>方法。当对象<strong>没有覆盖finalize方法</strong>，或者<strong>finalize方法已经被虚拟机调用过</strong>，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。</li><li>第二次标记。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被<strong>放置在一个名为：F-Queue的队列</strong>之中，并在稍后由一条<strong>虚拟机自动建立的、低优先级的Finalizer线程</strong>去执行。这里所谓的“执行”是指虚拟机会<strong>触发这个方法，但并不承诺会等待它运行结束</strong>。这样做的原因是，如果一个对象f<strong>inalize()方法中执行缓慢，或者发生死循环（更极端的情况）</strong>，将很可能会导致F-Queue<strong>队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃</strong>。</li><li>finalize()–只要<strong>重新与引用链上的任何的一个对象建立关联</strong>即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JVM–对象存活分析算法&quot;&gt;&lt;a href=&quot;#深入理解JVM–对象存活分析算法&quot; class=&quot;headerlink&quot; title=&quot;深入理解JVM–对象存活分析算法&quot;&gt;&lt;/a&gt;深入理解JVM–对象存活分析算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 
      
    
    </summary>
    
    
      <category term="JVM" scheme="https://blog.deschen.cn/categories/JVM/"/>
    
    
  </entry>
  
</feed>
